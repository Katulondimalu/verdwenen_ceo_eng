{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar InvertedLuminanceSource_1 = require(\"../core/InvertedLuminanceSource\");\n\nvar LuminanceSource_1 = require(\"../core/LuminanceSource\");\n\nvar IllegalArgumentException_1 = require(\"../core/IllegalArgumentException\");\n/**\n * @deprecated Moving to @zxing/browser\n */\n\n\nvar HTMLCanvasElementLuminanceSource =\n/** @class */\nfunction (_super) {\n  __extends(HTMLCanvasElementLuminanceSource, _super);\n\n  function HTMLCanvasElementLuminanceSource(canvas) {\n    var _this = _super.call(this, canvas.width, canvas.height) || this;\n\n    _this.canvas = canvas;\n    _this.tempCanvasElement = null;\n    _this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(canvas);\n    return _this;\n  }\n\n  HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData = function (canvas) {\n    var imageData = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);\n    return HTMLCanvasElementLuminanceSource.toGrayscaleBuffer(imageData.data, canvas.width, canvas.height);\n  };\n\n  HTMLCanvasElementLuminanceSource.toGrayscaleBuffer = function (imageBuffer, width, height) {\n    var grayscaleBuffer = new Uint8ClampedArray(width * height);\n\n    for (var i = 0, j = 0, length_1 = imageBuffer.length; i < length_1; i += 4, j++) {\n      var gray = void 0;\n      var alpha = imageBuffer[i + 3]; // The color of fully-transparent pixels is irrelevant. They are often, technically, fully-transparent\n      // black (0 alpha, and then 0 RGB). They are often used, of course as the \"white\" area in a\n      // barcode image. Force any such pixel to be white:\n\n      if (alpha === 0) {\n        gray = 0xFF;\n      } else {\n        var pixelR = imageBuffer[i];\n        var pixelG = imageBuffer[i + 1];\n        var pixelB = imageBuffer[i + 2]; // .299R + 0.587G + 0.114B (YUV/YIQ for PAL and NTSC),\n        // (306*R) >> 10 is approximately equal to R*0.299, and so on.\n        // 0x200 >> 10 is 0.5, it implements rounding.\n\n        gray = 306 * pixelR + 601 * pixelG + 117 * pixelB + 0x200 >> 10;\n      }\n\n      grayscaleBuffer[j] = gray;\n    }\n\n    return grayscaleBuffer;\n  };\n\n  HTMLCanvasElementLuminanceSource.prototype.getRow = function (y\n  /*int*/\n  , row) {\n    if (y < 0 || y >= this.getHeight()) {\n      throw new IllegalArgumentException_1.default('Requested row is outside the image: ' + y);\n    }\n\n    var width = this.getWidth();\n    var start = y * width;\n\n    if (row === null) {\n      row = this.buffer.slice(start, start + width);\n    } else {\n      if (row.length < width) {\n        row = new Uint8ClampedArray(width);\n      } // The underlying raster of image consists of bytes with the luminance values\n      // TODO: can avoid set/slice?\n\n\n      row.set(this.buffer.slice(start, start + width));\n    }\n\n    return row;\n  };\n\n  HTMLCanvasElementLuminanceSource.prototype.getMatrix = function () {\n    return this.buffer;\n  };\n\n  HTMLCanvasElementLuminanceSource.prototype.isCropSupported = function () {\n    return true;\n  };\n\n  HTMLCanvasElementLuminanceSource.prototype.crop = function (left\n  /*int*/\n  , top\n  /*int*/\n  , width\n  /*int*/\n  , height\n  /*int*/\n  ) {\n    _super.prototype.crop.call(this, left, top, width, height);\n\n    return this;\n  };\n  /**\n   * This is always true, since the image is a gray-scale image.\n   *\n   * @return true\n   */\n\n\n  HTMLCanvasElementLuminanceSource.prototype.isRotateSupported = function () {\n    return true;\n  };\n\n  HTMLCanvasElementLuminanceSource.prototype.rotateCounterClockwise = function () {\n    this.rotate(-90);\n    return this;\n  };\n\n  HTMLCanvasElementLuminanceSource.prototype.rotateCounterClockwise45 = function () {\n    this.rotate(-45);\n    return this;\n  };\n\n  HTMLCanvasElementLuminanceSource.prototype.getTempCanvasElement = function () {\n    if (null === this.tempCanvasElement) {\n      var tempCanvasElement = this.canvas.ownerDocument.createElement('canvas');\n      tempCanvasElement.width = this.canvas.width;\n      tempCanvasElement.height = this.canvas.height;\n      this.tempCanvasElement = tempCanvasElement;\n    }\n\n    return this.tempCanvasElement;\n  };\n\n  HTMLCanvasElementLuminanceSource.prototype.rotate = function (angle) {\n    var tempCanvasElement = this.getTempCanvasElement();\n    var tempContext = tempCanvasElement.getContext('2d');\n    var angleRadians = angle * HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS; // Calculate and set new dimensions for temp canvas\n\n    var width = this.canvas.width;\n    var height = this.canvas.height;\n    var newWidth = Math.ceil(Math.abs(Math.cos(angleRadians)) * width + Math.abs(Math.sin(angleRadians)) * height);\n    var newHeight = Math.ceil(Math.abs(Math.sin(angleRadians)) * width + Math.abs(Math.cos(angleRadians)) * height);\n    tempCanvasElement.width = newWidth;\n    tempCanvasElement.height = newHeight; // Draw at center of temp canvas to prevent clipping of image data\n\n    tempContext.translate(newWidth / 2, newHeight / 2);\n    tempContext.rotate(angleRadians);\n    tempContext.drawImage(this.canvas, width / -2, height / -2);\n    this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(tempCanvasElement);\n    return this;\n  };\n\n  HTMLCanvasElementLuminanceSource.prototype.invert = function () {\n    return new InvertedLuminanceSource_1.default(this);\n  };\n\n  HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS = Math.PI / 180;\n  return HTMLCanvasElementLuminanceSource;\n}(LuminanceSource_1.default);\n\nexports.HTMLCanvasElementLuminanceSource = HTMLCanvasElementLuminanceSource;","map":{"version":3,"sources":["../../src/browser/HTMLCanvasElementLuminanceSource.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar InvertedLuminanceSource_1 = require(\"../core/InvertedLuminanceSource\");\nvar LuminanceSource_1 = require(\"../core/LuminanceSource\");\nvar IllegalArgumentException_1 = require(\"../core/IllegalArgumentException\");\n/**\n * @deprecated Moving to @zxing/browser\n */\nvar HTMLCanvasElementLuminanceSource = /** @class */ (function (_super) {\n    __extends(HTMLCanvasElementLuminanceSource, _super);\n    function HTMLCanvasElementLuminanceSource(canvas) {\n        var _this = _super.call(this, canvas.width, canvas.height) || this;\n        _this.canvas = canvas;\n        _this.tempCanvasElement = null;\n        _this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(canvas);\n        return _this;\n    }\n    HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData = function (canvas) {\n        var imageData = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);\n        return HTMLCanvasElementLuminanceSource.toGrayscaleBuffer(imageData.data, canvas.width, canvas.height);\n    };\n    HTMLCanvasElementLuminanceSource.toGrayscaleBuffer = function (imageBuffer, width, height) {\n        var grayscaleBuffer = new Uint8ClampedArray(width * height);\n        for (var i = 0, j = 0, length_1 = imageBuffer.length; i < length_1; i += 4, j++) {\n            var gray = void 0;\n            var alpha = imageBuffer[i + 3];\n            // The color of fully-transparent pixels is irrelevant. They are often, technically, fully-transparent\n            // black (0 alpha, and then 0 RGB). They are often used, of course as the \"white\" area in a\n            // barcode image. Force any such pixel to be white:\n            if (alpha === 0) {\n                gray = 0xFF;\n            }\n            else {\n                var pixelR = imageBuffer[i];\n                var pixelG = imageBuffer[i + 1];\n                var pixelB = imageBuffer[i + 2];\n                // .299R + 0.587G + 0.114B (YUV/YIQ for PAL and NTSC),\n                // (306*R) >> 10 is approximately equal to R*0.299, and so on.\n                // 0x200 >> 10 is 0.5, it implements rounding.\n                gray = (306 * pixelR +\n                    601 * pixelG +\n                    117 * pixelB +\n                    0x200) >> 10;\n            }\n            grayscaleBuffer[j] = gray;\n        }\n        return grayscaleBuffer;\n    };\n    HTMLCanvasElementLuminanceSource.prototype.getRow = function (y /*int*/, row) {\n        if (y < 0 || y >= this.getHeight()) {\n            throw new IllegalArgumentException_1.default('Requested row is outside the image: ' + y);\n        }\n        var width = this.getWidth();\n        var start = y * width;\n        if (row === null) {\n            row = this.buffer.slice(start, start + width);\n        }\n        else {\n            if (row.length < width) {\n                row = new Uint8ClampedArray(width);\n            }\n            // The underlying raster of image consists of bytes with the luminance values\n            // TODO: can avoid set/slice?\n            row.set(this.buffer.slice(start, start + width));\n        }\n        return row;\n    };\n    HTMLCanvasElementLuminanceSource.prototype.getMatrix = function () {\n        return this.buffer;\n    };\n    HTMLCanvasElementLuminanceSource.prototype.isCropSupported = function () {\n        return true;\n    };\n    HTMLCanvasElementLuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n        _super.prototype.crop.call(this, left, top, width, height);\n        return this;\n    };\n    /**\n     * This is always true, since the image is a gray-scale image.\n     *\n     * @return true\n     */\n    HTMLCanvasElementLuminanceSource.prototype.isRotateSupported = function () {\n        return true;\n    };\n    HTMLCanvasElementLuminanceSource.prototype.rotateCounterClockwise = function () {\n        this.rotate(-90);\n        return this;\n    };\n    HTMLCanvasElementLuminanceSource.prototype.rotateCounterClockwise45 = function () {\n        this.rotate(-45);\n        return this;\n    };\n    HTMLCanvasElementLuminanceSource.prototype.getTempCanvasElement = function () {\n        if (null === this.tempCanvasElement) {\n            var tempCanvasElement = this.canvas.ownerDocument.createElement('canvas');\n            tempCanvasElement.width = this.canvas.width;\n            tempCanvasElement.height = this.canvas.height;\n            this.tempCanvasElement = tempCanvasElement;\n        }\n        return this.tempCanvasElement;\n    };\n    HTMLCanvasElementLuminanceSource.prototype.rotate = function (angle) {\n        var tempCanvasElement = this.getTempCanvasElement();\n        var tempContext = tempCanvasElement.getContext('2d');\n        var angleRadians = angle * HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS;\n        // Calculate and set new dimensions for temp canvas\n        var width = this.canvas.width;\n        var height = this.canvas.height;\n        var newWidth = Math.ceil(Math.abs(Math.cos(angleRadians)) * width + Math.abs(Math.sin(angleRadians)) * height);\n        var newHeight = Math.ceil(Math.abs(Math.sin(angleRadians)) * width + Math.abs(Math.cos(angleRadians)) * height);\n        tempCanvasElement.width = newWidth;\n        tempCanvasElement.height = newHeight;\n        // Draw at center of temp canvas to prevent clipping of image data\n        tempContext.translate(newWidth / 2, newHeight / 2);\n        tempContext.rotate(angleRadians);\n        tempContext.drawImage(this.canvas, width / -2, height / -2);\n        this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(tempCanvasElement);\n        return this;\n    };\n    HTMLCanvasElementLuminanceSource.prototype.invert = function () {\n        return new InvertedLuminanceSource_1.default(this);\n    };\n    HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS = Math.PI / 180;\n    return HTMLCanvasElementLuminanceSource;\n}(LuminanceSource_1.default));\nexports.HTMLCanvasElementLuminanceSource = HTMLCanvasElementLuminanceSource;\n//# sourceMappingURL=HTMLCanvasElementLuminanceSource.js.map"]},"metadata":{},"sourceType":"script"}