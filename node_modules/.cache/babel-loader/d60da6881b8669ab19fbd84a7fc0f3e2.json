{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ResultPoint_1 = require(\"../../ResultPoint\");\n\nvar AztecDetectorResult_1 = require(\"../AztecDetectorResult\");\n\nvar MathUtils_1 = require(\"../../common/detector/MathUtils\");\n\nvar WhiteRectangleDetector_1 = require(\"../../common/detector/WhiteRectangleDetector\");\n\nvar GenericGF_1 = require(\"../../common/reedsolomon/GenericGF\");\n\nvar ReedSolomonDecoder_1 = require(\"../../common/reedsolomon/ReedSolomonDecoder\");\n\nvar NotFoundException_1 = require(\"../../NotFoundException\");\n\nvar GridSamplerInstance_1 = require(\"../../common/GridSamplerInstance\");\n\nvar Integer_1 = require(\"../../util/Integer\");\n\nvar Point =\n/** @class */\nfunction () {\n  function Point(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  Point.prototype.toResultPoint = function () {\n    return new ResultPoint_1.default(this.getX(), this.getY());\n  };\n\n  Point.prototype.getX = function () {\n    return this.x;\n  };\n\n  Point.prototype.getY = function () {\n    return this.y;\n  };\n\n  return Point;\n}();\n\nexports.Point = Point;\n/**\n * Encapsulates logic that can detect an Aztec Code in an image, even if the Aztec Code\n * is rotated or skewed, or partially obscured.\n *\n * @author David Olivier\n * @author Frank Yellin\n */\n\nvar Detector =\n/** @class */\nfunction () {\n  function Detector(image) {\n    this.EXPECTED_CORNER_BITS = new Int32Array([0xee0, 0x1dc, 0x83b, 0x707]);\n    this.image = image;\n  }\n\n  Detector.prototype.detect = function () {\n    return this.detectMirror(false);\n  };\n  /**\n   * Detects an Aztec Code in an image.\n   *\n   * @param isMirror if true, image is a mirror-image of original\n   * @return {@link AztecDetectorResult} encapsulating results of detecting an Aztec Code\n   * @throws NotFoundException if no Aztec Code can be found\n   */\n\n\n  Detector.prototype.detectMirror = function (isMirror) {\n    // 1. Get the center of the aztec matrix\n    var pCenter = this.getMatrixCenter(); // 2. Get the center points of the four diagonal points just outside the bull's eye\n    //  [topRight, bottomRight, bottomLeft, topLeft]\n\n    var bullsEyeCorners = this.getBullsEyeCorners(pCenter);\n\n    if (isMirror) {\n      var temp = bullsEyeCorners[0];\n      bullsEyeCorners[0] = bullsEyeCorners[2];\n      bullsEyeCorners[2] = temp;\n    } // 3. Get the size of the matrix and other parameters from the bull's eye\n\n\n    this.extractParameters(bullsEyeCorners); // 4. Sample the grid\n\n    var bits = this.sampleGrid(this.image, bullsEyeCorners[this.shift % 4], bullsEyeCorners[(this.shift + 1) % 4], bullsEyeCorners[(this.shift + 2) % 4], bullsEyeCorners[(this.shift + 3) % 4]); // 5. Get the corners of the matrix.\n\n    var corners = this.getMatrixCornerPoints(bullsEyeCorners);\n    return new AztecDetectorResult_1.default(bits, corners, this.compact, this.nbDataBlocks, this.nbLayers);\n  };\n  /**\n   * Extracts the number of data layers and data blocks from the layer around the bull's eye.\n   *\n   * @param bullsEyeCorners the array of bull's eye corners\n   * @throws NotFoundException in case of too many errors or invalid parameters\n   */\n\n\n  Detector.prototype.extractParameters = function (bullsEyeCorners) {\n    if (!this.isValidPoint(bullsEyeCorners[0]) || !this.isValidPoint(bullsEyeCorners[1]) || !this.isValidPoint(bullsEyeCorners[2]) || !this.isValidPoint(bullsEyeCorners[3])) {\n      throw new NotFoundException_1.default();\n    }\n\n    var length = 2 * this.nbCenterLayers; // Get the bits around the bull's eye\n\n    var sides = new Int32Array([this.sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length), this.sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length), this.sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length), this.sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length) // Top\n    ]); // bullsEyeCorners[shift] is the corner of the bulls'eye that has three\n    // orientation marks.\n    // sides[shift] is the row/column that goes from the corner with three\n    // orientation marks to the corner with two.\n\n    this.shift = this.getRotation(sides, length); // Flatten the parameter bits into a single 28- or 40-bit long\n\n    var parameterData = 0;\n\n    for (var i = 0; i < 4; i++) {\n      var side = sides[(this.shift + i) % 4];\n\n      if (this.compact) {\n        // Each side of the form ..XXXXXXX. where Xs are parameter data\n        parameterData <<= 7;\n        parameterData += side >> 1 & 0x7F;\n      } else {\n        // Each side of the form ..XXXXX.XXXXX. where Xs are parameter data\n        parameterData <<= 10;\n        parameterData += (side >> 2 & 0x1f << 5) + (side >> 1 & 0x1F);\n      }\n    } // Corrects parameter data using RS.  Returns just the data portion\n    // without the error correction.\n\n\n    var correctedData = this.getCorrectedParameterData(parameterData, this.compact);\n\n    if (this.compact) {\n      // 8 bits:  2 bits layers and 6 bits data blocks\n      this.nbLayers = (correctedData >> 6) + 1;\n      this.nbDataBlocks = (correctedData & 0x3F) + 1;\n    } else {\n      // 16 bits:  5 bits layers and 11 bits data blocks\n      this.nbLayers = (correctedData >> 11) + 1;\n      this.nbDataBlocks = (correctedData & 0x7FF) + 1;\n    }\n  };\n\n  Detector.prototype.getRotation = function (sides, length) {\n    // In a normal pattern, we expect to See\n    //   **    .*             D       A\n    //   *      *\n    //\n    //   .      *\n    //   ..    ..             C       B\n    //\n    // Grab the 3 bits from each of the sides the form the locator pattern and concatenate\n    // into a 12-bit integer.  Start with the bit at A\n    var cornerBits = 0;\n    sides.forEach(function (side, idx, arr) {\n      // XX......X where X's are orientation marks\n      var t = (side >> length - 2 << 1) + (side & 1);\n      cornerBits = (cornerBits << 3) + t;\n    }); // for (var side in sides) {\n    //     // XX......X where X's are orientation marks\n    //     var t = ((side >> (length - 2)) << 1) + (side & 1);\n    //     cornerBits = (cornerBits << 3) + t;\n    // }\n    // Mov the bottom bit to the top, so that the three bits of the locator pattern at A are\n    // together.  cornerBits is now:\n    //  3 orientation bits at A || 3 orientation bits at B || ... || 3 orientation bits at D\n\n    cornerBits = ((cornerBits & 1) << 11) + (cornerBits >> 1); // The result shift indicates which element of BullsEyeCorners[] goes into the top-left\n    // corner. Since the four rotation values have a Hamming distance of 8, we\n    // can easily tolerate two errors.\n\n    for (var shift = 0; shift < 4; shift++) {\n      if (Integer_1.default.bitCount(cornerBits ^ this.EXPECTED_CORNER_BITS[shift]) <= 2) {\n        return shift;\n      }\n    }\n\n    throw new NotFoundException_1.default();\n  };\n  /**\n   * Corrects the parameter bits using Reed-Solomon algorithm.\n   *\n   * @param parameterData parameter bits\n   * @param compact true if this is a compact Aztec code\n   * @throws NotFoundException if the array contains too many errors\n   */\n\n\n  Detector.prototype.getCorrectedParameterData = function (parameterData, compact) {\n    var numCodewords;\n    var numDataCodewords;\n\n    if (compact) {\n      numCodewords = 7;\n      numDataCodewords = 2;\n    } else {\n      numCodewords = 10;\n      numDataCodewords = 4;\n    }\n\n    var numECCodewords = numCodewords - numDataCodewords;\n    var parameterWords = new Int32Array(numCodewords);\n\n    for (var i = numCodewords - 1; i >= 0; --i) {\n      parameterWords[i] = parameterData & 0xF;\n      parameterData >>= 4;\n    }\n\n    try {\n      var rsDecoder = new ReedSolomonDecoder_1.default(GenericGF_1.default.AZTEC_PARAM);\n      rsDecoder.decode(parameterWords, numECCodewords);\n    } catch (ignored) {\n      throw new NotFoundException_1.default();\n    } // Toss the error correction.  Just return the data as an integer\n\n\n    var result = 0;\n\n    for (var i = 0; i < numDataCodewords; i++) {\n      result = (result << 4) + parameterWords[i];\n    }\n\n    return result;\n  };\n  /**\n   * Finds the corners of a bull-eye centered on the passed point.\n   * This returns the centers of the diagonal points just outside the bull's eye\n   * Returns [topRight, bottomRight, bottomLeft, topLeft]\n   *\n   * @param pCenter Center point\n   * @return The corners of the bull-eye\n   * @throws NotFoundException If no valid bull-eye can be found\n   */\n\n\n  Detector.prototype.getBullsEyeCorners = function (pCenter) {\n    var pina = pCenter;\n    var pinb = pCenter;\n    var pinc = pCenter;\n    var pind = pCenter;\n    var color = true;\n\n    for (this.nbCenterLayers = 1; this.nbCenterLayers < 9; this.nbCenterLayers++) {\n      var pouta = this.getFirstDifferent(pina, color, 1, -1);\n      var poutb = this.getFirstDifferent(pinb, color, 1, 1);\n      var poutc = this.getFirstDifferent(pinc, color, -1, 1);\n      var poutd = this.getFirstDifferent(pind, color, -1, -1); // d      a\n      //\n      // c      b\n\n      if (this.nbCenterLayers > 2) {\n        var q = this.distancePoint(poutd, pouta) * this.nbCenterLayers / (this.distancePoint(pind, pina) * (this.nbCenterLayers + 2));\n\n        if (q < 0.75 || q > 1.25 || !this.isWhiteOrBlackRectangle(pouta, poutb, poutc, poutd)) {\n          break;\n        }\n      }\n\n      pina = pouta;\n      pinb = poutb;\n      pinc = poutc;\n      pind = poutd;\n      color = !color;\n    }\n\n    if (this.nbCenterLayers !== 5 && this.nbCenterLayers !== 7) {\n      throw new NotFoundException_1.default();\n    }\n\n    this.compact = this.nbCenterLayers === 5; // Expand the square by .5 pixel in each direction so that we're on the border\n    // between the white square and the black square\n\n    var pinax = new ResultPoint_1.default(pina.getX() + 0.5, pina.getY() - 0.5);\n    var pinbx = new ResultPoint_1.default(pinb.getX() + 0.5, pinb.getY() + 0.5);\n    var pincx = new ResultPoint_1.default(pinc.getX() - 0.5, pinc.getY() + 0.5);\n    var pindx = new ResultPoint_1.default(pind.getX() - 0.5, pind.getY() - 0.5); // Expand the square so that its corners are the centers of the points\n    // just outside the bull's eye.\n\n    return this.expandSquare([pinax, pinbx, pincx, pindx], 2 * this.nbCenterLayers - 3, 2 * this.nbCenterLayers);\n  };\n  /**\n   * Finds a candidate center point of an Aztec code from an image\n   *\n   * @return the center point\n   */\n\n\n  Detector.prototype.getMatrixCenter = function () {\n    var pointA;\n    var pointB;\n    var pointC;\n    var pointD; // Get a white rectangle that can be the border of the matrix in center bull's eye or\n\n    try {\n      var cornerPoints = new WhiteRectangleDetector_1.default(this.image).detect();\n      pointA = cornerPoints[0];\n      pointB = cornerPoints[1];\n      pointC = cornerPoints[2];\n      pointD = cornerPoints[3];\n    } catch (e) {\n      // This exception can be in case the initial rectangle is white\n      // In that case, surely in the bull's eye, we try to expand the rectangle.\n      var cx_1 = this.image.getWidth() / 2;\n      var cy_1 = this.image.getHeight() / 2;\n      pointA = this.getFirstDifferent(new Point(cx_1 + 7, cy_1 - 7), false, 1, -1).toResultPoint();\n      pointB = this.getFirstDifferent(new Point(cx_1 + 7, cy_1 + 7), false, 1, 1).toResultPoint();\n      pointC = this.getFirstDifferent(new Point(cx_1 - 7, cy_1 + 7), false, -1, 1).toResultPoint();\n      pointD = this.getFirstDifferent(new Point(cx_1 - 7, cy_1 - 7), false, -1, -1).toResultPoint();\n    } // Compute the center of the rectangle\n\n\n    var cx = MathUtils_1.default.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);\n    var cy = MathUtils_1.default.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0); // Redetermine the white rectangle starting from previously computed center.\n    // This will ensure that we end up with a white rectangle in center bull's eye\n    // in order to compute a more accurate center.\n\n    try {\n      var cornerPoints = new WhiteRectangleDetector_1.default(this.image, 15, cx, cy).detect();\n      pointA = cornerPoints[0];\n      pointB = cornerPoints[1];\n      pointC = cornerPoints[2];\n      pointD = cornerPoints[3];\n    } catch (e) {\n      // This exception can be in case the initial rectangle is white\n      // In that case we try to expand the rectangle.\n      pointA = this.getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();\n      pointB = this.getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();\n      pointC = this.getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();\n      pointD = this.getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();\n    } // Recompute the center of the rectangle\n\n\n    cx = MathUtils_1.default.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);\n    cy = MathUtils_1.default.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);\n    return new Point(cx, cy);\n  };\n  /**\n   * Gets the Aztec code corners from the bull's eye corners and the parameters.\n   *\n   * @param bullsEyeCorners the array of bull's eye corners\n   * @return the array of aztec code corners\n   */\n\n\n  Detector.prototype.getMatrixCornerPoints = function (bullsEyeCorners) {\n    return this.expandSquare(bullsEyeCorners, 2 * this.nbCenterLayers, this.getDimension());\n  };\n  /**\n   * Creates a BitMatrix by sampling the provided image.\n   * topLeft, topRight, bottomRight, and bottomLeft are the centers of the squares on the\n   * diagonal just outside the bull's eye.\n   */\n\n\n  Detector.prototype.sampleGrid = function (image, topLeft, topRight, bottomRight, bottomLeft) {\n    var sampler = GridSamplerInstance_1.default.getInstance();\n    var dimension = this.getDimension();\n    var low = dimension / 2 - this.nbCenterLayers;\n    var high = dimension / 2 + this.nbCenterLayers;\n    return sampler.sampleGrid(image, dimension, dimension, low, low, // topleft\n    high, low, // topright\n    high, high, // bottomright\n    low, high, // bottomleft\n    topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());\n  };\n  /**\n   * Samples a line.\n   *\n   * @param p1   start point (inclusive)\n   * @param p2   end point (exclusive)\n   * @param size number of bits\n   * @return the array of bits as an int (first bit is high-order bit of result)\n   */\n\n\n  Detector.prototype.sampleLine = function (p1, p2, size) {\n    var result = 0;\n    var d = this.distanceResultPoint(p1, p2);\n    var moduleSize = d / size;\n    var px = p1.getX();\n    var py = p1.getY();\n    var dx = moduleSize * (p2.getX() - p1.getX()) / d;\n    var dy = moduleSize * (p2.getY() - p1.getY()) / d;\n\n    for (var i = 0; i < size; i++) {\n      if (this.image.get(MathUtils_1.default.round(px + i * dx), MathUtils_1.default.round(py + i * dy))) {\n        result |= 1 << size - i - 1;\n      }\n    }\n\n    return result;\n  };\n  /**\n   * @return true if the border of the rectangle passed in parameter is compound of white points only\n   *         or black points only\n   */\n\n\n  Detector.prototype.isWhiteOrBlackRectangle = function (p1, p2, p3, p4) {\n    var corr = 3;\n    p1 = new Point(p1.getX() - corr, p1.getY() + corr);\n    p2 = new Point(p2.getX() - corr, p2.getY() - corr);\n    p3 = new Point(p3.getX() + corr, p3.getY() - corr);\n    p4 = new Point(p4.getX() + corr, p4.getY() + corr);\n    var cInit = this.getColor(p4, p1);\n\n    if (cInit === 0) {\n      return false;\n    }\n\n    var c = this.getColor(p1, p2);\n\n    if (c !== cInit) {\n      return false;\n    }\n\n    c = this.getColor(p2, p3);\n\n    if (c !== cInit) {\n      return false;\n    }\n\n    c = this.getColor(p3, p4);\n    return c === cInit;\n  };\n  /**\n   * Gets the color of a segment\n   *\n   * @return 1 if segment more than 90% black, -1 if segment is more than 90% white, 0 else\n   */\n\n\n  Detector.prototype.getColor = function (p1, p2) {\n    var d = this.distancePoint(p1, p2);\n    var dx = (p2.getX() - p1.getX()) / d;\n    var dy = (p2.getY() - p1.getY()) / d;\n    var error = 0;\n    var px = p1.getX();\n    var py = p1.getY();\n    var colorModel = this.image.get(p1.getX(), p1.getY());\n    var iMax = Math.ceil(d);\n\n    for (var i = 0; i < iMax; i++) {\n      px += dx;\n      py += dy;\n\n      if (this.image.get(MathUtils_1.default.round(px), MathUtils_1.default.round(py)) !== colorModel) {\n        error++;\n      }\n    }\n\n    var errRatio = error / d;\n\n    if (errRatio > 0.1 && errRatio < 0.9) {\n      return 0;\n    }\n\n    return errRatio <= 0.1 === colorModel ? 1 : -1;\n  };\n  /**\n   * Gets the coordinate of the first point with a different color in the given direction\n   */\n\n\n  Detector.prototype.getFirstDifferent = function (init, color, dx, dy) {\n    var x = init.getX() + dx;\n    var y = init.getY() + dy;\n\n    while (this.isValid(x, y) && this.image.get(x, y) === color) {\n      x += dx;\n      y += dy;\n    }\n\n    x -= dx;\n    y -= dy;\n\n    while (this.isValid(x, y) && this.image.get(x, y) === color) {\n      x += dx;\n    }\n\n    x -= dx;\n\n    while (this.isValid(x, y) && this.image.get(x, y) === color) {\n      y += dy;\n    }\n\n    y -= dy;\n    return new Point(x, y);\n  };\n  /**\n   * Expand the square represented by the corner points by pushing out equally in all directions\n   *\n   * @param cornerPoints the corners of the square, which has the bull's eye at its center\n   * @param oldSide the original length of the side of the square in the target bit matrix\n   * @param newSide the new length of the size of the square in the target bit matrix\n   * @return the corners of the expanded square\n   */\n\n\n  Detector.prototype.expandSquare = function (cornerPoints, oldSide, newSide) {\n    var ratio = newSide / (2.0 * oldSide);\n    var dx = cornerPoints[0].getX() - cornerPoints[2].getX();\n    var dy = cornerPoints[0].getY() - cornerPoints[2].getY();\n    var centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0;\n    var centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0;\n    var result0 = new ResultPoint_1.default(centerx + ratio * dx, centery + ratio * dy);\n    var result2 = new ResultPoint_1.default(centerx - ratio * dx, centery - ratio * dy);\n    dx = cornerPoints[1].getX() - cornerPoints[3].getX();\n    dy = cornerPoints[1].getY() - cornerPoints[3].getY();\n    centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0;\n    centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0;\n    var result1 = new ResultPoint_1.default(centerx + ratio * dx, centery + ratio * dy);\n    var result3 = new ResultPoint_1.default(centerx - ratio * dx, centery - ratio * dy);\n    var results = [result0, result1, result2, result3];\n    return results;\n  };\n\n  Detector.prototype.isValid = function (x, y) {\n    return x >= 0 && x < this.image.getWidth() && y > 0 && y < this.image.getHeight();\n  };\n\n  Detector.prototype.isValidPoint = function (point) {\n    var x = MathUtils_1.default.round(point.getX());\n    var y = MathUtils_1.default.round(point.getY());\n    return this.isValid(x, y);\n  };\n\n  Detector.prototype.distancePoint = function (a, b) {\n    return MathUtils_1.default.distance(a.getX(), a.getY(), b.getX(), b.getY());\n  };\n\n  Detector.prototype.distanceResultPoint = function (a, b) {\n    return MathUtils_1.default.distance(a.getX(), a.getY(), b.getX(), b.getY());\n  };\n\n  Detector.prototype.getDimension = function () {\n    if (this.compact) {\n      return 4 * this.nbLayers + 11;\n    }\n\n    if (this.nbLayers <= 4) {\n      return 4 * this.nbLayers + 15;\n    }\n\n    return 4 * this.nbLayers + 2 * (Integer_1.default.truncDivision(this.nbLayers - 4, 8) + 1) + 15;\n  };\n\n  return Detector;\n}();\n\nexports.default = Detector;","map":{"version":3,"sources":["../../../../src/core/aztec/detector/Detector.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ResultPoint_1 = require(\"../../ResultPoint\");\nvar AztecDetectorResult_1 = require(\"../AztecDetectorResult\");\nvar MathUtils_1 = require(\"../../common/detector/MathUtils\");\nvar WhiteRectangleDetector_1 = require(\"../../common/detector/WhiteRectangleDetector\");\nvar GenericGF_1 = require(\"../../common/reedsolomon/GenericGF\");\nvar ReedSolomonDecoder_1 = require(\"../../common/reedsolomon/ReedSolomonDecoder\");\nvar NotFoundException_1 = require(\"../../NotFoundException\");\nvar GridSamplerInstance_1 = require(\"../../common/GridSamplerInstance\");\nvar Integer_1 = require(\"../../util/Integer\");\nvar Point = /** @class */ (function () {\n    function Point(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    Point.prototype.toResultPoint = function () {\n        return new ResultPoint_1.default(this.getX(), this.getY());\n    };\n    Point.prototype.getX = function () {\n        return this.x;\n    };\n    Point.prototype.getY = function () {\n        return this.y;\n    };\n    return Point;\n}());\nexports.Point = Point;\n/**\n * Encapsulates logic that can detect an Aztec Code in an image, even if the Aztec Code\n * is rotated or skewed, or partially obscured.\n *\n * @author David Olivier\n * @author Frank Yellin\n */\nvar Detector = /** @class */ (function () {\n    function Detector(image) {\n        this.EXPECTED_CORNER_BITS = new Int32Array([\n            0xee0,\n            0x1dc,\n            0x83b,\n            0x707,\n        ]);\n        this.image = image;\n    }\n    Detector.prototype.detect = function () {\n        return this.detectMirror(false);\n    };\n    /**\n     * Detects an Aztec Code in an image.\n     *\n     * @param isMirror if true, image is a mirror-image of original\n     * @return {@link AztecDetectorResult} encapsulating results of detecting an Aztec Code\n     * @throws NotFoundException if no Aztec Code can be found\n     */\n    Detector.prototype.detectMirror = function (isMirror) {\n        // 1. Get the center of the aztec matrix\n        var pCenter = this.getMatrixCenter();\n        // 2. Get the center points of the four diagonal points just outside the bull's eye\n        //  [topRight, bottomRight, bottomLeft, topLeft]\n        var bullsEyeCorners = this.getBullsEyeCorners(pCenter);\n        if (isMirror) {\n            var temp = bullsEyeCorners[0];\n            bullsEyeCorners[0] = bullsEyeCorners[2];\n            bullsEyeCorners[2] = temp;\n        }\n        // 3. Get the size of the matrix and other parameters from the bull's eye\n        this.extractParameters(bullsEyeCorners);\n        // 4. Sample the grid\n        var bits = this.sampleGrid(this.image, bullsEyeCorners[this.shift % 4], bullsEyeCorners[(this.shift + 1) % 4], bullsEyeCorners[(this.shift + 2) % 4], bullsEyeCorners[(this.shift + 3) % 4]);\n        // 5. Get the corners of the matrix.\n        var corners = this.getMatrixCornerPoints(bullsEyeCorners);\n        return new AztecDetectorResult_1.default(bits, corners, this.compact, this.nbDataBlocks, this.nbLayers);\n    };\n    /**\n     * Extracts the number of data layers and data blocks from the layer around the bull's eye.\n     *\n     * @param bullsEyeCorners the array of bull's eye corners\n     * @throws NotFoundException in case of too many errors or invalid parameters\n     */\n    Detector.prototype.extractParameters = function (bullsEyeCorners) {\n        if (!this.isValidPoint(bullsEyeCorners[0]) || !this.isValidPoint(bullsEyeCorners[1]) ||\n            !this.isValidPoint(bullsEyeCorners[2]) || !this.isValidPoint(bullsEyeCorners[3])) {\n            throw new NotFoundException_1.default();\n        }\n        var length = 2 * this.nbCenterLayers;\n        // Get the bits around the bull's eye\n        var sides = new Int32Array([\n            this.sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length),\n            this.sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length),\n            this.sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length),\n            this.sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length) // Top\n        ]);\n        // bullsEyeCorners[shift] is the corner of the bulls'eye that has three\n        // orientation marks.\n        // sides[shift] is the row/column that goes from the corner with three\n        // orientation marks to the corner with two.\n        this.shift = this.getRotation(sides, length);\n        // Flatten the parameter bits into a single 28- or 40-bit long\n        var parameterData = 0;\n        for (var i = 0; i < 4; i++) {\n            var side = sides[(this.shift + i) % 4];\n            if (this.compact) {\n                // Each side of the form ..XXXXXXX. where Xs are parameter data\n                parameterData <<= 7;\n                parameterData += (side >> 1) & 0x7F;\n            }\n            else {\n                // Each side of the form ..XXXXX.XXXXX. where Xs are parameter data\n                parameterData <<= 10;\n                parameterData += ((side >> 2) & (0x1f << 5)) + ((side >> 1) & 0x1F);\n            }\n        }\n        // Corrects parameter data using RS.  Returns just the data portion\n        // without the error correction.\n        var correctedData = this.getCorrectedParameterData(parameterData, this.compact);\n        if (this.compact) {\n            // 8 bits:  2 bits layers and 6 bits data blocks\n            this.nbLayers = (correctedData >> 6) + 1;\n            this.nbDataBlocks = (correctedData & 0x3F) + 1;\n        }\n        else {\n            // 16 bits:  5 bits layers and 11 bits data blocks\n            this.nbLayers = (correctedData >> 11) + 1;\n            this.nbDataBlocks = (correctedData & 0x7FF) + 1;\n        }\n    };\n    Detector.prototype.getRotation = function (sides, length) {\n        // In a normal pattern, we expect to See\n        //   **    .*             D       A\n        //   *      *\n        //\n        //   .      *\n        //   ..    ..             C       B\n        //\n        // Grab the 3 bits from each of the sides the form the locator pattern and concatenate\n        // into a 12-bit integer.  Start with the bit at A\n        var cornerBits = 0;\n        sides.forEach(function (side, idx, arr) {\n            // XX......X where X's are orientation marks\n            var t = ((side >> (length - 2)) << 1) + (side & 1);\n            cornerBits = (cornerBits << 3) + t;\n        });\n        // for (var side in sides) {\n        //     // XX......X where X's are orientation marks\n        //     var t = ((side >> (length - 2)) << 1) + (side & 1);\n        //     cornerBits = (cornerBits << 3) + t;\n        // }\n        // Mov the bottom bit to the top, so that the three bits of the locator pattern at A are\n        // together.  cornerBits is now:\n        //  3 orientation bits at A || 3 orientation bits at B || ... || 3 orientation bits at D\n        cornerBits = ((cornerBits & 1) << 11) + (cornerBits >> 1);\n        // The result shift indicates which element of BullsEyeCorners[] goes into the top-left\n        // corner. Since the four rotation values have a Hamming distance of 8, we\n        // can easily tolerate two errors.\n        for (var shift = 0; shift < 4; shift++) {\n            if (Integer_1.default.bitCount(cornerBits ^ this.EXPECTED_CORNER_BITS[shift]) <= 2) {\n                return shift;\n            }\n        }\n        throw new NotFoundException_1.default();\n    };\n    /**\n     * Corrects the parameter bits using Reed-Solomon algorithm.\n     *\n     * @param parameterData parameter bits\n     * @param compact true if this is a compact Aztec code\n     * @throws NotFoundException if the array contains too many errors\n     */\n    Detector.prototype.getCorrectedParameterData = function (parameterData, compact) {\n        var numCodewords;\n        var numDataCodewords;\n        if (compact) {\n            numCodewords = 7;\n            numDataCodewords = 2;\n        }\n        else {\n            numCodewords = 10;\n            numDataCodewords = 4;\n        }\n        var numECCodewords = numCodewords - numDataCodewords;\n        var parameterWords = new Int32Array(numCodewords);\n        for (var i = numCodewords - 1; i >= 0; --i) {\n            parameterWords[i] = parameterData & 0xF;\n            parameterData >>= 4;\n        }\n        try {\n            var rsDecoder = new ReedSolomonDecoder_1.default(GenericGF_1.default.AZTEC_PARAM);\n            rsDecoder.decode(parameterWords, numECCodewords);\n        }\n        catch (ignored) {\n            throw new NotFoundException_1.default();\n        }\n        // Toss the error correction.  Just return the data as an integer\n        var result = 0;\n        for (var i = 0; i < numDataCodewords; i++) {\n            result = (result << 4) + parameterWords[i];\n        }\n        return result;\n    };\n    /**\n     * Finds the corners of a bull-eye centered on the passed point.\n     * This returns the centers of the diagonal points just outside the bull's eye\n     * Returns [topRight, bottomRight, bottomLeft, topLeft]\n     *\n     * @param pCenter Center point\n     * @return The corners of the bull-eye\n     * @throws NotFoundException If no valid bull-eye can be found\n     */\n    Detector.prototype.getBullsEyeCorners = function (pCenter) {\n        var pina = pCenter;\n        var pinb = pCenter;\n        var pinc = pCenter;\n        var pind = pCenter;\n        var color = true;\n        for (this.nbCenterLayers = 1; this.nbCenterLayers < 9; this.nbCenterLayers++) {\n            var pouta = this.getFirstDifferent(pina, color, 1, -1);\n            var poutb = this.getFirstDifferent(pinb, color, 1, 1);\n            var poutc = this.getFirstDifferent(pinc, color, -1, 1);\n            var poutd = this.getFirstDifferent(pind, color, -1, -1);\n            // d      a\n            //\n            // c      b\n            if (this.nbCenterLayers > 2) {\n                var q = (this.distancePoint(poutd, pouta) * this.nbCenterLayers) / (this.distancePoint(pind, pina) * (this.nbCenterLayers + 2));\n                if (q < 0.75 || q > 1.25 || !this.isWhiteOrBlackRectangle(pouta, poutb, poutc, poutd)) {\n                    break;\n                }\n            }\n            pina = pouta;\n            pinb = poutb;\n            pinc = poutc;\n            pind = poutd;\n            color = !color;\n        }\n        if (this.nbCenterLayers !== 5 && this.nbCenterLayers !== 7) {\n            throw new NotFoundException_1.default();\n        }\n        this.compact = this.nbCenterLayers === 5;\n        // Expand the square by .5 pixel in each direction so that we're on the border\n        // between the white square and the black square\n        var pinax = new ResultPoint_1.default(pina.getX() + 0.5, pina.getY() - 0.5);\n        var pinbx = new ResultPoint_1.default(pinb.getX() + 0.5, pinb.getY() + 0.5);\n        var pincx = new ResultPoint_1.default(pinc.getX() - 0.5, pinc.getY() + 0.5);\n        var pindx = new ResultPoint_1.default(pind.getX() - 0.5, pind.getY() - 0.5);\n        // Expand the square so that its corners are the centers of the points\n        // just outside the bull's eye.\n        return this.expandSquare([pinax, pinbx, pincx, pindx], 2 * this.nbCenterLayers - 3, 2 * this.nbCenterLayers);\n    };\n    /**\n     * Finds a candidate center point of an Aztec code from an image\n     *\n     * @return the center point\n     */\n    Detector.prototype.getMatrixCenter = function () {\n        var pointA;\n        var pointB;\n        var pointC;\n        var pointD;\n        // Get a white rectangle that can be the border of the matrix in center bull's eye or\n        try {\n            var cornerPoints = new WhiteRectangleDetector_1.default(this.image).detect();\n            pointA = cornerPoints[0];\n            pointB = cornerPoints[1];\n            pointC = cornerPoints[2];\n            pointD = cornerPoints[3];\n        }\n        catch (e) {\n            // This exception can be in case the initial rectangle is white\n            // In that case, surely in the bull's eye, we try to expand the rectangle.\n            var cx_1 = this.image.getWidth() / 2;\n            var cy_1 = this.image.getHeight() / 2;\n            pointA = this.getFirstDifferent(new Point(cx_1 + 7, cy_1 - 7), false, 1, -1).toResultPoint();\n            pointB = this.getFirstDifferent(new Point(cx_1 + 7, cy_1 + 7), false, 1, 1).toResultPoint();\n            pointC = this.getFirstDifferent(new Point(cx_1 - 7, cy_1 + 7), false, -1, 1).toResultPoint();\n            pointD = this.getFirstDifferent(new Point(cx_1 - 7, cy_1 - 7), false, -1, -1).toResultPoint();\n        }\n        // Compute the center of the rectangle\n        var cx = MathUtils_1.default.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);\n        var cy = MathUtils_1.default.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);\n        // Redetermine the white rectangle starting from previously computed center.\n        // This will ensure that we end up with a white rectangle in center bull's eye\n        // in order to compute a more accurate center.\n        try {\n            var cornerPoints = new WhiteRectangleDetector_1.default(this.image, 15, cx, cy).detect();\n            pointA = cornerPoints[0];\n            pointB = cornerPoints[1];\n            pointC = cornerPoints[2];\n            pointD = cornerPoints[3];\n        }\n        catch (e) {\n            // This exception can be in case the initial rectangle is white\n            // In that case we try to expand the rectangle.\n            pointA = this.getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();\n            pointB = this.getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();\n            pointC = this.getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();\n            pointD = this.getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();\n        }\n        // Recompute the center of the rectangle\n        cx = MathUtils_1.default.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);\n        cy = MathUtils_1.default.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);\n        return new Point(cx, cy);\n    };\n    /**\n     * Gets the Aztec code corners from the bull's eye corners and the parameters.\n     *\n     * @param bullsEyeCorners the array of bull's eye corners\n     * @return the array of aztec code corners\n     */\n    Detector.prototype.getMatrixCornerPoints = function (bullsEyeCorners) {\n        return this.expandSquare(bullsEyeCorners, 2 * this.nbCenterLayers, this.getDimension());\n    };\n    /**\n     * Creates a BitMatrix by sampling the provided image.\n     * topLeft, topRight, bottomRight, and bottomLeft are the centers of the squares on the\n     * diagonal just outside the bull's eye.\n     */\n    Detector.prototype.sampleGrid = function (image, topLeft, topRight, bottomRight, bottomLeft) {\n        var sampler = GridSamplerInstance_1.default.getInstance();\n        var dimension = this.getDimension();\n        var low = dimension / 2 - this.nbCenterLayers;\n        var high = dimension / 2 + this.nbCenterLayers;\n        return sampler.sampleGrid(image, dimension, dimension, low, low, // topleft\n        high, low, // topright\n        high, high, // bottomright\n        low, high, // bottomleft\n        topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());\n    };\n    /**\n     * Samples a line.\n     *\n     * @param p1   start point (inclusive)\n     * @param p2   end point (exclusive)\n     * @param size number of bits\n     * @return the array of bits as an int (first bit is high-order bit of result)\n     */\n    Detector.prototype.sampleLine = function (p1, p2, size) {\n        var result = 0;\n        var d = this.distanceResultPoint(p1, p2);\n        var moduleSize = d / size;\n        var px = p1.getX();\n        var py = p1.getY();\n        var dx = moduleSize * (p2.getX() - p1.getX()) / d;\n        var dy = moduleSize * (p2.getY() - p1.getY()) / d;\n        for (var i = 0; i < size; i++) {\n            if (this.image.get(MathUtils_1.default.round(px + i * dx), MathUtils_1.default.round(py + i * dy))) {\n                result |= 1 << (size - i - 1);\n            }\n        }\n        return result;\n    };\n    /**\n     * @return true if the border of the rectangle passed in parameter is compound of white points only\n     *         or black points only\n     */\n    Detector.prototype.isWhiteOrBlackRectangle = function (p1, p2, p3, p4) {\n        var corr = 3;\n        p1 = new Point(p1.getX() - corr, p1.getY() + corr);\n        p2 = new Point(p2.getX() - corr, p2.getY() - corr);\n        p3 = new Point(p3.getX() + corr, p3.getY() - corr);\n        p4 = new Point(p4.getX() + corr, p4.getY() + corr);\n        var cInit = this.getColor(p4, p1);\n        if (cInit === 0) {\n            return false;\n        }\n        var c = this.getColor(p1, p2);\n        if (c !== cInit) {\n            return false;\n        }\n        c = this.getColor(p2, p3);\n        if (c !== cInit) {\n            return false;\n        }\n        c = this.getColor(p3, p4);\n        return c === cInit;\n    };\n    /**\n     * Gets the color of a segment\n     *\n     * @return 1 if segment more than 90% black, -1 if segment is more than 90% white, 0 else\n     */\n    Detector.prototype.getColor = function (p1, p2) {\n        var d = this.distancePoint(p1, p2);\n        var dx = (p2.getX() - p1.getX()) / d;\n        var dy = (p2.getY() - p1.getY()) / d;\n        var error = 0;\n        var px = p1.getX();\n        var py = p1.getY();\n        var colorModel = this.image.get(p1.getX(), p1.getY());\n        var iMax = Math.ceil(d);\n        for (var i = 0; i < iMax; i++) {\n            px += dx;\n            py += dy;\n            if (this.image.get(MathUtils_1.default.round(px), MathUtils_1.default.round(py)) !== colorModel) {\n                error++;\n            }\n        }\n        var errRatio = error / d;\n        if (errRatio > 0.1 && errRatio < 0.9) {\n            return 0;\n        }\n        return (errRatio <= 0.1) === colorModel ? 1 : -1;\n    };\n    /**\n     * Gets the coordinate of the first point with a different color in the given direction\n     */\n    Detector.prototype.getFirstDifferent = function (init, color, dx, dy) {\n        var x = init.getX() + dx;\n        var y = init.getY() + dy;\n        while (this.isValid(x, y) && this.image.get(x, y) === color) {\n            x += dx;\n            y += dy;\n        }\n        x -= dx;\n        y -= dy;\n        while (this.isValid(x, y) && this.image.get(x, y) === color) {\n            x += dx;\n        }\n        x -= dx;\n        while (this.isValid(x, y) && this.image.get(x, y) === color) {\n            y += dy;\n        }\n        y -= dy;\n        return new Point(x, y);\n    };\n    /**\n     * Expand the square represented by the corner points by pushing out equally in all directions\n     *\n     * @param cornerPoints the corners of the square, which has the bull's eye at its center\n     * @param oldSide the original length of the side of the square in the target bit matrix\n     * @param newSide the new length of the size of the square in the target bit matrix\n     * @return the corners of the expanded square\n     */\n    Detector.prototype.expandSquare = function (cornerPoints, oldSide, newSide) {\n        var ratio = newSide / (2.0 * oldSide);\n        var dx = cornerPoints[0].getX() - cornerPoints[2].getX();\n        var dy = cornerPoints[0].getY() - cornerPoints[2].getY();\n        var centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0;\n        var centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0;\n        var result0 = new ResultPoint_1.default(centerx + ratio * dx, centery + ratio * dy);\n        var result2 = new ResultPoint_1.default(centerx - ratio * dx, centery - ratio * dy);\n        dx = cornerPoints[1].getX() - cornerPoints[3].getX();\n        dy = cornerPoints[1].getY() - cornerPoints[3].getY();\n        centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0;\n        centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0;\n        var result1 = new ResultPoint_1.default(centerx + ratio * dx, centery + ratio * dy);\n        var result3 = new ResultPoint_1.default(centerx - ratio * dx, centery - ratio * dy);\n        var results = [result0, result1, result2, result3];\n        return results;\n    };\n    Detector.prototype.isValid = function (x, y) {\n        return x >= 0 && x < this.image.getWidth() && y > 0 && y < this.image.getHeight();\n    };\n    Detector.prototype.isValidPoint = function (point) {\n        var x = MathUtils_1.default.round(point.getX());\n        var y = MathUtils_1.default.round(point.getY());\n        return this.isValid(x, y);\n    };\n    Detector.prototype.distancePoint = function (a, b) {\n        return MathUtils_1.default.distance(a.getX(), a.getY(), b.getX(), b.getY());\n    };\n    Detector.prototype.distanceResultPoint = function (a, b) {\n        return MathUtils_1.default.distance(a.getX(), a.getY(), b.getX(), b.getY());\n    };\n    Detector.prototype.getDimension = function () {\n        if (this.compact) {\n            return 4 * this.nbLayers + 11;\n        }\n        if (this.nbLayers <= 4) {\n            return 4 * this.nbLayers + 15;\n        }\n        return 4 * this.nbLayers + 2 * (Integer_1.default.truncDivision((this.nbLayers - 4), 8) + 1) + 15;\n    };\n    return Detector;\n}());\nexports.default = Detector;\n//# sourceMappingURL=Detector.js.map"]},"metadata":{},"sourceType":"script"}