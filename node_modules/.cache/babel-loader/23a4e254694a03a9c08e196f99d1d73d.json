{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // package com.google.zxing.pdf417.decoder;\n// import com.google.zxing.FormatException;\n\nvar FormatException_1 = require(\"../../FormatException\"); // import com.google.zxing.common.CharacterSetECI;\n\n\nvar CharacterSetECI_1 = require(\"../../common/CharacterSetECI\"); // import com.google.zxing.common.DecoderResult;\n\n\nvar DecoderResult_1 = require(\"../../common/DecoderResult\"); // import com.google.zxing.pdf417.PDF417ResultMetadata;\n\n\nvar PDF417ResultMetadata_1 = require(\"../PDF417ResultMetadata\"); // import java.io.ByteArrayOutputStream;\n// import java.math.BigInteger;\n// import java.nio.charset.Charset;\n// import java.nio.charset.StandardCharsets;\n// import java.util.Arrays;\n\n\nvar Arrays_1 = require(\"../../util/Arrays\");\n\nvar StringBuilder_1 = require(\"../../util/StringBuilder\");\n\nvar Integer_1 = require(\"../../util/Integer\");\n\nvar Long_1 = require(\"../../util/Long\");\n\nvar ByteArrayOutputStream_1 = require(\"../../util/ByteArrayOutputStream\");\n\nvar StringEncoding_1 = require(\"../../util/StringEncoding\");\n/*private*/\n\n\nvar Mode;\n\n(function (Mode) {\n  Mode[Mode[\"ALPHA\"] = 0] = \"ALPHA\";\n  Mode[Mode[\"LOWER\"] = 1] = \"LOWER\";\n  Mode[Mode[\"MIXED\"] = 2] = \"MIXED\";\n  Mode[Mode[\"PUNCT\"] = 3] = \"PUNCT\";\n  Mode[Mode[\"ALPHA_SHIFT\"] = 4] = \"ALPHA_SHIFT\";\n  Mode[Mode[\"PUNCT_SHIFT\"] = 5] = \"PUNCT_SHIFT\";\n})(Mode || (Mode = {}));\n/**\n * Indirectly access the global BigInt constructor, it\n * allows browsers that doesn't support BigInt to run\n * the library without breaking due to \"undefined BigInt\"\n * errors.\n */\n\n\nfunction getBigIntConstructor() {\n  if (typeof window !== 'undefined') {\n    return window['BigInt'] || null;\n  }\n\n  if (typeof global !== 'undefined') {\n    return global['BigInt'] || null;\n  }\n\n  throw new Error('Can\\'t search globals for BigInt!');\n}\n/**\n * Used to store the BigInt constructor.\n */\n\n\nvar BigInteger;\n/**\n * This function creates a bigint value. It allows browsers\n * that doesn't support BigInt to run the rest of the library\n * by not directly accessing the BigInt constructor.\n */\n\nfunction createBigInt(num) {\n  if (typeof BigInteger === 'undefined') {\n    BigInteger = getBigIntConstructor();\n  }\n\n  if (BigInteger === null) {\n    throw new Error('BigInt is not supported!');\n  }\n\n  return BigInteger(num);\n}\n\nfunction getEXP900() {\n  // in Java - array with length = 16\n  var EXP900 = [];\n  EXP900[0] = createBigInt(1);\n  var nineHundred = createBigInt(900);\n  EXP900[1] = nineHundred; // in Java - array with length = 16\n\n  for (var i\n  /*int*/\n  = 2; i < 16; i++) {\n    EXP900[i] = EXP900[i - 1] * nineHundred;\n  }\n\n  return EXP900;\n}\n/**\n * <p>This class contains the methods for decoding the PDF417 codewords.</p>\n *\n * @author SITA Lab (kevin.osullivan@sita.aero)\n * @author Guenther Grau\n */\n\n\nvar DecodedBitStreamParser =\n/** @class */\nfunction () {\n  function DecodedBitStreamParser() {} //   private DecodedBitStreamParser() {\n  // }\n\n  /**\n   *\n   * @param codewords\n   * @param ecLevel\n   *\n   * @throws FormatException\n   */\n\n\n  DecodedBitStreamParser.decode = function (codewords, ecLevel) {\n    // pass encoding to result (will be used for decode symbols in byte mode)\n    var result = new StringBuilder_1.default(''); // let encoding: Charset = StandardCharsets.ISO_8859_1;\n\n    var encoding = CharacterSetECI_1.default.ISO8859_1;\n    /**\n     * @note the next command is specific from this TypeScript library\n     * because TS can't properly cast some values to char and\n     * convert it to string later correctly due to encoding\n     * differences from Java version. As reported here:\n     * https://github.com/zxing-js/library/pull/264/files#r382831593\n     */\n\n    result.enableDecoding(encoding); // Get compaction mode\n\n    var codeIndex = 1;\n    var code = codewords[codeIndex++];\n    var resultMetadata = new PDF417ResultMetadata_1.default();\n\n    while (codeIndex < codewords[0]) {\n      switch (code) {\n        case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n          codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex, result);\n          break;\n\n        case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:\n        case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:\n          codeIndex = DecodedBitStreamParser.byteCompaction(code, codewords, encoding, codeIndex, result);\n          break;\n\n        case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n          result.append(\n          /*(char)*/\n          codewords[codeIndex++]);\n          break;\n\n        case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:\n          codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex, result);\n          break;\n\n        case DecodedBitStreamParser.ECI_CHARSET:\n          var charsetECI = CharacterSetECI_1.default.getCharacterSetECIByValue(codewords[codeIndex++]); // encoding = Charset.forName(charsetECI.getName());\n\n          break;\n\n        case DecodedBitStreamParser.ECI_GENERAL_PURPOSE:\n          // Can't do anything with generic ECI; skip its 2 characters\n          codeIndex += 2;\n          break;\n\n        case DecodedBitStreamParser.ECI_USER_DEFINED:\n          // Can't do anything with user ECI; skip its 1 character\n          codeIndex++;\n          break;\n\n        case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n          codeIndex = DecodedBitStreamParser.decodeMacroBlock(codewords, codeIndex, resultMetadata);\n          break;\n\n        case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n        case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:\n          // Should not see these outside a macro block\n          throw new FormatException_1.default();\n\n        default:\n          // Default to text compaction. During testing numerous barcodes\n          // appeared to be missing the starting mode. In these cases defaulting\n          // to text compaction seems to work.\n          codeIndex--;\n          codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex, result);\n          break;\n      }\n\n      if (codeIndex < codewords.length) {\n        code = codewords[codeIndex++];\n      } else {\n        throw FormatException_1.default.getFormatInstance();\n      }\n    }\n\n    if (result.length() === 0) {\n      throw FormatException_1.default.getFormatInstance();\n    }\n\n    var decoderResult = new DecoderResult_1.default(null, result.toString(), null, ecLevel);\n    decoderResult.setOther(resultMetadata);\n    return decoderResult;\n  };\n  /**\n   *\n   * @param int\n   * @param param1\n   * @param codewords\n   * @param int\n   * @param codeIndex\n   * @param PDF417ResultMetadata\n   * @param resultMetadata\n   *\n   * @throws FormatException\n   */\n  // @SuppressWarnings(\"deprecation\")\n\n\n  DecodedBitStreamParser.decodeMacroBlock = function (codewords, codeIndex, resultMetadata) {\n    if (codeIndex + DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS > codewords[0]) {\n      // we must have at least two bytes left for the segment index\n      throw FormatException_1.default.getFormatInstance();\n    }\n\n    var segmentIndexArray = new Int32Array(DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS);\n\n    for (var i\n    /*int*/\n    = 0; i < DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS; i++, codeIndex++) {\n      segmentIndexArray[i] = codewords[codeIndex];\n    }\n\n    resultMetadata.setSegmentIndex(Integer_1.default.parseInt(DecodedBitStreamParser.decodeBase900toBase10(segmentIndexArray, DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS)));\n    var fileId = new StringBuilder_1.default();\n    codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex, fileId);\n    resultMetadata.setFileId(fileId.toString());\n    var optionalFieldsStart = -1;\n\n    if (codewords[codeIndex] === DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD) {\n      optionalFieldsStart = codeIndex + 1;\n    }\n\n    while (codeIndex < codewords[0]) {\n      switch (codewords[codeIndex]) {\n        case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n          codeIndex++;\n\n          switch (codewords[codeIndex]) {\n            case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME:\n              var fileName = new StringBuilder_1.default();\n              codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex + 1, fileName);\n              resultMetadata.setFileName(fileName.toString());\n              break;\n\n            case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SENDER:\n              var sender = new StringBuilder_1.default();\n              codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex + 1, sender);\n              resultMetadata.setSender(sender.toString());\n              break;\n\n            case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE:\n              var addressee = new StringBuilder_1.default();\n              codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex + 1, addressee);\n              resultMetadata.setAddressee(addressee.toString());\n              break;\n\n            case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT:\n              var segmentCount = new StringBuilder_1.default();\n              codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, segmentCount);\n              resultMetadata.setSegmentCount(Integer_1.default.parseInt(segmentCount.toString()));\n              break;\n\n            case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP:\n              var timestamp = new StringBuilder_1.default();\n              codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, timestamp);\n              resultMetadata.setTimestamp(Long_1.default.parseLong(timestamp.toString()));\n              break;\n\n            case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM:\n              var checksum = new StringBuilder_1.default();\n              codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, checksum);\n              resultMetadata.setChecksum(Integer_1.default.parseInt(checksum.toString()));\n              break;\n\n            case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE:\n              var fileSize = new StringBuilder_1.default();\n              codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, fileSize);\n              resultMetadata.setFileSize(Long_1.default.parseLong(fileSize.toString()));\n              break;\n\n            default:\n              throw FormatException_1.default.getFormatInstance();\n          }\n\n          break;\n\n        case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:\n          codeIndex++;\n          resultMetadata.setLastSegment(true);\n          break;\n\n        default:\n          throw FormatException_1.default.getFormatInstance();\n      }\n    } // copy optional fields to additional options\n\n\n    if (optionalFieldsStart !== -1) {\n      var optionalFieldsLength = codeIndex - optionalFieldsStart;\n\n      if (resultMetadata.isLastSegment()) {\n        // do not include terminator\n        optionalFieldsLength--;\n      }\n\n      resultMetadata.setOptionalData(Arrays_1.default.copyOfRange(codewords, optionalFieldsStart, optionalFieldsStart + optionalFieldsLength));\n    }\n\n    return codeIndex;\n  };\n  /**\n   * Text Compaction mode (see 5.4.1.5) permits all printable ASCII characters to be\n   * encoded, i.e. values 32 - 126 inclusive in accordance with ISO/IEC 646 (IRV), as\n   * well as selected control characters.\n   *\n   * @param codewords The array of codewords (data + error)\n   * @param codeIndex The current index into the codeword array.\n   * @param result    The decoded data is appended to the result.\n   * @return The next index into the codeword array.\n   */\n\n\n  DecodedBitStreamParser.textCompaction = function (codewords, codeIndex, result) {\n    // 2 character per codeword\n    var textCompactionData = new Int32Array((codewords[0] - codeIndex) * 2); // Used to hold the byte compaction value if there is a mode shift\n\n    var byteCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);\n    var index = 0;\n    var end = false;\n\n    while (codeIndex < codewords[0] && !end) {\n      var code = codewords[codeIndex++];\n\n      if (code < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {\n        textCompactionData[index] = code / 30;\n        textCompactionData[index + 1] = code % 30;\n        index += 2;\n      } else {\n        switch (code) {\n          case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n            // reinitialize text compaction mode to alpha sub mode\n            textCompactionData[index++] = DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH;\n            break;\n\n          case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:\n          case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:\n          case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:\n          case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n          case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n          case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:\n            codeIndex--;\n            end = true;\n            break;\n\n          case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n            // The Mode Shift codeword 913 shall cause a temporary\n            // switch from Text Compaction mode to Byte Compaction mode.\n            // This switch shall be in effect for only the next codeword,\n            // after which the mode shall revert to the prevailing sub-mode\n            // of the Text Compaction mode. Codeword 913 is only available\n            // in Text Compaction mode; its use is described in 5.4.2.4.\n            textCompactionData[index] = DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE;\n            code = codewords[codeIndex++];\n            byteCompactionData[index] = code;\n            index++;\n            break;\n        }\n      }\n    }\n\n    DecodedBitStreamParser.decodeTextCompaction(textCompactionData, byteCompactionData, index, result);\n    return codeIndex;\n  };\n  /**\n   * The Text Compaction mode includes all the printable ASCII characters\n   * (i.e. values from 32 to 126) and three ASCII control characters: HT or tab\n   * (9: e), LF or line feed (10: e), and CR or carriage\n   * return (13: e). The Text Compaction mode also includes various latch\n   * and shift characters which are used exclusively within the mode. The Text\n   * Compaction mode encodes up to 2 characters per codeword. The compaction rules\n   * for converting data into PDF417 codewords are defined in 5.4.2.2. The sub-mode\n   * switches are defined in 5.4.2.3.\n   *\n   * @param textCompactionData The text compaction data.\n   * @param byteCompactionData The byte compaction data if there\n   *                           was a mode shift.\n   * @param length             The size of the text compaction and byte compaction data.\n   * @param result             The decoded data is appended to the result.\n   */\n\n\n  DecodedBitStreamParser.decodeTextCompaction = function (textCompactionData, byteCompactionData, length, result) {\n    // Beginning from an initial state of the Alpha sub-mode\n    // The default compaction mode for PDF417 in effect at the start of each symbol shall always be Text\n    // Compaction mode Alpha sub-mode (alphabetic: uppercase). A latch codeword from another mode to the Text\n    // Compaction mode shall always switch to the Text Compaction Alpha sub-mode.\n    var subMode = Mode.ALPHA;\n    var priorToShiftMode = Mode.ALPHA;\n    var i = 0;\n\n    while (i < length) {\n      var subModeCh = textCompactionData[i];\n      var ch =\n      /*char*/\n      '';\n\n      switch (subMode) {\n        case Mode.ALPHA:\n          // Alpha (alphabetic: uppercase)\n          if (subModeCh < 26) {\n            // Upper case Alpha Character\n            // Note: 65 = 'A' ASCII -> there is byte code of symbol\n            ch =\n            /*(char)('A' + subModeCh) */\n            String.fromCharCode(65 + subModeCh);\n          } else {\n            switch (subModeCh) {\n              case 26:\n                ch = ' ';\n                break;\n\n              case DecodedBitStreamParser.LL:\n                subMode = Mode.LOWER;\n                break;\n\n              case DecodedBitStreamParser.ML:\n                subMode = Mode.MIXED;\n                break;\n\n              case DecodedBitStreamParser.PS:\n                // Shift to punctuation\n                priorToShiftMode = subMode;\n                subMode = Mode.PUNCT_SHIFT;\n                break;\n\n              case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                result.append(\n                /*(char)*/\n                byteCompactionData[i]);\n                break;\n\n              case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                subMode = Mode.ALPHA;\n                break;\n            }\n          }\n\n          break;\n\n        case Mode.LOWER:\n          // Lower (alphabetic: lowercase)\n          if (subModeCh < 26) {\n            ch =\n            /*(char)('a' + subModeCh)*/\n            String.fromCharCode(97 + subModeCh);\n          } else {\n            switch (subModeCh) {\n              case 26:\n                ch = ' ';\n                break;\n\n              case DecodedBitStreamParser.AS:\n                // Shift to alpha\n                priorToShiftMode = subMode;\n                subMode = Mode.ALPHA_SHIFT;\n                break;\n\n              case DecodedBitStreamParser.ML:\n                subMode = Mode.MIXED;\n                break;\n\n              case DecodedBitStreamParser.PS:\n                // Shift to punctuation\n                priorToShiftMode = subMode;\n                subMode = Mode.PUNCT_SHIFT;\n                break;\n\n              case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                // TODO Does this need to use the current character encoding? See other occurrences below\n                result.append(\n                /*(char)*/\n                byteCompactionData[i]);\n                break;\n\n              case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                subMode = Mode.ALPHA;\n                break;\n            }\n          }\n\n          break;\n\n        case Mode.MIXED:\n          // Mixed (punctuation: e)\n          if (subModeCh < DecodedBitStreamParser.PL) {\n            ch = DecodedBitStreamParser.MIXED_CHARS[subModeCh];\n          } else {\n            switch (subModeCh) {\n              case DecodedBitStreamParser.PL:\n                subMode = Mode.PUNCT;\n                break;\n\n              case 26:\n                ch = ' ';\n                break;\n\n              case DecodedBitStreamParser.LL:\n                subMode = Mode.LOWER;\n                break;\n\n              case DecodedBitStreamParser.AL:\n                subMode = Mode.ALPHA;\n                break;\n\n              case DecodedBitStreamParser.PS:\n                // Shift to punctuation\n                priorToShiftMode = subMode;\n                subMode = Mode.PUNCT_SHIFT;\n                break;\n\n              case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                result.append(\n                /*(char)*/\n                byteCompactionData[i]);\n                break;\n\n              case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                subMode = Mode.ALPHA;\n                break;\n            }\n          }\n\n          break;\n\n        case Mode.PUNCT:\n          // Punctuation\n          if (subModeCh < DecodedBitStreamParser.PAL) {\n            ch = DecodedBitStreamParser.PUNCT_CHARS[subModeCh];\n          } else {\n            switch (subModeCh) {\n              case DecodedBitStreamParser.PAL:\n                subMode = Mode.ALPHA;\n                break;\n\n              case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                result.append(\n                /*(char)*/\n                byteCompactionData[i]);\n                break;\n\n              case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                subMode = Mode.ALPHA;\n                break;\n            }\n          }\n\n          break;\n\n        case Mode.ALPHA_SHIFT:\n          // Restore sub-mode\n          subMode = priorToShiftMode;\n\n          if (subModeCh < 26) {\n            ch =\n            /*(char)('A' + subModeCh)*/\n            String.fromCharCode(65 + subModeCh);\n          } else {\n            switch (subModeCh) {\n              case 26:\n                ch = ' ';\n                break;\n\n              case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                subMode = Mode.ALPHA;\n                break;\n            }\n          }\n\n          break;\n\n        case Mode.PUNCT_SHIFT:\n          // Restore sub-mode\n          subMode = priorToShiftMode;\n\n          if (subModeCh < DecodedBitStreamParser.PAL) {\n            ch = DecodedBitStreamParser.PUNCT_CHARS[subModeCh];\n          } else {\n            switch (subModeCh) {\n              case DecodedBitStreamParser.PAL:\n                subMode = Mode.ALPHA;\n                break;\n\n              case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                // PS before Shift-to-Byte is used as a padding character,\n                // see 5.4.2.4 of the specification\n                result.append(\n                /*(char)*/\n                byteCompactionData[i]);\n                break;\n\n              case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                subMode = Mode.ALPHA;\n                break;\n            }\n          }\n\n          break;\n      } // if (ch !== 0) {\n\n\n      if (ch !== '') {\n        // Append decoded character to result\n        result.append(ch);\n      }\n\n      i++;\n    }\n  };\n  /**\n   * Byte Compaction mode (see 5.4.3) permits all 256 possible 8-bit byte values to be encoded.\n   * This includes all ASCII characters value 0 to 127 inclusive and provides for international\n   * character set support.\n   *\n   * @param mode      The byte compaction mode i.e. 901 or 924\n   * @param codewords The array of codewords (data + error)\n   * @param encoding  Currently active character encoding\n   * @param codeIndex The current index into the codeword array.\n   * @param result    The decoded data is appended to the result.\n   * @return The next index into the codeword array.\n   */\n\n\n  DecodedBitStreamParser.byteCompaction = function (mode, codewords, encoding, codeIndex, result) {\n    var decodedBytes = new ByteArrayOutputStream_1.default();\n    var count = 0;\n    var value =\n    /*long*/\n    0;\n    var end = false;\n\n    switch (mode) {\n      case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:\n        // Total number of Byte Compaction characters to be encoded\n        // is not a multiple of 6\n        var byteCompactedCodewords = new Int32Array(6);\n        var nextCode = codewords[codeIndex++];\n\n        while (codeIndex < codewords[0] && !end) {\n          byteCompactedCodewords[count++] = nextCode; // Base 900\n\n          value = 900 * value + nextCode;\n          nextCode = codewords[codeIndex++]; // perhaps it should be ok to check only nextCode >= TEXT_COMPACTION_MODE_LATCH\n\n          switch (nextCode) {\n            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n            case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:\n            case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:\n            case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:\n            case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n            case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n            case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:\n              codeIndex--;\n              end = true;\n              break;\n\n            default:\n              if (count % 5 === 0 && count > 0) {\n                // Decode every 5 codewords\n                // Convert to Base 256\n                for (var j\n                /*int*/\n                = 0; j < 6; ++j) {\n                  /* @note\n                   * JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers.\n                   * So the next bitwise operation could not be done with simple numbers\n                   */\n                  decodedBytes.write(\n                  /*(byte)*/\n                  Number(createBigInt(value) >> createBigInt(8 * (5 - j))));\n                }\n\n                value = 0;\n                count = 0;\n              }\n\n              break;\n          }\n        } // if the end of all codewords is reached the last codeword needs to be added\n\n\n        if (codeIndex === codewords[0] && nextCode < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {\n          byteCompactedCodewords[count++] = nextCode;\n        } // If Byte Compaction mode is invoked with codeword 901,\n        // the last group of codewords is interpreted directly\n        // as one byte per codeword, without compaction.\n\n\n        for (var i\n        /*int*/\n        = 0; i < count; i++) {\n          decodedBytes.write(\n          /*(byte)*/\n          byteCompactedCodewords[i]);\n        }\n\n        break;\n\n      case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:\n        // Total number of Byte Compaction characters to be encoded\n        // is an integer multiple of 6\n        while (codeIndex < codewords[0] && !end) {\n          var code = codewords[codeIndex++];\n\n          if (code < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {\n            count++; // Base 900\n\n            value = 900 * value + code;\n          } else {\n            switch (code) {\n              case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n              case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:\n              case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:\n              case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:\n              case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n              case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n              case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:\n                codeIndex--;\n                end = true;\n                break;\n            }\n          }\n\n          if (count % 5 === 0 && count > 0) {\n            // Decode every 5 codewords\n            // Convert to Base 256\n\n            /* @note\n             * JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers.\n             * So the next bitwise operation could not be done with simple numbers\n            */\n            for (var j\n            /*int*/\n            = 0; j < 6; ++j) {\n              decodedBytes.write(\n              /*(byte)*/\n              Number(createBigInt(value) >> createBigInt(8 * (5 - j))));\n            }\n\n            value = 0;\n            count = 0;\n          }\n        }\n\n        break;\n    }\n\n    result.append(StringEncoding_1.default.decode(decodedBytes.toByteArray(), encoding));\n    return codeIndex;\n  };\n  /**\n   * Numeric Compaction mode (see 5.4.4) permits efficient encoding of numeric data strings.\n   *\n   * @param codewords The array of codewords (data + error)\n   * @param codeIndex The current index into the codeword array.\n   * @param result    The decoded data is appended to the result.\n   * @return The next index into the codeword array.\n   *\n   * @throws FormatException\n   */\n\n\n  DecodedBitStreamParser.numericCompaction = function (codewords, codeIndex\n  /*int*/\n  , result) {\n    var count = 0;\n    var end = false;\n    var numericCodewords = new Int32Array(DecodedBitStreamParser.MAX_NUMERIC_CODEWORDS);\n\n    while (codeIndex < codewords[0] && !end) {\n      var code = codewords[codeIndex++];\n\n      if (codeIndex === codewords[0]) {\n        end = true;\n      }\n\n      if (code < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {\n        numericCodewords[count] = code;\n        count++;\n      } else {\n        switch (code) {\n          case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n          case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:\n          case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:\n          case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n          case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n          case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:\n            codeIndex--;\n            end = true;\n            break;\n        }\n      }\n\n      if ((count % DecodedBitStreamParser.MAX_NUMERIC_CODEWORDS === 0 || code === DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH || end) && count > 0) {\n        // Re-invoking Numeric Compaction mode (by using codeword 902\n        // while in Numeric Compaction mode) serves  to terminate the\n        // current Numeric Compaction mode grouping as described in 5.4.4.2,\n        // and then to start a new one grouping.\n        result.append(DecodedBitStreamParser.decodeBase900toBase10(numericCodewords, count));\n        count = 0;\n      }\n    }\n\n    return codeIndex;\n  };\n  /**\n   * Convert a list of Numeric Compacted codewords from Base 900 to Base 10.\n   *\n   * @param codewords The array of codewords\n   * @param count     The number of codewords\n   * @return The decoded string representing the Numeric data.\n   *\n   * EXAMPLE\n   * Encode the fifteen digit numeric string 000213298174000\n   * Prefix the numeric string with a 1 and set the initial value of\n   * t = 1 000 213 298 174 000\n   * Calculate codeword 0\n   * d0 = 1 000 213 298 174 000 mod 900 = 200\n   *\n   * t = 1 000 213 298 174 000 div 900 = 1 111 348 109 082\n   * Calculate codeword 1\n   * d1 = 1 111 348 109 082 mod 900 = 282\n   *\n   * t = 1 111 348 109 082 div 900 = 1 234 831 232\n   * Calculate codeword 2\n   * d2 = 1 234 831 232 mod 900 = 632\n   *\n   * t = 1 234 831 232 div 900 = 1 372 034\n   * Calculate codeword 3\n   * d3 = 1 372 034 mod 900 = 434\n   *\n   * t = 1 372 034 div 900 = 1 524\n   * Calculate codeword 4\n   * d4 = 1 524 mod 900 = 624\n   *\n   * t = 1 524 div 900 = 1\n   * Calculate codeword 5\n   * d5 = 1 mod 900 = 1\n   * t = 1 div 900 = 0\n   * Codeword sequence is: 1, 624, 434, 632, 282, 200\n   *\n   * Decode the above codewords involves\n   *   1 x 900 power of 5 + 624 x 900 power of 4 + 434 x 900 power of 3 +\n   * 632 x 900 power of 2 + 282 x 900 power of 1 + 200 x 900 power of 0 = 1000213298174000\n   *\n   * Remove leading 1 =>  Result is 000213298174000\n   *\n   * @throws FormatException\n   */\n\n\n  DecodedBitStreamParser.decodeBase900toBase10 = function (codewords, count) {\n    var result = createBigInt(0);\n\n    for (var i\n    /*int*/\n    = 0; i < count; i++) {\n      result += DecodedBitStreamParser.EXP900[count - i - 1] * createBigInt(codewords[i]);\n    }\n\n    var resultString = result.toString();\n\n    if (resultString.charAt(0) !== '1') {\n      throw new FormatException_1.default();\n    }\n\n    return resultString.substring(1);\n  };\n\n  DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH = 900;\n  DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH = 901;\n  DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH = 902;\n  DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6 = 924;\n  DecodedBitStreamParser.ECI_USER_DEFINED = 925;\n  DecodedBitStreamParser.ECI_GENERAL_PURPOSE = 926;\n  DecodedBitStreamParser.ECI_CHARSET = 927;\n  DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK = 928;\n  DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD = 923;\n  DecodedBitStreamParser.MACRO_PDF417_TERMINATOR = 922;\n  DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE = 913;\n  DecodedBitStreamParser.MAX_NUMERIC_CODEWORDS = 15;\n  DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME = 0;\n  DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT = 1;\n  DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP = 2;\n  DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SENDER = 3;\n  DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE = 4;\n  DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE = 5;\n  DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM = 6;\n  DecodedBitStreamParser.PL = 25;\n  DecodedBitStreamParser.LL = 27;\n  DecodedBitStreamParser.AS = 27;\n  DecodedBitStreamParser.ML = 28;\n  DecodedBitStreamParser.AL = 28;\n  DecodedBitStreamParser.PS = 29;\n  DecodedBitStreamParser.PAL = 29;\n  DecodedBitStreamParser.PUNCT_CHARS = ';<>@[\\\\]_`~!\\r\\t,:\\n-.$/\"|*()?{}\\'';\n  DecodedBitStreamParser.MIXED_CHARS = '0123456789&\\r\\t,:#-.$/+%*=^';\n  /**\n   * Table containing values for the exponent of 900.\n   * This is used in the numeric compaction decode algorithm.\n   */\n\n  DecodedBitStreamParser.EXP900 = getBigIntConstructor() ? getEXP900() : [];\n  DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS = 2;\n  return DecodedBitStreamParser;\n}();\n\nexports.default = DecodedBitStreamParser;","map":{"version":3,"sources":["../../../../src/core/pdf417/decoder/DecodedBitStreamParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// package com.google.zxing.pdf417.decoder;\n// import com.google.zxing.FormatException;\nvar FormatException_1 = require(\"../../FormatException\");\n// import com.google.zxing.common.CharacterSetECI;\nvar CharacterSetECI_1 = require(\"../../common/CharacterSetECI\");\n// import com.google.zxing.common.DecoderResult;\nvar DecoderResult_1 = require(\"../../common/DecoderResult\");\n// import com.google.zxing.pdf417.PDF417ResultMetadata;\nvar PDF417ResultMetadata_1 = require(\"../PDF417ResultMetadata\");\n// import java.io.ByteArrayOutputStream;\n// import java.math.BigInteger;\n// import java.nio.charset.Charset;\n// import java.nio.charset.StandardCharsets;\n// import java.util.Arrays;\nvar Arrays_1 = require(\"../../util/Arrays\");\nvar StringBuilder_1 = require(\"../../util/StringBuilder\");\nvar Integer_1 = require(\"../../util/Integer\");\nvar Long_1 = require(\"../../util/Long\");\nvar ByteArrayOutputStream_1 = require(\"../../util/ByteArrayOutputStream\");\nvar StringEncoding_1 = require(\"../../util/StringEncoding\");\n/*private*/ var Mode;\n(function (Mode) {\n    Mode[Mode[\"ALPHA\"] = 0] = \"ALPHA\";\n    Mode[Mode[\"LOWER\"] = 1] = \"LOWER\";\n    Mode[Mode[\"MIXED\"] = 2] = \"MIXED\";\n    Mode[Mode[\"PUNCT\"] = 3] = \"PUNCT\";\n    Mode[Mode[\"ALPHA_SHIFT\"] = 4] = \"ALPHA_SHIFT\";\n    Mode[Mode[\"PUNCT_SHIFT\"] = 5] = \"PUNCT_SHIFT\";\n})(Mode || (Mode = {}));\n/**\n * Indirectly access the global BigInt constructor, it\n * allows browsers that doesn't support BigInt to run\n * the library without breaking due to \"undefined BigInt\"\n * errors.\n */\nfunction getBigIntConstructor() {\n    if (typeof window !== 'undefined') {\n        return window['BigInt'] || null;\n    }\n    if (typeof global !== 'undefined') {\n        return global['BigInt'] || null;\n    }\n    throw new Error('Can\\'t search globals for BigInt!');\n}\n/**\n * Used to store the BigInt constructor.\n */\nvar BigInteger;\n/**\n * This function creates a bigint value. It allows browsers\n * that doesn't support BigInt to run the rest of the library\n * by not directly accessing the BigInt constructor.\n */\nfunction createBigInt(num) {\n    if (typeof BigInteger === 'undefined') {\n        BigInteger = getBigIntConstructor();\n    }\n    if (BigInteger === null) {\n        throw new Error('BigInt is not supported!');\n    }\n    return BigInteger(num);\n}\nfunction getEXP900() {\n    // in Java - array with length = 16\n    var EXP900 = [];\n    EXP900[0] = createBigInt(1);\n    var nineHundred = createBigInt(900);\n    EXP900[1] = nineHundred;\n    // in Java - array with length = 16\n    for (var i /*int*/ = 2; i < 16; i++) {\n        EXP900[i] = EXP900[i - 1] * nineHundred;\n    }\n    return EXP900;\n}\n/**\n * <p>This class contains the methods for decoding the PDF417 codewords.</p>\n *\n * @author SITA Lab (kevin.osullivan@sita.aero)\n * @author Guenther Grau\n */\nvar DecodedBitStreamParser = /** @class */ (function () {\n    function DecodedBitStreamParser() {\n    }\n    //   private DecodedBitStreamParser() {\n    // }\n    /**\n     *\n     * @param codewords\n     * @param ecLevel\n     *\n     * @throws FormatException\n     */\n    DecodedBitStreamParser.decode = function (codewords, ecLevel) {\n        // pass encoding to result (will be used for decode symbols in byte mode)\n        var result = new StringBuilder_1.default('');\n        // let encoding: Charset = StandardCharsets.ISO_8859_1;\n        var encoding = CharacterSetECI_1.default.ISO8859_1;\n        /**\n         * @note the next command is specific from this TypeScript library\n         * because TS can't properly cast some values to char and\n         * convert it to string later correctly due to encoding\n         * differences from Java version. As reported here:\n         * https://github.com/zxing-js/library/pull/264/files#r382831593\n         */\n        result.enableDecoding(encoding);\n        // Get compaction mode\n        var codeIndex = 1;\n        var code = codewords[codeIndex++];\n        var resultMetadata = new PDF417ResultMetadata_1.default();\n        while (codeIndex < codewords[0]) {\n            switch (code) {\n                case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                    codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex, result);\n                    break;\n                case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:\n                case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:\n                    codeIndex = DecodedBitStreamParser.byteCompaction(code, codewords, encoding, codeIndex, result);\n                    break;\n                case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                    result.append(/*(char)*/ codewords[codeIndex++]);\n                    break;\n                case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:\n                    codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex, result);\n                    break;\n                case DecodedBitStreamParser.ECI_CHARSET:\n                    var charsetECI = CharacterSetECI_1.default.getCharacterSetECIByValue(codewords[codeIndex++]);\n                    // encoding = Charset.forName(charsetECI.getName());\n                    break;\n                case DecodedBitStreamParser.ECI_GENERAL_PURPOSE:\n                    // Can't do anything with generic ECI; skip its 2 characters\n                    codeIndex += 2;\n                    break;\n                case DecodedBitStreamParser.ECI_USER_DEFINED:\n                    // Can't do anything with user ECI; skip its 1 character\n                    codeIndex++;\n                    break;\n                case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                    codeIndex = DecodedBitStreamParser.decodeMacroBlock(codewords, codeIndex, resultMetadata);\n                    break;\n                case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:\n                    // Should not see these outside a macro block\n                    throw new FormatException_1.default();\n                default:\n                    // Default to text compaction. During testing numerous barcodes\n                    // appeared to be missing the starting mode. In these cases defaulting\n                    // to text compaction seems to work.\n                    codeIndex--;\n                    codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex, result);\n                    break;\n            }\n            if (codeIndex < codewords.length) {\n                code = codewords[codeIndex++];\n            }\n            else {\n                throw FormatException_1.default.getFormatInstance();\n            }\n        }\n        if (result.length() === 0) {\n            throw FormatException_1.default.getFormatInstance();\n        }\n        var decoderResult = new DecoderResult_1.default(null, result.toString(), null, ecLevel);\n        decoderResult.setOther(resultMetadata);\n        return decoderResult;\n    };\n    /**\n     *\n     * @param int\n     * @param param1\n     * @param codewords\n     * @param int\n     * @param codeIndex\n     * @param PDF417ResultMetadata\n     * @param resultMetadata\n     *\n     * @throws FormatException\n     */\n    // @SuppressWarnings(\"deprecation\")\n    DecodedBitStreamParser.decodeMacroBlock = function (codewords, codeIndex, resultMetadata) {\n        if (codeIndex + DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS > codewords[0]) {\n            // we must have at least two bytes left for the segment index\n            throw FormatException_1.default.getFormatInstance();\n        }\n        var segmentIndexArray = new Int32Array(DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS);\n        for (var i /*int*/ = 0; i < DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS; i++, codeIndex++) {\n            segmentIndexArray[i] = codewords[codeIndex];\n        }\n        resultMetadata.setSegmentIndex(Integer_1.default.parseInt(DecodedBitStreamParser.decodeBase900toBase10(segmentIndexArray, DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS)));\n        var fileId = new StringBuilder_1.default();\n        codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex, fileId);\n        resultMetadata.setFileId(fileId.toString());\n        var optionalFieldsStart = -1;\n        if (codewords[codeIndex] === DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD) {\n            optionalFieldsStart = codeIndex + 1;\n        }\n        while (codeIndex < codewords[0]) {\n            switch (codewords[codeIndex]) {\n                case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                    codeIndex++;\n                    switch (codewords[codeIndex]) {\n                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME:\n                            var fileName = new StringBuilder_1.default();\n                            codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex + 1, fileName);\n                            resultMetadata.setFileName(fileName.toString());\n                            break;\n                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SENDER:\n                            var sender = new StringBuilder_1.default();\n                            codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex + 1, sender);\n                            resultMetadata.setSender(sender.toString());\n                            break;\n                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE:\n                            var addressee = new StringBuilder_1.default();\n                            codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex + 1, addressee);\n                            resultMetadata.setAddressee(addressee.toString());\n                            break;\n                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT:\n                            var segmentCount = new StringBuilder_1.default();\n                            codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, segmentCount);\n                            resultMetadata.setSegmentCount(Integer_1.default.parseInt(segmentCount.toString()));\n                            break;\n                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP:\n                            var timestamp = new StringBuilder_1.default();\n                            codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, timestamp);\n                            resultMetadata.setTimestamp(Long_1.default.parseLong(timestamp.toString()));\n                            break;\n                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM:\n                            var checksum = new StringBuilder_1.default();\n                            codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, checksum);\n                            resultMetadata.setChecksum(Integer_1.default.parseInt(checksum.toString()));\n                            break;\n                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE:\n                            var fileSize = new StringBuilder_1.default();\n                            codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, fileSize);\n                            resultMetadata.setFileSize(Long_1.default.parseLong(fileSize.toString()));\n                            break;\n                        default:\n                            throw FormatException_1.default.getFormatInstance();\n                    }\n                    break;\n                case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:\n                    codeIndex++;\n                    resultMetadata.setLastSegment(true);\n                    break;\n                default:\n                    throw FormatException_1.default.getFormatInstance();\n            }\n        }\n        // copy optional fields to additional options\n        if (optionalFieldsStart !== -1) {\n            var optionalFieldsLength = codeIndex - optionalFieldsStart;\n            if (resultMetadata.isLastSegment()) {\n                // do not include terminator\n                optionalFieldsLength--;\n            }\n            resultMetadata.setOptionalData(Arrays_1.default.copyOfRange(codewords, optionalFieldsStart, optionalFieldsStart + optionalFieldsLength));\n        }\n        return codeIndex;\n    };\n    /**\n     * Text Compaction mode (see 5.4.1.5) permits all printable ASCII characters to be\n     * encoded, i.e. values 32 - 126 inclusive in accordance with ISO/IEC 646 (IRV), as\n     * well as selected control characters.\n     *\n     * @param codewords The array of codewords (data + error)\n     * @param codeIndex The current index into the codeword array.\n     * @param result    The decoded data is appended to the result.\n     * @return The next index into the codeword array.\n     */\n    DecodedBitStreamParser.textCompaction = function (codewords, codeIndex, result) {\n        // 2 character per codeword\n        var textCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);\n        // Used to hold the byte compaction value if there is a mode shift\n        var byteCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);\n        var index = 0;\n        var end = false;\n        while ((codeIndex < codewords[0]) && !end) {\n            var code = codewords[codeIndex++];\n            if (code < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {\n                textCompactionData[index] = code / 30;\n                textCompactionData[index + 1] = code % 30;\n                index += 2;\n            }\n            else {\n                switch (code) {\n                    case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                        // reinitialize text compaction mode to alpha sub mode\n                        textCompactionData[index++] = DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH;\n                        break;\n                    case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:\n                    case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:\n                    case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:\n                    case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                    case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                    case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:\n                        codeIndex--;\n                        end = true;\n                        break;\n                    case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                        // The Mode Shift codeword 913 shall cause a temporary\n                        // switch from Text Compaction mode to Byte Compaction mode.\n                        // This switch shall be in effect for only the next codeword,\n                        // after which the mode shall revert to the prevailing sub-mode\n                        // of the Text Compaction mode. Codeword 913 is only available\n                        // in Text Compaction mode; its use is described in 5.4.2.4.\n                        textCompactionData[index] = DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE;\n                        code = codewords[codeIndex++];\n                        byteCompactionData[index] = code;\n                        index++;\n                        break;\n                }\n            }\n        }\n        DecodedBitStreamParser.decodeTextCompaction(textCompactionData, byteCompactionData, index, result);\n        return codeIndex;\n    };\n    /**\n     * The Text Compaction mode includes all the printable ASCII characters\n     * (i.e. values from 32 to 126) and three ASCII control characters: HT or tab\n     * (9: e), LF or line feed (10: e), and CR or carriage\n     * return (13: e). The Text Compaction mode also includes various latch\n     * and shift characters which are used exclusively within the mode. The Text\n     * Compaction mode encodes up to 2 characters per codeword. The compaction rules\n     * for converting data into PDF417 codewords are defined in 5.4.2.2. The sub-mode\n     * switches are defined in 5.4.2.3.\n     *\n     * @param textCompactionData The text compaction data.\n     * @param byteCompactionData The byte compaction data if there\n     *                           was a mode shift.\n     * @param length             The size of the text compaction and byte compaction data.\n     * @param result             The decoded data is appended to the result.\n     */\n    DecodedBitStreamParser.decodeTextCompaction = function (textCompactionData, byteCompactionData, length, result) {\n        // Beginning from an initial state of the Alpha sub-mode\n        // The default compaction mode for PDF417 in effect at the start of each symbol shall always be Text\n        // Compaction mode Alpha sub-mode (alphabetic: uppercase). A latch codeword from another mode to the Text\n        // Compaction mode shall always switch to the Text Compaction Alpha sub-mode.\n        var subMode = Mode.ALPHA;\n        var priorToShiftMode = Mode.ALPHA;\n        var i = 0;\n        while (i < length) {\n            var subModeCh = textCompactionData[i];\n            var ch = /*char*/ '';\n            switch (subMode) {\n                case Mode.ALPHA:\n                    // Alpha (alphabetic: uppercase)\n                    if (subModeCh < 26) {\n                        // Upper case Alpha Character\n                        // Note: 65 = 'A' ASCII -> there is byte code of symbol\n                        ch = /*(char)('A' + subModeCh) */ String.fromCharCode(65 + subModeCh);\n                    }\n                    else {\n                        switch (subModeCh) {\n                            case 26:\n                                ch = ' ';\n                                break;\n                            case DecodedBitStreamParser.LL:\n                                subMode = Mode.LOWER;\n                                break;\n                            case DecodedBitStreamParser.ML:\n                                subMode = Mode.MIXED;\n                                break;\n                            case DecodedBitStreamParser.PS:\n                                // Shift to punctuation\n                                priorToShiftMode = subMode;\n                                subMode = Mode.PUNCT_SHIFT;\n                                break;\n                            case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                result.append(/*(char)*/ byteCompactionData[i]);\n                                break;\n                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                                subMode = Mode.ALPHA;\n                                break;\n                        }\n                    }\n                    break;\n                case Mode.LOWER:\n                    // Lower (alphabetic: lowercase)\n                    if (subModeCh < 26) {\n                        ch = /*(char)('a' + subModeCh)*/ String.fromCharCode(97 + subModeCh);\n                    }\n                    else {\n                        switch (subModeCh) {\n                            case 26:\n                                ch = ' ';\n                                break;\n                            case DecodedBitStreamParser.AS:\n                                // Shift to alpha\n                                priorToShiftMode = subMode;\n                                subMode = Mode.ALPHA_SHIFT;\n                                break;\n                            case DecodedBitStreamParser.ML:\n                                subMode = Mode.MIXED;\n                                break;\n                            case DecodedBitStreamParser.PS:\n                                // Shift to punctuation\n                                priorToShiftMode = subMode;\n                                subMode = Mode.PUNCT_SHIFT;\n                                break;\n                            case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                // TODO Does this need to use the current character encoding? See other occurrences below\n                                result.append(/*(char)*/ byteCompactionData[i]);\n                                break;\n                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                                subMode = Mode.ALPHA;\n                                break;\n                        }\n                    }\n                    break;\n                case Mode.MIXED:\n                    // Mixed (punctuation: e)\n                    if (subModeCh < DecodedBitStreamParser.PL) {\n                        ch = DecodedBitStreamParser.MIXED_CHARS[subModeCh];\n                    }\n                    else {\n                        switch (subModeCh) {\n                            case DecodedBitStreamParser.PL:\n                                subMode = Mode.PUNCT;\n                                break;\n                            case 26:\n                                ch = ' ';\n                                break;\n                            case DecodedBitStreamParser.LL:\n                                subMode = Mode.LOWER;\n                                break;\n                            case DecodedBitStreamParser.AL:\n                                subMode = Mode.ALPHA;\n                                break;\n                            case DecodedBitStreamParser.PS:\n                                // Shift to punctuation\n                                priorToShiftMode = subMode;\n                                subMode = Mode.PUNCT_SHIFT;\n                                break;\n                            case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                result.append(/*(char)*/ byteCompactionData[i]);\n                                break;\n                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                                subMode = Mode.ALPHA;\n                                break;\n                        }\n                    }\n                    break;\n                case Mode.PUNCT:\n                    // Punctuation\n                    if (subModeCh < DecodedBitStreamParser.PAL) {\n                        ch = DecodedBitStreamParser.PUNCT_CHARS[subModeCh];\n                    }\n                    else {\n                        switch (subModeCh) {\n                            case DecodedBitStreamParser.PAL:\n                                subMode = Mode.ALPHA;\n                                break;\n                            case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                result.append(/*(char)*/ byteCompactionData[i]);\n                                break;\n                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                                subMode = Mode.ALPHA;\n                                break;\n                        }\n                    }\n                    break;\n                case Mode.ALPHA_SHIFT:\n                    // Restore sub-mode\n                    subMode = priorToShiftMode;\n                    if (subModeCh < 26) {\n                        ch = /*(char)('A' + subModeCh)*/ String.fromCharCode(65 + subModeCh);\n                    }\n                    else {\n                        switch (subModeCh) {\n                            case 26:\n                                ch = ' ';\n                                break;\n                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                                subMode = Mode.ALPHA;\n                                break;\n                        }\n                    }\n                    break;\n                case Mode.PUNCT_SHIFT:\n                    // Restore sub-mode\n                    subMode = priorToShiftMode;\n                    if (subModeCh < DecodedBitStreamParser.PAL) {\n                        ch = DecodedBitStreamParser.PUNCT_CHARS[subModeCh];\n                    }\n                    else {\n                        switch (subModeCh) {\n                            case DecodedBitStreamParser.PAL:\n                                subMode = Mode.ALPHA;\n                                break;\n                            case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                // PS before Shift-to-Byte is used as a padding character,\n                                // see 5.4.2.4 of the specification\n                                result.append(/*(char)*/ byteCompactionData[i]);\n                                break;\n                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                                subMode = Mode.ALPHA;\n                                break;\n                        }\n                    }\n                    break;\n            }\n            // if (ch !== 0) {\n            if (ch !== '') {\n                // Append decoded character to result\n                result.append(ch);\n            }\n            i++;\n        }\n    };\n    /**\n     * Byte Compaction mode (see 5.4.3) permits all 256 possible 8-bit byte values to be encoded.\n     * This includes all ASCII characters value 0 to 127 inclusive and provides for international\n     * character set support.\n     *\n     * @param mode      The byte compaction mode i.e. 901 or 924\n     * @param codewords The array of codewords (data + error)\n     * @param encoding  Currently active character encoding\n     * @param codeIndex The current index into the codeword array.\n     * @param result    The decoded data is appended to the result.\n     * @return The next index into the codeword array.\n     */\n    DecodedBitStreamParser.byteCompaction = function (mode, codewords, encoding, codeIndex, result) {\n        var decodedBytes = new ByteArrayOutputStream_1.default();\n        var count = 0;\n        var value = /*long*/ 0;\n        var end = false;\n        switch (mode) {\n            case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:\n                // Total number of Byte Compaction characters to be encoded\n                // is not a multiple of 6\n                var byteCompactedCodewords = new Int32Array(6);\n                var nextCode = codewords[codeIndex++];\n                while ((codeIndex < codewords[0]) && !end) {\n                    byteCompactedCodewords[count++] = nextCode;\n                    // Base 900\n                    value = 900 * value + nextCode;\n                    nextCode = codewords[codeIndex++];\n                    // perhaps it should be ok to check only nextCode >= TEXT_COMPACTION_MODE_LATCH\n                    switch (nextCode) {\n                        case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                        case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:\n                        case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:\n                        case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:\n                        case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                        case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                        case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:\n                            codeIndex--;\n                            end = true;\n                            break;\n                        default:\n                            if ((count % 5 === 0) && (count > 0)) {\n                                // Decode every 5 codewords\n                                // Convert to Base 256\n                                for (var j /*int*/ = 0; j < 6; ++j) {\n                                    /* @note\n                                     * JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers.\n                                     * So the next bitwise operation could not be done with simple numbers\n                                     */\n                                    decodedBytes.write(/*(byte)*/ Number(createBigInt(value) >> createBigInt(8 * (5 - j))));\n                                }\n                                value = 0;\n                                count = 0;\n                            }\n                            break;\n                    }\n                }\n                // if the end of all codewords is reached the last codeword needs to be added\n                if (codeIndex === codewords[0] && nextCode < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {\n                    byteCompactedCodewords[count++] = nextCode;\n                }\n                // If Byte Compaction mode is invoked with codeword 901,\n                // the last group of codewords is interpreted directly\n                // as one byte per codeword, without compaction.\n                for (var i /*int*/ = 0; i < count; i++) {\n                    decodedBytes.write(/*(byte)*/ byteCompactedCodewords[i]);\n                }\n                break;\n            case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:\n                // Total number of Byte Compaction characters to be encoded\n                // is an integer multiple of 6\n                while (codeIndex < codewords[0] && !end) {\n                    var code = codewords[codeIndex++];\n                    if (code < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {\n                        count++;\n                        // Base 900\n                        value = 900 * value + code;\n                    }\n                    else {\n                        switch (code) {\n                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                            case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:\n                            case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:\n                            case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:\n                            case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                            case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                            case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:\n                                codeIndex--;\n                                end = true;\n                                break;\n                        }\n                    }\n                    if ((count % 5 === 0) && (count > 0)) {\n                        // Decode every 5 codewords\n                        // Convert to Base 256\n                        /* @note\n                         * JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers.\n                         * So the next bitwise operation could not be done with simple numbers\n                        */\n                        for (var j /*int*/ = 0; j < 6; ++j) {\n                            decodedBytes.write(/*(byte)*/ Number(createBigInt(value) >> createBigInt(8 * (5 - j))));\n                        }\n                        value = 0;\n                        count = 0;\n                    }\n                }\n                break;\n        }\n        result.append(StringEncoding_1.default.decode(decodedBytes.toByteArray(), encoding));\n        return codeIndex;\n    };\n    /**\n     * Numeric Compaction mode (see 5.4.4) permits efficient encoding of numeric data strings.\n     *\n     * @param codewords The array of codewords (data + error)\n     * @param codeIndex The current index into the codeword array.\n     * @param result    The decoded data is appended to the result.\n     * @return The next index into the codeword array.\n     *\n     * @throws FormatException\n     */\n    DecodedBitStreamParser.numericCompaction = function (codewords, codeIndex /*int*/, result) {\n        var count = 0;\n        var end = false;\n        var numericCodewords = new Int32Array(DecodedBitStreamParser.MAX_NUMERIC_CODEWORDS);\n        while (codeIndex < codewords[0] && !end) {\n            var code = codewords[codeIndex++];\n            if (codeIndex === codewords[0]) {\n                end = true;\n            }\n            if (code < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {\n                numericCodewords[count] = code;\n                count++;\n            }\n            else {\n                switch (code) {\n                    case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                    case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:\n                    case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:\n                    case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                    case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                    case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:\n                        codeIndex--;\n                        end = true;\n                        break;\n                }\n            }\n            if ((count % DecodedBitStreamParser.MAX_NUMERIC_CODEWORDS === 0 || code === DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH || end) && count > 0) {\n                // Re-invoking Numeric Compaction mode (by using codeword 902\n                // while in Numeric Compaction mode) serves  to terminate the\n                // current Numeric Compaction mode grouping as described in 5.4.4.2,\n                // and then to start a new one grouping.\n                result.append(DecodedBitStreamParser.decodeBase900toBase10(numericCodewords, count));\n                count = 0;\n            }\n        }\n        return codeIndex;\n    };\n    /**\n     * Convert a list of Numeric Compacted codewords from Base 900 to Base 10.\n     *\n     * @param codewords The array of codewords\n     * @param count     The number of codewords\n     * @return The decoded string representing the Numeric data.\n     *\n     * EXAMPLE\n     * Encode the fifteen digit numeric string 000213298174000\n     * Prefix the numeric string with a 1 and set the initial value of\n     * t = 1 000 213 298 174 000\n     * Calculate codeword 0\n     * d0 = 1 000 213 298 174 000 mod 900 = 200\n     *\n     * t = 1 000 213 298 174 000 div 900 = 1 111 348 109 082\n     * Calculate codeword 1\n     * d1 = 1 111 348 109 082 mod 900 = 282\n     *\n     * t = 1 111 348 109 082 div 900 = 1 234 831 232\n     * Calculate codeword 2\n     * d2 = 1 234 831 232 mod 900 = 632\n     *\n     * t = 1 234 831 232 div 900 = 1 372 034\n     * Calculate codeword 3\n     * d3 = 1 372 034 mod 900 = 434\n     *\n     * t = 1 372 034 div 900 = 1 524\n     * Calculate codeword 4\n     * d4 = 1 524 mod 900 = 624\n     *\n     * t = 1 524 div 900 = 1\n     * Calculate codeword 5\n     * d5 = 1 mod 900 = 1\n     * t = 1 div 900 = 0\n     * Codeword sequence is: 1, 624, 434, 632, 282, 200\n     *\n     * Decode the above codewords involves\n     *   1 x 900 power of 5 + 624 x 900 power of 4 + 434 x 900 power of 3 +\n     * 632 x 900 power of 2 + 282 x 900 power of 1 + 200 x 900 power of 0 = 1000213298174000\n     *\n     * Remove leading 1 =>  Result is 000213298174000\n     *\n     * @throws FormatException\n     */\n    DecodedBitStreamParser.decodeBase900toBase10 = function (codewords, count) {\n        var result = createBigInt(0);\n        for (var i /*int*/ = 0; i < count; i++) {\n            result += DecodedBitStreamParser.EXP900[count - i - 1] * createBigInt(codewords[i]);\n        }\n        var resultString = result.toString();\n        if (resultString.charAt(0) !== '1') {\n            throw new FormatException_1.default();\n        }\n        return resultString.substring(1);\n    };\n    DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH = 900;\n    DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH = 901;\n    DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH = 902;\n    DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6 = 924;\n    DecodedBitStreamParser.ECI_USER_DEFINED = 925;\n    DecodedBitStreamParser.ECI_GENERAL_PURPOSE = 926;\n    DecodedBitStreamParser.ECI_CHARSET = 927;\n    DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK = 928;\n    DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD = 923;\n    DecodedBitStreamParser.MACRO_PDF417_TERMINATOR = 922;\n    DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE = 913;\n    DecodedBitStreamParser.MAX_NUMERIC_CODEWORDS = 15;\n    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME = 0;\n    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT = 1;\n    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP = 2;\n    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SENDER = 3;\n    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE = 4;\n    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE = 5;\n    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM = 6;\n    DecodedBitStreamParser.PL = 25;\n    DecodedBitStreamParser.LL = 27;\n    DecodedBitStreamParser.AS = 27;\n    DecodedBitStreamParser.ML = 28;\n    DecodedBitStreamParser.AL = 28;\n    DecodedBitStreamParser.PS = 29;\n    DecodedBitStreamParser.PAL = 29;\n    DecodedBitStreamParser.PUNCT_CHARS = ';<>@[\\\\]_`~!\\r\\t,:\\n-.$/\"|*()?{}\\'';\n    DecodedBitStreamParser.MIXED_CHARS = '0123456789&\\r\\t,:#-.$/+%*=^';\n    /**\n     * Table containing values for the exponent of 900.\n     * This is used in the numeric compaction decode algorithm.\n     */\n    DecodedBitStreamParser.EXP900 = getBigIntConstructor() ? getEXP900() : [];\n    DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS = 2;\n    return DecodedBitStreamParser;\n}());\nexports.default = DecodedBitStreamParser;\n//# sourceMappingURL=DecodedBitStreamParser.js.map"]},"metadata":{},"sourceType":"script"}