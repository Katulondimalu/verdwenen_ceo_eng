{"ast":null,"code":"\"use strict\";\n/* eslint camelcase:off */\n\nconst ArgHandler = require(\"./ArgHandler\");\n\nconst _ = require(\"lodash\");\n\nconst xmlq = require(\"./xmlq\");\n\nconst colorIndexes = require(\"./colorIndexes\");\n/**\n * A Rich text fragment.\n */\n\n\nclass RichTextFragment {\n  /**\n   * Creates a new instance of RichTextFragment.\n   * @constructor\n   * @param {string|Object} value - Text value or XML node\n   * @param {object|undefined|null} [styles] - Multiple styles.\n   * @param {RichText} richText - The rich text instance where this fragment belongs to.\n   */\n  constructor(value, styles, richText) {\n    this._richText = richText;\n\n    if (value.name === 'r') {\n      this._node = value;\n      this._fontNode = xmlq.findChild(this._node, 'rPr');\n\n      if (!this._fontNode) {\n        this._fontNode = {\n          name: 'rPr',\n          attributes: {},\n          children: []\n        };\n\n        this._node.children.unshift(this._fontNode);\n      }\n\n      this._valueNode = xmlq.findChild(this._node, 't');\n    } else {\n      this._node = {\n        name: 'r',\n        attributes: {},\n        children: [{\n          name: 'rPr',\n          attributes: {},\n          children: []\n        }, {\n          name: 't',\n          attributes: {},\n          children: []\n        }]\n      };\n      this._fontNode = xmlq.findChild(this._node, 'rPr');\n      this._valueNode = xmlq.findChild(this._node, 't');\n      this.value(value);\n\n      if (styles) {\n        this.style(styles);\n      }\n    }\n  }\n  /**\n   * Gets the value of this part of rich text\n   * @return {string} text\n   */\n\n  /**\n  * Sets the value of this part of rich text\n  * @param {string} text - the text to set\n  * @return {RichTextFragment} - RichTextFragment\n  */\n\n\n  value() {\n    return new ArgHandler(\"_RichText.value\").case(() => {\n      return this._valueNode.children[0];\n    }).case('string', value => {\n      value = value.replace(/(?:\\r\\n|\\r|\\n)/g, '\\r\\n');\n      const hasLineSeparator = value.indexOf('\\r\\n') !== -1;\n      this._valueNode.children[0] = value;\n      if (value.charAt(0) === ' ') xmlq.setAttributes(this._valueNode, {\n        'xml:space': 'preserve'\n      });\n      if (this._richText) this._richText.removeUnsupportedNodes();\n\n      if (hasLineSeparator) {\n        // set wrapText = true if it contains line separator, excel will only display new lines if it sets.\n        if (this._richText.cell) {\n          this._richText.cell.style('wrapText', true);\n        }\n\n        xmlq.setAttributes(this._valueNode, {\n          'xml:space': 'preserve'\n        });\n      }\n\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Convert the rich text to an XML object.\n   * @returns {{}} The XML form.\n   * @ignore\n   */\n\n\n  toXml() {\n    return this._node;\n  }\n  /**\n   * Gets an individual style.\n   * @param {string} name - The name of the style.\n   * @returns {*} The style.\n   */\n\n  /**\n  * Gets multiple styles.\n  * @param {Array.<string>} names - The names of the style.\n  * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.\n  */\n\n  /**\n  * Sets an individual style.\n  * @param {string} name - The name of the style.\n  * @param {*} value - The value to set.\n  * @returns {RichTextFragment} This RichTextFragment.\n  */\n\n  /**\n  * Sets multiple styles.\n  * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.\n  * @returns {RichTextFragment} This RichTextFragment.\n  */\n\n\n  style() {\n    return new ArgHandler(\"_RichText.style\").case('string', name => {\n      // Get single value\n      const getterName = `_get_${name}`;\n      if (!this[getterName]) throw new Error(`_RichText.style: '${name}' is not a valid style`);\n      return this[getterName]();\n    }).case('array', names => {\n      // Get list of values\n      const values = {};\n      names.forEach(name => {\n        values[name] = this.style(name);\n      });\n      return values;\n    }).case(['string', '*'], (name, value) => {\n      // Set a single value\n      const setterName = `_set_${name}`;\n      if (!this[setterName]) throw new Error(`_RichText.style: '${name}' is not a valid style`);\n      return this[setterName](value);\n    }).case('object', nameValues => {\n      // Object of key value pairs to set\n      for (const name in nameValues) {\n        if (!nameValues.hasOwnProperty(name)) continue;\n        const value = nameValues[name];\n        this.style(name, value);\n      }\n\n      return this;\n    }).handle(arguments);\n  }\n\n  _getColor(node, name) {\n    const child = xmlq.findChild(node, name);\n    if (!child || !child.attributes) return;\n    const color = {};\n    if (child.attributes.hasOwnProperty('rgb')) color.rgb = child.attributes.rgb;else if (child.attributes.hasOwnProperty('theme')) color.theme = child.attributes.theme;else if (child.attributes.hasOwnProperty('indexed')) color.rgb = colorIndexes[child.attributes.indexed];\n    if (child.attributes.hasOwnProperty('tint')) color.tint = child.attributes.tint;\n    if (_.isEmpty(color)) return;\n    return color;\n  }\n\n  _setColor(node, name, color) {\n    if (typeof color === \"string\") color = {\n      rgb: color\n    };else if (typeof color === \"number\") color = {\n      theme: color\n    };\n    xmlq.setChildAttributes(node, name, {\n      rgb: color && color.rgb && color.rgb.toUpperCase(),\n      indexed: null,\n      theme: color && color.theme,\n      tint: color && color.tint\n    });\n    xmlq.removeChildIfEmpty(node, 'color');\n  }\n\n  _get_bold() {\n    return xmlq.hasChild(this._fontNode, 'b');\n  }\n\n  _set_bold(bold) {\n    if (bold) xmlq.appendChildIfNotFound(this._fontNode, \"b\");else xmlq.removeChild(this._fontNode, 'b');\n  }\n\n  _get_italic() {\n    return xmlq.hasChild(this._fontNode, 'i');\n  }\n\n  _set_italic(italic) {\n    if (italic) xmlq.appendChildIfNotFound(this._fontNode, \"i\");else xmlq.removeChild(this._fontNode, 'i');\n  }\n\n  _get_underline() {\n    const uNode = xmlq.findChild(this._fontNode, 'u');\n    return uNode ? uNode.attributes.val || true : false;\n  }\n\n  _set_underline(underline) {\n    if (underline) {\n      const uNode = xmlq.appendChildIfNotFound(this._fontNode, \"u\");\n      const val = typeof underline === 'string' ? underline : null;\n      xmlq.setAttributes(uNode, {\n        val\n      });\n    } else {\n      xmlq.removeChild(this._fontNode, 'u');\n    }\n  }\n\n  _get_strikethrough() {\n    return xmlq.hasChild(this._fontNode, 'strike');\n  }\n\n  _set_strikethrough(strikethrough) {\n    if (strikethrough) xmlq.appendChildIfNotFound(this._fontNode, \"strike\");else xmlq.removeChild(this._fontNode, 'strike');\n  }\n\n  _getFontVerticalAlignment() {\n    return xmlq.getChildAttribute(this._fontNode, 'vertAlign', \"val\");\n  }\n\n  _setFontVerticalAlignment(alignment) {\n    xmlq.setChildAttributes(this._fontNode, 'vertAlign', {\n      val: alignment\n    });\n    xmlq.removeChildIfEmpty(this._fontNode, 'vertAlign');\n  }\n\n  _get_subscript() {\n    return this._getFontVerticalAlignment() === \"subscript\";\n  }\n\n  _set_subscript(subscript) {\n    this._setFontVerticalAlignment(subscript ? \"subscript\" : null);\n  }\n\n  _get_superscript() {\n    return this._getFontVerticalAlignment() === \"superscript\";\n  }\n\n  _set_superscript(superscript) {\n    this._setFontVerticalAlignment(superscript ? \"superscript\" : null);\n  }\n\n  _get_fontSize() {\n    return xmlq.getChildAttribute(this._fontNode, 'sz', \"val\");\n  }\n\n  _set_fontSize(size) {\n    xmlq.setChildAttributes(this._fontNode, 'sz', {\n      val: size\n    });\n    xmlq.removeChildIfEmpty(this._fontNode, 'sz');\n  }\n\n  _get_fontFamily() {\n    return xmlq.getChildAttribute(this._fontNode, 'rFont', \"val\");\n  }\n\n  _set_fontFamily(family) {\n    xmlq.setChildAttributes(this._fontNode, 'rFont', {\n      val: family\n    });\n    xmlq.removeChildIfEmpty(this._fontNode, 'rFont');\n  }\n\n  _get_fontGenericFamily() {\n    return xmlq.getChildAttribute(this._fontNode, 'family', \"val\");\n  }\n  /**\n   * @param {number} genericFamily - 1: Serif, 2: Sans Serif, 3: Monospace,\n   * @private\n   * @return {undefined}\n   */\n\n\n  _set_fontGenericFamily(genericFamily) {\n    xmlq.setChildAttributes(this._fontNode, 'family', {\n      val: genericFamily\n    });\n    xmlq.removeChildIfEmpty(this._fontNode, 'family');\n  }\n\n  _get_fontColor() {\n    return this._getColor(this._fontNode, \"color\");\n  }\n\n  _set_fontColor(color) {\n    this._setColor(this._fontNode, \"color\", color);\n  }\n\n  _get_fontScheme() {\n    // can be 'minor', 'major', 'none'\n    return xmlq.getChildAttribute(this._fontNode, 'scheme', \"val\");\n  }\n  /**\n   * @param {string} scheme - 'minor'|'major'|'none'\n   * @private\n   * @return {undefined}\n   */\n\n\n  _set_fontScheme(scheme) {\n    xmlq.setChildAttributes(this._fontNode, 'scheme', {\n      val: scheme\n    });\n    xmlq.removeChildIfEmpty(this._fontNode, 'scheme');\n  }\n\n} // IE doesn't support function names so explicitly set it.\n\n\nif (!RichTextFragment.name) RichTextFragment.name = \"RichTextFragment\";\nmodule.exports = RichTextFragment;","map":{"version":3,"names":["ArgHandler","require","_","xmlq","colorIndexes","RichTextFragment","constructor","value","styles","richText","_richText","name","_node","_fontNode","findChild","attributes","children","unshift","_valueNode","style","case","replace","hasLineSeparator","indexOf","charAt","setAttributes","removeUnsupportedNodes","cell","handle","arguments","toXml","getterName","Error","names","values","forEach","setterName","nameValues","hasOwnProperty","_getColor","node","child","color","rgb","theme","indexed","tint","isEmpty","_setColor","setChildAttributes","toUpperCase","removeChildIfEmpty","_get_bold","hasChild","_set_bold","bold","appendChildIfNotFound","removeChild","_get_italic","_set_italic","italic","_get_underline","uNode","val","_set_underline","underline","_get_strikethrough","_set_strikethrough","strikethrough","_getFontVerticalAlignment","getChildAttribute","_setFontVerticalAlignment","alignment","_get_subscript","_set_subscript","subscript","_get_superscript","_set_superscript","superscript","_get_fontSize","_set_fontSize","size","_get_fontFamily","_set_fontFamily","family","_get_fontGenericFamily","_set_fontGenericFamily","genericFamily","_get_fontColor","_set_fontColor","_get_fontScheme","_set_fontScheme","scheme","module","exports"],"sources":["/Users/stichtinghelden/Documents/GitHub/de_verdwenen_ceo/node_modules/xlsx-populate/lib/RichTextFragment.js"],"sourcesContent":["\"use strict\";\n\n/* eslint camelcase:off */\n\nconst ArgHandler = require(\"./ArgHandler\");\nconst _ = require(\"lodash\");\nconst xmlq = require(\"./xmlq\");\nconst colorIndexes = require(\"./colorIndexes\");\n\n/**\n * A Rich text fragment.\n */\nclass RichTextFragment {\n    /**\n     * Creates a new instance of RichTextFragment.\n     * @constructor\n     * @param {string|Object} value - Text value or XML node\n     * @param {object|undefined|null} [styles] - Multiple styles.\n     * @param {RichText} richText - The rich text instance where this fragment belongs to.\n     */\n    constructor(value, styles, richText) {\n        this._richText = richText;\n        if (value.name === 'r') {\n            this._node = value;\n            this._fontNode = xmlq.findChild(this._node, 'rPr');\n            if (!this._fontNode) {\n                this._fontNode = { name: 'rPr', attributes: {}, children: [] };\n                this._node.children.unshift(this._fontNode);\n            }\n            this._valueNode = xmlq.findChild(this._node, 't');\n        } else {\n            this._node = {\n                name: 'r',\n                attributes: {},\n                children: [\n                    { name: 'rPr', attributes: {}, children: [] },\n                    { name: 't', attributes: {}, children: [] }\n                ]\n            };\n            this._fontNode = xmlq.findChild(this._node, 'rPr');\n            this._valueNode = xmlq.findChild(this._node, 't');\n            this.value(value);\n            if (styles) {\n                this.style(styles);\n            }\n        }\n    }\n\n    /**\n     * Gets the value of this part of rich text\n     * @return {string} text\n     *//**\n     * Sets the value of this part of rich text\n     * @param {string} text - the text to set\n     * @return {RichTextFragment} - RichTextFragment\n     */\n    value() {\n        return new ArgHandler(\"_RichText.value\")\n            .case(() => {\n                return this._valueNode.children[0];\n            })\n            .case('string', value => {\n                value = value.replace(/(?:\\r\\n|\\r|\\n)/g, '\\r\\n');\n                const hasLineSeparator = value.indexOf('\\r\\n') !== -1;\n                this._valueNode.children[0] = value;\n                if (value.charAt(0) === ' ') xmlq.setAttributes(this._valueNode, { 'xml:space': 'preserve' });\n\n                if (this._richText) this._richText.removeUnsupportedNodes();\n                if (hasLineSeparator) {\n                    // set wrapText = true if it contains line separator, excel will only display new lines if it sets.\n                    if (this._richText.cell) {\n                        this._richText.cell.style('wrapText', true);\n                    }\n                    xmlq.setAttributes(this._valueNode, { 'xml:space': 'preserve' });\n                }\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Convert the rich text to an XML object.\n     * @returns {{}} The XML form.\n     * @ignore\n     */\n    toXml() {\n        return this._node;\n    }\n\n    /**\n     * Gets an individual style.\n     * @param {string} name - The name of the style.\n     * @returns {*} The style.\n     *//**\n     * Gets multiple styles.\n     * @param {Array.<string>} names - The names of the style.\n     * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.\n     *//**\n     * Sets an individual style.\n     * @param {string} name - The name of the style.\n     * @param {*} value - The value to set.\n     * @returns {RichTextFragment} This RichTextFragment.\n     *//**\n     * Sets multiple styles.\n     * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.\n     * @returns {RichTextFragment} This RichTextFragment.\n     */\n    style() {\n        return new ArgHandler(\"_RichText.style\")\n            .case('string', name => {\n                // Get single value\n                const getterName = `_get_${name}`;\n                if (!this[getterName]) throw new Error(`_RichText.style: '${name}' is not a valid style`);\n                return this[getterName]();\n            })\n            .case('array', names => {\n                // Get list of values\n                const values = {};\n                names.forEach(name => {\n                    values[name] = this.style(name);\n                });\n                return values;\n            })\n            .case(['string', '*'], (name, value) => {\n                // Set a single value\n                const setterName = `_set_${name}`;\n                if (!this[setterName]) throw new Error(`_RichText.style: '${name}' is not a valid style`);\n                return this[setterName](value);\n            })\n            .case('object', nameValues => {\n                // Object of key value pairs to set\n                for (const name in nameValues) {\n                    if (!nameValues.hasOwnProperty(name)) continue;\n                    const value = nameValues[name];\n                    this.style(name, value);\n                }\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    _getColor(node, name) {\n        const child = xmlq.findChild(node, name);\n        if (!child || !child.attributes) return;\n\n        const color = {};\n        if (child.attributes.hasOwnProperty('rgb')) color.rgb = child.attributes.rgb;\n        else if (child.attributes.hasOwnProperty('theme')) color.theme = child.attributes.theme;\n        else if (child.attributes.hasOwnProperty('indexed')) color.rgb = colorIndexes[child.attributes.indexed];\n\n        if (child.attributes.hasOwnProperty('tint')) color.tint = child.attributes.tint;\n\n        if (_.isEmpty(color)) return;\n\n        return color;\n    }\n\n    _setColor(node, name, color) {\n        if (typeof color === \"string\") color = { rgb: color };\n        else if (typeof color === \"number\") color = { theme: color };\n\n        xmlq.setChildAttributes(node, name, {\n            rgb: color && color.rgb && color.rgb.toUpperCase(),\n            indexed: null,\n            theme: color && color.theme,\n            tint: color && color.tint\n        });\n\n        xmlq.removeChildIfEmpty(node, 'color');\n    }\n\n    _get_bold() {\n        return xmlq.hasChild(this._fontNode, 'b');\n    }\n\n    _set_bold(bold) {\n        if (bold) xmlq.appendChildIfNotFound(this._fontNode, \"b\");\n        else xmlq.removeChild(this._fontNode, 'b');\n    }\n\n    _get_italic() {\n        return xmlq.hasChild(this._fontNode, 'i');\n    }\n\n    _set_italic(italic) {\n        if (italic) xmlq.appendChildIfNotFound(this._fontNode, \"i\");\n        else xmlq.removeChild(this._fontNode, 'i');\n    }\n\n    _get_underline() {\n        const uNode = xmlq.findChild(this._fontNode, 'u');\n        return uNode ? uNode.attributes.val || true : false;\n    }\n\n    _set_underline(underline) {\n        if (underline) {\n            const uNode = xmlq.appendChildIfNotFound(this._fontNode, \"u\");\n            const val = typeof underline === 'string' ? underline : null;\n            xmlq.setAttributes(uNode, { val });\n        } else {\n            xmlq.removeChild(this._fontNode, 'u');\n        }\n    }\n\n    _get_strikethrough() {\n        return xmlq.hasChild(this._fontNode, 'strike');\n    }\n\n    _set_strikethrough(strikethrough) {\n        if (strikethrough) xmlq.appendChildIfNotFound(this._fontNode, \"strike\");\n        else xmlq.removeChild(this._fontNode, 'strike');\n    }\n\n    _getFontVerticalAlignment() {\n        return xmlq.getChildAttribute(this._fontNode, 'vertAlign', \"val\");\n    }\n\n    _setFontVerticalAlignment(alignment) {\n        xmlq.setChildAttributes(this._fontNode, 'vertAlign', { val: alignment });\n        xmlq.removeChildIfEmpty(this._fontNode, 'vertAlign');\n    }\n\n    _get_subscript() {\n        return this._getFontVerticalAlignment() === \"subscript\";\n    }\n\n    _set_subscript(subscript) {\n        this._setFontVerticalAlignment(subscript ? \"subscript\" : null);\n    }\n\n    _get_superscript() {\n        return this._getFontVerticalAlignment() === \"superscript\";\n    }\n\n    _set_superscript(superscript) {\n        this._setFontVerticalAlignment(superscript ? \"superscript\" : null);\n    }\n\n    _get_fontSize() {\n        return xmlq.getChildAttribute(this._fontNode, 'sz', \"val\");\n    }\n\n    _set_fontSize(size) {\n        xmlq.setChildAttributes(this._fontNode, 'sz', { val: size });\n        xmlq.removeChildIfEmpty(this._fontNode, 'sz');\n    }\n\n    _get_fontFamily() {\n        return xmlq.getChildAttribute(this._fontNode, 'rFont', \"val\");\n    }\n\n    _set_fontFamily(family) {\n        xmlq.setChildAttributes(this._fontNode, 'rFont', { val: family });\n        xmlq.removeChildIfEmpty(this._fontNode, 'rFont');\n    }\n\n    _get_fontGenericFamily() {\n        return xmlq.getChildAttribute(this._fontNode, 'family', \"val\");\n    }\n\n    /**\n     * @param {number} genericFamily - 1: Serif, 2: Sans Serif, 3: Monospace,\n     * @private\n     * @return {undefined}\n     */\n    _set_fontGenericFamily(genericFamily) {\n        xmlq.setChildAttributes(this._fontNode, 'family', { val: genericFamily });\n        xmlq.removeChildIfEmpty(this._fontNode, 'family');\n    }\n\n    _get_fontColor() {\n        return this._getColor(this._fontNode, \"color\");\n    }\n\n    _set_fontColor(color) {\n        this._setColor(this._fontNode, \"color\", color);\n    }\n\n    _get_fontScheme() {\n        // can be 'minor', 'major', 'none'\n        return xmlq.getChildAttribute(this._fontNode, 'scheme', \"val\");\n    }\n\n    /**\n     * @param {string} scheme - 'minor'|'major'|'none'\n     * @private\n     * @return {undefined}\n     */\n    _set_fontScheme(scheme) {\n        xmlq.setChildAttributes(this._fontNode, 'scheme', { val: scheme });\n        xmlq.removeChildIfEmpty(this._fontNode, 'scheme');\n    }\n}\n\n// IE doesn't support function names so explicitly set it.\nif (!RichTextFragment.name) RichTextFragment.name = \"RichTextFragment\";\n\nmodule.exports = RichTextFragment;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}