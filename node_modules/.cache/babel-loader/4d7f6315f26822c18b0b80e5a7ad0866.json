{"ast":null,"code":"\"use strict\";\n\nconst ArgHandler = require(\"./ArgHandler\");\n\nconst addressConverter = require('./addressConverter'); // Default column width.\n\n\nconst defaultColumnWidth = 9.140625;\n/**\n * A column.\n */\n\nclass Column {\n  // /**\n  //  * Creates a new Column.\n  //  * @param {Sheet} sheet - The parent sheet.\n  //  * @param {{}} node - The column node.\n  //  * @constructor\n  //  * @ignore\n  //  * @private\n  //  */\n  constructor(sheet, node) {\n    this._sheet = sheet;\n    this._node = node;\n  }\n  /* PUBLIC */\n\n  /**\n   * Get the address of the column.\n   * @param {{}} [opts] - Options\n   * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.\n   * @param {boolean} [opts.anchored] - Anchor the address.\n   * @returns {string} The address\n   */\n\n\n  address(opts) {\n    return addressConverter.toAddress({\n      type: 'column',\n      columnName: this.columnName(),\n      sheetName: opts && opts.includeSheetName && this.sheet().name(),\n      columnAnchored: opts && opts.anchored\n    });\n  }\n  /**\n   * Get a cell within the column.\n   * @param {number} rowNumber - The row number.\n   * @returns {Cell} The cell in the column with the given row number.\n   */\n\n\n  cell(rowNumber) {\n    return this.sheet().cell(rowNumber, this.columnNumber());\n  }\n  /**\n   * Get the name of the column.\n   * @returns {string} The column name.\n   */\n\n\n  columnName() {\n    return addressConverter.columnNumberToName(this.columnNumber());\n  }\n  /**\n   * Get the number of the column.\n   * @returns {number} The column number.\n   */\n\n\n  columnNumber() {\n    return this._node.attributes.min;\n  }\n  /**\n   * Gets a value indicating whether the column is hidden.\n   * @returns {boolean} A flag indicating whether the column is hidden.\n   */\n\n  /**\n  * Sets whether the column is hidden.\n  * @param {boolean} hidden - A flag indicating whether to hide the column.\n  * @returns {Column} The column.\n  */\n\n\n  hidden() {\n    return new ArgHandler(\"Column.hidden\").case(() => {\n      return this._node.attributes.hidden === 1;\n    }).case('boolean', hidden => {\n      if (hidden) this._node.attributes.hidden = 1;else delete this._node.attributes.hidden;\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Get the parent sheet.\n   * @returns {Sheet} The parent sheet.\n   */\n\n\n  sheet() {\n    return this._sheet;\n  }\n  /**\n   * Gets an individual style.\n   * @param {string} name - The name of the style.\n   * @returns {*} The style.\n   */\n\n  /**\n  * Gets multiple styles.\n  * @param {Array.<string>} names - The names of the style.\n  * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.\n  */\n\n  /**\n  * Sets an individual style.\n  * @param {string} name - The name of the style.\n  * @param {*} value - The value to set.\n  * @returns {Cell} The cell.\n  */\n\n  /**\n  * Sets multiple styles.\n  * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.\n  * @returns {Cell} The cell.\n  */\n\n  /**\n  * Sets to a specific style\n  * @param {Style} style - Style object given from stylesheet.createStyle\n  * @returns {Cell} The cell.\n  */\n\n\n  style() {\n    return new ArgHandler(\"Column.style\").case('string', name => {\n      // Get single value\n      this._createStyleIfNeeded();\n\n      return this._style.style(name);\n    }).case('array', names => {\n      // Get list of values\n      const values = {};\n      names.forEach(name => {\n        values[name] = this.style(name);\n      });\n      return values;\n    }).case(['string', '*'], (name, value) => {\n      // If a row node is already defined that intersects with this column and that row has a style set, we\n      // need to make sure that a cell node exists at the intersection so we can style it appropriately.\n      // Fetching the cell will force a new cell node to be created with a style matching the column. So we\n      // will fetch and style the cell at each row that intersects this column if it is already present or it\n      // has a style defined.\n      this.sheet().forEachExistingRow(row => {\n        if (row.hasStyle() || row.hasCell(this.columnNumber())) {\n          row.cell(this.columnNumber()).style(name, value);\n        }\n      }); // Set a single value for all cells to a single value\n\n      this._createStyleIfNeeded();\n\n      this._style.style(name, value);\n\n      return this;\n    }).case('object', nameValues => {\n      // Object of key value pairs to set\n      for (const name in nameValues) {\n        if (!nameValues.hasOwnProperty(name)) continue;\n        const value = nameValues[name];\n        this.style(name, value);\n      }\n\n      return this;\n    }).case('Style', style => {\n      // See Large Comment Above\n      this.sheet().forEachExistingRow(row => {\n        if (row.hasStyle() || row.hasCell(this.columnNumber())) {\n          row.cell(this.columnNumber()).style(style);\n        }\n      });\n      this._style = style;\n      this._node.attributes.style = style.id();\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Gets the width.\n   * @returns {undefined|number} The width (or undefined).\n   */\n\n  /**\n  * Sets the width.\n  * @param {number} width - The width of the column.\n  * @returns {Column} The column.\n  */\n\n\n  width(width) {\n    return new ArgHandler(\"Column.width\").case(() => {\n      return this._node.attributes.customWidth ? this._node.attributes.width : undefined;\n    }).case('number', width => {\n      this._node.attributes.width = width;\n      this._node.attributes.customWidth = 1;\n      return this;\n    }).case('nil', () => {\n      delete this._node.attributes.width;\n      delete this._node.attributes.customWidth;\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Get the parent workbook.\n   * @returns {Workbook} The parent workbook.\n   */\n\n\n  workbook() {\n    return this.sheet().workbook();\n  }\n  /**\n   * Append vertical page break after the column.\n   * @returns {Column} the column.\n   */\n\n\n  addPageBreak() {\n    this.sheet().verticalPageBreaks().add(this.columnNumber());\n    return this;\n  }\n  /* INTERNAL */\n\n  /**\n   * Convert the column to an XML object.\n   * @returns {{}} The XML form.\n   * @ignore\n   */\n\n\n  toXml() {\n    return this._node;\n  }\n  /* PRIVATE */\n\n  /**\n   * Create a style for this column if it doesn't already exist.\n   * @returns {undefined}\n   * @private\n   */\n\n\n  _createStyleIfNeeded() {\n    if (!this._style) {\n      const styleId = this._node.attributes.style;\n      this._style = this.workbook().styleSheet().createStyle(styleId);\n      this._node.attributes.style = this._style.id();\n      if (!this.width()) this.width(defaultColumnWidth);\n    }\n  }\n\n}\n\nmodule.exports = Column;","map":{"version":3,"names":["ArgHandler","require","addressConverter","defaultColumnWidth","Column","constructor","sheet","node","_sheet","_node","address","opts","toAddress","type","columnName","sheetName","includeSheetName","name","columnAnchored","anchored","cell","rowNumber","columnNumber","columnNumberToName","attributes","min","hidden","case","handle","arguments","style","_createStyleIfNeeded","_style","names","values","forEach","value","forEachExistingRow","row","hasStyle","hasCell","nameValues","hasOwnProperty","id","width","customWidth","undefined","workbook","addPageBreak","verticalPageBreaks","add","toXml","styleId","styleSheet","createStyle","module","exports"],"sources":["/Users/stichtinghelden/Documents/GitHub/de_verdwenen_ceo/node_modules/xlsx-populate/lib/Column.js"],"sourcesContent":["\"use strict\";\n\nconst ArgHandler = require(\"./ArgHandler\");\nconst addressConverter = require('./addressConverter');\n\n// Default column width.\nconst defaultColumnWidth = 9.140625;\n\n/**\n * A column.\n */\nclass Column {\n    // /**\n    //  * Creates a new Column.\n    //  * @param {Sheet} sheet - The parent sheet.\n    //  * @param {{}} node - The column node.\n    //  * @constructor\n    //  * @ignore\n    //  * @private\n    //  */\n    constructor(sheet, node) {\n        this._sheet = sheet;\n        this._node = node;\n    }\n\n    /* PUBLIC */\n\n    /**\n     * Get the address of the column.\n     * @param {{}} [opts] - Options\n     * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.\n     * @param {boolean} [opts.anchored] - Anchor the address.\n     * @returns {string} The address\n     */\n    address(opts) {\n        return addressConverter.toAddress({\n            type: 'column',\n            columnName: this.columnName(),\n            sheetName: opts && opts.includeSheetName && this.sheet().name(),\n            columnAnchored: opts && opts.anchored\n        });\n    }\n\n    /**\n     * Get a cell within the column.\n     * @param {number} rowNumber - The row number.\n     * @returns {Cell} The cell in the column with the given row number.\n     */\n    cell(rowNumber) {\n        return this.sheet().cell(rowNumber, this.columnNumber());\n    }\n\n    /**\n     * Get the name of the column.\n     * @returns {string} The column name.\n     */\n    columnName() {\n        return addressConverter.columnNumberToName(this.columnNumber());\n    }\n\n    /**\n     * Get the number of the column.\n     * @returns {number} The column number.\n     */\n    columnNumber() {\n        return this._node.attributes.min;\n    }\n\n    /**\n     * Gets a value indicating whether the column is hidden.\n     * @returns {boolean} A flag indicating whether the column is hidden.\n     *//**\n     * Sets whether the column is hidden.\n     * @param {boolean} hidden - A flag indicating whether to hide the column.\n     * @returns {Column} The column.\n     */\n    hidden() {\n        return new ArgHandler(\"Column.hidden\")\n            .case(() => {\n                return this._node.attributes.hidden === 1;\n            })\n            .case('boolean', hidden => {\n                if (hidden) this._node.attributes.hidden = 1;\n                else delete this._node.attributes.hidden;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the parent sheet.\n     * @returns {Sheet} The parent sheet.\n     */\n    sheet() {\n        return this._sheet;\n    }\n\n    /**\n     * Gets an individual style.\n     * @param {string} name - The name of the style.\n     * @returns {*} The style.\n     *//**\n     * Gets multiple styles.\n     * @param {Array.<string>} names - The names of the style.\n     * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.\n     *//**\n     * Sets an individual style.\n     * @param {string} name - The name of the style.\n     * @param {*} value - The value to set.\n     * @returns {Cell} The cell.\n     *//**\n     * Sets multiple styles.\n     * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.\n     * @returns {Cell} The cell.\n     *//**\n\t * Sets to a specific style\n\t * @param {Style} style - Style object given from stylesheet.createStyle\n\t * @returns {Cell} The cell.\n\t */\n    style() {\n        return new ArgHandler(\"Column.style\")\n            .case('string', name => {\n                // Get single value\n                this._createStyleIfNeeded();\n                return this._style.style(name);\n            })\n            .case('array', names => {\n                // Get list of values\n                const values = {};\n                names.forEach(name => {\n                    values[name] = this.style(name);\n                });\n\n                return values;\n            })\n            .case(['string', '*'], (name, value) => {\n                // If a row node is already defined that intersects with this column and that row has a style set, we\n                // need to make sure that a cell node exists at the intersection so we can style it appropriately.\n                // Fetching the cell will force a new cell node to be created with a style matching the column. So we\n                // will fetch and style the cell at each row that intersects this column if it is already present or it\n                // has a style defined.\n                this.sheet().forEachExistingRow(row => {\n                    if (row.hasStyle() || row.hasCell(this.columnNumber())) {\n                        row.cell(this.columnNumber()).style(name, value);\n                    }\n                });\n\n                // Set a single value for all cells to a single value\n                this._createStyleIfNeeded();\n                this._style.style(name, value);\n\n                return this;\n            })\n            .case('object', nameValues => {\n                // Object of key value pairs to set\n                for (const name in nameValues) {\n                    if (!nameValues.hasOwnProperty(name)) continue;\n                    const value = nameValues[name];\n                    this.style(name, value);\n                }\n\n                return this;\n            })\n            .case('Style', style => {\n                // See Large Comment Above\n                this.sheet().forEachExistingRow(row => {\n                    if (row.hasStyle() || row.hasCell(this.columnNumber())) {\n                        row.cell(this.columnNumber()).style(style);\n                    }\n                });\n\n                this._style = style;\n                this._node.attributes.style = style.id();\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets the width.\n     * @returns {undefined|number} The width (or undefined).\n     *//**\n     * Sets the width.\n     * @param {number} width - The width of the column.\n     * @returns {Column} The column.\n     */\n    width(width) {\n        return new ArgHandler(\"Column.width\")\n            .case(() => {\n                return this._node.attributes.customWidth ? this._node.attributes.width : undefined;\n            })\n            .case('number', width => {\n                this._node.attributes.width = width;\n                this._node.attributes.customWidth = 1;\n                return this;\n            })\n            .case('nil', () => {\n                delete this._node.attributes.width;\n                delete this._node.attributes.customWidth;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the parent workbook.\n     * @returns {Workbook} The parent workbook.\n     */\n    workbook() {\n        return this.sheet().workbook();\n    }\n\n    /**\n     * Append vertical page break after the column.\n     * @returns {Column} the column.\n     */\n    addPageBreak() {\n        this.sheet().verticalPageBreaks().add(this.columnNumber());\n        return this;\n    }\n\n    /* INTERNAL */\n\n    /**\n     * Convert the column to an XML object.\n     * @returns {{}} The XML form.\n     * @ignore\n     */\n    toXml() {\n        return this._node;\n    }\n\n    /* PRIVATE */\n\n    /**\n     * Create a style for this column if it doesn't already exist.\n     * @returns {undefined}\n     * @private\n     */\n    _createStyleIfNeeded() {\n        if (!this._style) {\n            const styleId = this._node.attributes.style;\n            this._style = this.workbook().styleSheet().createStyle(styleId);\n            this._node.attributes.style = this._style.id();\n\n            if (!this.width()) this.width(defaultColumnWidth);\n        }\n    }\n}\n\nmodule.exports = Column;\n"],"mappings":"AAAA;;AAEA,MAAMA,UAAU,GAAGC,OAAO,CAAC,cAAD,CAA1B;;AACA,MAAMC,gBAAgB,GAAGD,OAAO,CAAC,oBAAD,CAAhC,C,CAEA;;;AACA,MAAME,kBAAkB,GAAG,QAA3B;AAEA;AACA;AACA;;AACA,MAAMC,MAAN,CAAa;EACT;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAC,WAAW,CAACC,KAAD,EAAQC,IAAR,EAAc;IACrB,KAAKC,MAAL,GAAcF,KAAd;IACA,KAAKG,KAAL,GAAaF,IAAb;EACH;EAED;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACIG,OAAO,CAACC,IAAD,EAAO;IACV,OAAOT,gBAAgB,CAACU,SAAjB,CAA2B;MAC9BC,IAAI,EAAE,QADwB;MAE9BC,UAAU,EAAE,KAAKA,UAAL,EAFkB;MAG9BC,SAAS,EAAEJ,IAAI,IAAIA,IAAI,CAACK,gBAAb,IAAiC,KAAKV,KAAL,GAAaW,IAAb,EAHd;MAI9BC,cAAc,EAAEP,IAAI,IAAIA,IAAI,CAACQ;IAJC,CAA3B,CAAP;EAMH;EAED;AACJ;AACA;AACA;AACA;;;EACIC,IAAI,CAACC,SAAD,EAAY;IACZ,OAAO,KAAKf,KAAL,GAAac,IAAb,CAAkBC,SAAlB,EAA6B,KAAKC,YAAL,EAA7B,CAAP;EACH;EAED;AACJ;AACA;AACA;;;EACIR,UAAU,GAAG;IACT,OAAOZ,gBAAgB,CAACqB,kBAAjB,CAAoC,KAAKD,YAAL,EAApC,CAAP;EACH;EAED;AACJ;AACA;AACA;;;EACIA,YAAY,GAAG;IACX,OAAO,KAAKb,KAAL,CAAWe,UAAX,CAAsBC,GAA7B;EACH;EAED;AACJ;AACA;AACA;;EAAO;AACP;AACA;AACA;AACA;;;EACIC,MAAM,GAAG;IACL,OAAO,IAAI1B,UAAJ,CAAe,eAAf,EACF2B,IADE,CACG,MAAM;MACR,OAAO,KAAKlB,KAAL,CAAWe,UAAX,CAAsBE,MAAtB,KAAiC,CAAxC;IACH,CAHE,EAIFC,IAJE,CAIG,SAJH,EAIcD,MAAM,IAAI;MACvB,IAAIA,MAAJ,EAAY,KAAKjB,KAAL,CAAWe,UAAX,CAAsBE,MAAtB,GAA+B,CAA/B,CAAZ,KACK,OAAO,KAAKjB,KAAL,CAAWe,UAAX,CAAsBE,MAA7B;MACL,OAAO,IAAP;IACH,CARE,EASFE,MATE,CASKC,SATL,CAAP;EAUH;EAED;AACJ;AACA;AACA;;;EACIvB,KAAK,GAAG;IACJ,OAAO,KAAKE,MAAZ;EACH;EAED;AACJ;AACA;AACA;AACA;;EAAO;AACP;AACA;AACA;AACA;;EAAO;AACP;AACA;AACA;AACA;AACA;;EAAO;AACP;AACA;AACA;AACA;;EAAO;AACP;AACA;AACA;AACA;;;EACIsB,KAAK,GAAG;IACJ,OAAO,IAAI9B,UAAJ,CAAe,cAAf,EACF2B,IADE,CACG,QADH,EACaV,IAAI,IAAI;MACpB;MACA,KAAKc,oBAAL;;MACA,OAAO,KAAKC,MAAL,CAAYF,KAAZ,CAAkBb,IAAlB,CAAP;IACH,CALE,EAMFU,IANE,CAMG,OANH,EAMYM,KAAK,IAAI;MACpB;MACA,MAAMC,MAAM,GAAG,EAAf;MACAD,KAAK,CAACE,OAAN,CAAclB,IAAI,IAAI;QAClBiB,MAAM,CAACjB,IAAD,CAAN,GAAe,KAAKa,KAAL,CAAWb,IAAX,CAAf;MACH,CAFD;MAIA,OAAOiB,MAAP;IACH,CAdE,EAeFP,IAfE,CAeG,CAAC,QAAD,EAAW,GAAX,CAfH,EAeoB,CAACV,IAAD,EAAOmB,KAAP,KAAiB;MACpC;MACA;MACA;MACA;MACA;MACA,KAAK9B,KAAL,GAAa+B,kBAAb,CAAgCC,GAAG,IAAI;QACnC,IAAIA,GAAG,CAACC,QAAJ,MAAkBD,GAAG,CAACE,OAAJ,CAAY,KAAKlB,YAAL,EAAZ,CAAtB,EAAwD;UACpDgB,GAAG,CAAClB,IAAJ,CAAS,KAAKE,YAAL,EAAT,EAA8BQ,KAA9B,CAAoCb,IAApC,EAA0CmB,KAA1C;QACH;MACJ,CAJD,EANoC,CAYpC;;MACA,KAAKL,oBAAL;;MACA,KAAKC,MAAL,CAAYF,KAAZ,CAAkBb,IAAlB,EAAwBmB,KAAxB;;MAEA,OAAO,IAAP;IACH,CAhCE,EAiCFT,IAjCE,CAiCG,QAjCH,EAiCac,UAAU,IAAI;MAC1B;MACA,KAAK,MAAMxB,IAAX,IAAmBwB,UAAnB,EAA+B;QAC3B,IAAI,CAACA,UAAU,CAACC,cAAX,CAA0BzB,IAA1B,CAAL,EAAsC;QACtC,MAAMmB,KAAK,GAAGK,UAAU,CAACxB,IAAD,CAAxB;QACA,KAAKa,KAAL,CAAWb,IAAX,EAAiBmB,KAAjB;MACH;;MAED,OAAO,IAAP;IACH,CA1CE,EA2CFT,IA3CE,CA2CG,OA3CH,EA2CYG,KAAK,IAAI;MACpB;MACA,KAAKxB,KAAL,GAAa+B,kBAAb,CAAgCC,GAAG,IAAI;QACnC,IAAIA,GAAG,CAACC,QAAJ,MAAkBD,GAAG,CAACE,OAAJ,CAAY,KAAKlB,YAAL,EAAZ,CAAtB,EAAwD;UACpDgB,GAAG,CAAClB,IAAJ,CAAS,KAAKE,YAAL,EAAT,EAA8BQ,KAA9B,CAAoCA,KAApC;QACH;MACJ,CAJD;MAMA,KAAKE,MAAL,GAAcF,KAAd;MACA,KAAKrB,KAAL,CAAWe,UAAX,CAAsBM,KAAtB,GAA8BA,KAAK,CAACa,EAAN,EAA9B;MAEA,OAAO,IAAP;IACH,CAvDE,EAwDFf,MAxDE,CAwDKC,SAxDL,CAAP;EAyDH;EAED;AACJ;AACA;AACA;;EAAO;AACP;AACA;AACA;AACA;;;EACIe,KAAK,CAACA,KAAD,EAAQ;IACT,OAAO,IAAI5C,UAAJ,CAAe,cAAf,EACF2B,IADE,CACG,MAAM;MACR,OAAO,KAAKlB,KAAL,CAAWe,UAAX,CAAsBqB,WAAtB,GAAoC,KAAKpC,KAAL,CAAWe,UAAX,CAAsBoB,KAA1D,GAAkEE,SAAzE;IACH,CAHE,EAIFnB,IAJE,CAIG,QAJH,EAIaiB,KAAK,IAAI;MACrB,KAAKnC,KAAL,CAAWe,UAAX,CAAsBoB,KAAtB,GAA8BA,KAA9B;MACA,KAAKnC,KAAL,CAAWe,UAAX,CAAsBqB,WAAtB,GAAoC,CAApC;MACA,OAAO,IAAP;IACH,CARE,EASFlB,IATE,CASG,KATH,EASU,MAAM;MACf,OAAO,KAAKlB,KAAL,CAAWe,UAAX,CAAsBoB,KAA7B;MACA,OAAO,KAAKnC,KAAL,CAAWe,UAAX,CAAsBqB,WAA7B;MACA,OAAO,IAAP;IACH,CAbE,EAcFjB,MAdE,CAcKC,SAdL,CAAP;EAeH;EAED;AACJ;AACA;AACA;;;EACIkB,QAAQ,GAAG;IACP,OAAO,KAAKzC,KAAL,GAAayC,QAAb,EAAP;EACH;EAED;AACJ;AACA;AACA;;;EACIC,YAAY,GAAG;IACX,KAAK1C,KAAL,GAAa2C,kBAAb,GAAkCC,GAAlC,CAAsC,KAAK5B,YAAL,EAAtC;IACA,OAAO,IAAP;EACH;EAED;;EAEA;AACJ;AACA;AACA;AACA;;;EACI6B,KAAK,GAAG;IACJ,OAAO,KAAK1C,KAAZ;EACH;EAED;;EAEA;AACJ;AACA;AACA;AACA;;;EACIsB,oBAAoB,GAAG;IACnB,IAAI,CAAC,KAAKC,MAAV,EAAkB;MACd,MAAMoB,OAAO,GAAG,KAAK3C,KAAL,CAAWe,UAAX,CAAsBM,KAAtC;MACA,KAAKE,MAAL,GAAc,KAAKe,QAAL,GAAgBM,UAAhB,GAA6BC,WAA7B,CAAyCF,OAAzC,CAAd;MACA,KAAK3C,KAAL,CAAWe,UAAX,CAAsBM,KAAtB,GAA8B,KAAKE,MAAL,CAAYW,EAAZ,EAA9B;MAEA,IAAI,CAAC,KAAKC,KAAL,EAAL,EAAmB,KAAKA,KAAL,CAAWzC,kBAAX;IACtB;EACJ;;AA7OQ;;AAgPboD,MAAM,CAACC,OAAP,GAAiBpD,MAAjB"},"metadata":{},"sourceType":"script"}