{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2013 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // package com.google.zxing.pdf417.decoder;\n// import com.google.zxing.pdf417.PDF417Common;\n\nvar PDF417Common_1 = require(\"../PDF417Common\");\n\nvar Formatter_1 = require(\"../../util/Formatter\");\n/**\n * @author Guenther Grau\n */\n\n\nvar DetectionResult =\n/** @class */\nfunction () {\n  function DetectionResult(barcodeMetadata, boundingBox) {\n    /*final*/\n    this.ADJUST_ROW_NUMBER_SKIP = 2;\n    this.barcodeMetadata = barcodeMetadata;\n    this.barcodeColumnCount = barcodeMetadata.getColumnCount();\n    this.boundingBox = boundingBox; // this.detectionResultColumns = new DetectionResultColumn[this.barcodeColumnCount + 2];\n\n    this.detectionResultColumns = new Array(this.barcodeColumnCount + 2);\n  }\n\n  DetectionResult.prototype.getDetectionResultColumns = function () {\n    this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[0]);\n    this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[this.barcodeColumnCount + 1]);\n    var unadjustedCodewordCount = PDF417Common_1.default.MAX_CODEWORDS_IN_BARCODE;\n    var previousUnadjustedCount;\n\n    do {\n      previousUnadjustedCount = unadjustedCodewordCount;\n      unadjustedCodewordCount = this.adjustRowNumbersAndGetCount();\n    } while (unadjustedCodewordCount > 0 && unadjustedCodewordCount < previousUnadjustedCount);\n\n    return this.detectionResultColumns;\n  };\n\n  DetectionResult.prototype.adjustIndicatorColumnRowNumbers = function (detectionResultColumn) {\n    if (detectionResultColumn != null) {\n      detectionResultColumn.adjustCompleteIndicatorColumnRowNumbers(this.barcodeMetadata);\n    }\n  }; // TODO ensure that no detected codewords with unknown row number are left\n  // we should be able to estimate the row height and use it as a hint for the row number\n  // we should also fill the rows top to bottom and bottom to top\n\n  /**\n   * @return number of codewords which don't have a valid row number. Note that the count is not accurate as codewords\n   * will be counted several times. It just serves as an indicator to see when we can stop adjusting row numbers\n   */\n\n\n  DetectionResult.prototype.adjustRowNumbersAndGetCount = function () {\n    var unadjustedCount = this.adjustRowNumbersByRow();\n\n    if (unadjustedCount === 0) {\n      return 0;\n    }\n\n    for (var barcodeColumn\n    /*int*/\n    = 1; barcodeColumn < this.barcodeColumnCount + 1; barcodeColumn++) {\n      var codewords = this.detectionResultColumns[barcodeColumn].getCodewords();\n\n      for (var codewordsRow\n      /*int*/\n      = 0; codewordsRow < codewords.length; codewordsRow++) {\n        if (codewords[codewordsRow] == null) {\n          continue;\n        }\n\n        if (!codewords[codewordsRow].hasValidRowNumber()) {\n          this.adjustRowNumbers(barcodeColumn, codewordsRow, codewords);\n        }\n      }\n    }\n\n    return unadjustedCount;\n  };\n\n  DetectionResult.prototype.adjustRowNumbersByRow = function () {\n    this.adjustRowNumbersFromBothRI(); // TODO we should only do full row adjustments if row numbers of left and right row indicator column match.\n    // Maybe it's even better to calculated the height (rows: d) and divide it by the number of barcode\n    // rows. This, together with the LRI and RRI row numbers should allow us to get a good estimate where a row\n    // number starts and ends.\n\n    var unadjustedCount = this.adjustRowNumbersFromLRI();\n    return unadjustedCount + this.adjustRowNumbersFromRRI();\n  };\n\n  DetectionResult.prototype.adjustRowNumbersFromBothRI = function () {\n    if (this.detectionResultColumns[0] == null || this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {\n      return;\n    }\n\n    var LRIcodewords = this.detectionResultColumns[0].getCodewords();\n    var RRIcodewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();\n\n    for (var codewordsRow\n    /*int*/\n    = 0; codewordsRow < LRIcodewords.length; codewordsRow++) {\n      if (LRIcodewords[codewordsRow] != null && RRIcodewords[codewordsRow] != null && LRIcodewords[codewordsRow].getRowNumber() === RRIcodewords[codewordsRow].getRowNumber()) {\n        for (var barcodeColumn\n        /*int*/\n        = 1; barcodeColumn <= this.barcodeColumnCount; barcodeColumn++) {\n          var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];\n\n          if (codeword == null) {\n            continue;\n          }\n\n          codeword.setRowNumber(LRIcodewords[codewordsRow].getRowNumber());\n\n          if (!codeword.hasValidRowNumber()) {\n            this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow] = null;\n          }\n        }\n      }\n    }\n  };\n\n  DetectionResult.prototype.adjustRowNumbersFromRRI = function () {\n    if (this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {\n      return 0;\n    }\n\n    var unadjustedCount = 0;\n    var codewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();\n\n    for (var codewordsRow\n    /*int*/\n    = 0; codewordsRow < codewords.length; codewordsRow++) {\n      if (codewords[codewordsRow] == null) {\n        continue;\n      }\n\n      var rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();\n      var invalidRowCounts = 0;\n\n      for (var barcodeColumn\n      /*int*/\n      = this.barcodeColumnCount + 1; barcodeColumn > 0 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn--) {\n        var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];\n\n        if (codeword != null) {\n          invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);\n\n          if (!codeword.hasValidRowNumber()) {\n            unadjustedCount++;\n          }\n        }\n      }\n    }\n\n    return unadjustedCount;\n  };\n\n  DetectionResult.prototype.adjustRowNumbersFromLRI = function () {\n    if (this.detectionResultColumns[0] == null) {\n      return 0;\n    }\n\n    var unadjustedCount = 0;\n    var codewords = this.detectionResultColumns[0].getCodewords();\n\n    for (var codewordsRow\n    /*int*/\n    = 0; codewordsRow < codewords.length; codewordsRow++) {\n      if (codewords[codewordsRow] == null) {\n        continue;\n      }\n\n      var rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();\n      var invalidRowCounts = 0;\n\n      for (var barcodeColumn\n      /*int*/\n      = 1; barcodeColumn < this.barcodeColumnCount + 1 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn++) {\n        var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];\n\n        if (codeword != null) {\n          invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);\n\n          if (!codeword.hasValidRowNumber()) {\n            unadjustedCount++;\n          }\n        }\n      }\n    }\n\n    return unadjustedCount;\n  };\n\n  DetectionResult.adjustRowNumberIfValid = function (rowIndicatorRowNumber, invalidRowCounts, codeword) {\n    if (codeword == null) {\n      return invalidRowCounts;\n    }\n\n    if (!codeword.hasValidRowNumber()) {\n      if (codeword.isValidRowNumber(rowIndicatorRowNumber)) {\n        codeword.setRowNumber(rowIndicatorRowNumber);\n        invalidRowCounts = 0;\n      } else {\n        ++invalidRowCounts;\n      }\n    }\n\n    return invalidRowCounts;\n  };\n\n  DetectionResult.prototype.adjustRowNumbers = function (barcodeColumn, codewordsRow, codewords) {\n    var e_1, _a;\n\n    var codeword = codewords[codewordsRow];\n    var previousColumnCodewords = this.detectionResultColumns[barcodeColumn - 1].getCodewords();\n    var nextColumnCodewords = previousColumnCodewords;\n\n    if (this.detectionResultColumns[barcodeColumn + 1] != null) {\n      nextColumnCodewords = this.detectionResultColumns[barcodeColumn + 1].getCodewords();\n    } // let otherCodewords: Codeword[] = new Codeword[14];\n\n\n    var otherCodewords = new Array(14);\n    otherCodewords[2] = previousColumnCodewords[codewordsRow];\n    otherCodewords[3] = nextColumnCodewords[codewordsRow];\n\n    if (codewordsRow > 0) {\n      otherCodewords[0] = codewords[codewordsRow - 1];\n      otherCodewords[4] = previousColumnCodewords[codewordsRow - 1];\n      otherCodewords[5] = nextColumnCodewords[codewordsRow - 1];\n    }\n\n    if (codewordsRow > 1) {\n      otherCodewords[8] = codewords[codewordsRow - 2];\n      otherCodewords[10] = previousColumnCodewords[codewordsRow - 2];\n      otherCodewords[11] = nextColumnCodewords[codewordsRow - 2];\n    }\n\n    if (codewordsRow < codewords.length - 1) {\n      otherCodewords[1] = codewords[codewordsRow + 1];\n      otherCodewords[6] = previousColumnCodewords[codewordsRow + 1];\n      otherCodewords[7] = nextColumnCodewords[codewordsRow + 1];\n    }\n\n    if (codewordsRow < codewords.length - 2) {\n      otherCodewords[9] = codewords[codewordsRow + 2];\n      otherCodewords[12] = previousColumnCodewords[codewordsRow + 2];\n      otherCodewords[13] = nextColumnCodewords[codewordsRow + 2];\n    }\n\n    try {\n      for (var otherCodewords_1 = __values(otherCodewords), otherCodewords_1_1 = otherCodewords_1.next(); !otherCodewords_1_1.done; otherCodewords_1_1 = otherCodewords_1.next()) {\n        var otherCodeword = otherCodewords_1_1.value;\n\n        if (DetectionResult.adjustRowNumber(codeword, otherCodeword)) {\n          return;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (otherCodewords_1_1 && !otherCodewords_1_1.done && (_a = otherCodewords_1.return)) _a.call(otherCodewords_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n  /**\n   * @return true, if row number was adjusted, false otherwise\n   */\n\n\n  DetectionResult.adjustRowNumber = function (codeword, otherCodeword) {\n    if (otherCodeword == null) {\n      return false;\n    }\n\n    if (otherCodeword.hasValidRowNumber() && otherCodeword.getBucket() === codeword.getBucket()) {\n      codeword.setRowNumber(otherCodeword.getRowNumber());\n      return true;\n    }\n\n    return false;\n  };\n\n  DetectionResult.prototype.getBarcodeColumnCount = function () {\n    return this.barcodeColumnCount;\n  };\n\n  DetectionResult.prototype.getBarcodeRowCount = function () {\n    return this.barcodeMetadata.getRowCount();\n  };\n\n  DetectionResult.prototype.getBarcodeECLevel = function () {\n    return this.barcodeMetadata.getErrorCorrectionLevel();\n  };\n\n  DetectionResult.prototype.setBoundingBox = function (boundingBox) {\n    this.boundingBox = boundingBox;\n  };\n\n  DetectionResult.prototype.getBoundingBox = function () {\n    return this.boundingBox;\n  };\n\n  DetectionResult.prototype.setDetectionResultColumn = function (barcodeColumn, detectionResultColumn) {\n    this.detectionResultColumns[barcodeColumn] = detectionResultColumn;\n  };\n\n  DetectionResult.prototype.getDetectionResultColumn = function (barcodeColumn) {\n    return this.detectionResultColumns[barcodeColumn];\n  }; // @Override\n\n\n  DetectionResult.prototype.toString = function () {\n    var rowIndicatorColumn = this.detectionResultColumns[0];\n\n    if (rowIndicatorColumn == null) {\n      rowIndicatorColumn = this.detectionResultColumns[this.barcodeColumnCount + 1];\n    } // try (\n\n\n    var formatter = new Formatter_1.default(); // ) {\n\n    for (var codewordsRow\n    /*int*/\n    = 0; codewordsRow < rowIndicatorColumn.getCodewords().length; codewordsRow++) {\n      formatter.format('CW %3d:', codewordsRow);\n\n      for (var barcodeColumn\n      /*int*/\n      = 0; barcodeColumn < this.barcodeColumnCount + 2; barcodeColumn++) {\n        if (this.detectionResultColumns[barcodeColumn] == null) {\n          formatter.format('    |   ');\n          continue;\n        }\n\n        var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];\n\n        if (codeword == null) {\n          formatter.format('    |   ');\n          continue;\n        }\n\n        formatter.format(' %3d|%3d', codeword.getRowNumber(), codeword.getValue());\n      }\n\n      formatter.format('%n');\n    }\n\n    return formatter.toString(); // }\n  };\n\n  return DetectionResult;\n}();\n\nexports.default = DetectionResult;","map":{"version":3,"sources":["../../../../src/core/pdf417/decoder/DetectionResult.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2013 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// package com.google.zxing.pdf417.decoder;\n// import com.google.zxing.pdf417.PDF417Common;\nvar PDF417Common_1 = require(\"../PDF417Common\");\nvar Formatter_1 = require(\"../../util/Formatter\");\n/**\n * @author Guenther Grau\n */\nvar DetectionResult = /** @class */ (function () {\n    function DetectionResult(barcodeMetadata, boundingBox) {\n        /*final*/ this.ADJUST_ROW_NUMBER_SKIP = 2;\n        this.barcodeMetadata = barcodeMetadata;\n        this.barcodeColumnCount = barcodeMetadata.getColumnCount();\n        this.boundingBox = boundingBox;\n        // this.detectionResultColumns = new DetectionResultColumn[this.barcodeColumnCount + 2];\n        this.detectionResultColumns = new Array(this.barcodeColumnCount + 2);\n    }\n    DetectionResult.prototype.getDetectionResultColumns = function () {\n        this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[0]);\n        this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[this.barcodeColumnCount + 1]);\n        var unadjustedCodewordCount = PDF417Common_1.default.MAX_CODEWORDS_IN_BARCODE;\n        var previousUnadjustedCount;\n        do {\n            previousUnadjustedCount = unadjustedCodewordCount;\n            unadjustedCodewordCount = this.adjustRowNumbersAndGetCount();\n        } while (unadjustedCodewordCount > 0 && unadjustedCodewordCount < previousUnadjustedCount);\n        return this.detectionResultColumns;\n    };\n    DetectionResult.prototype.adjustIndicatorColumnRowNumbers = function (detectionResultColumn) {\n        if (detectionResultColumn != null) {\n            detectionResultColumn\n                .adjustCompleteIndicatorColumnRowNumbers(this.barcodeMetadata);\n        }\n    };\n    // TODO ensure that no detected codewords with unknown row number are left\n    // we should be able to estimate the row height and use it as a hint for the row number\n    // we should also fill the rows top to bottom and bottom to top\n    /**\n     * @return number of codewords which don't have a valid row number. Note that the count is not accurate as codewords\n     * will be counted several times. It just serves as an indicator to see when we can stop adjusting row numbers\n     */\n    DetectionResult.prototype.adjustRowNumbersAndGetCount = function () {\n        var unadjustedCount = this.adjustRowNumbersByRow();\n        if (unadjustedCount === 0) {\n            return 0;\n        }\n        for (var barcodeColumn /*int*/ = 1; barcodeColumn < this.barcodeColumnCount + 1; barcodeColumn++) {\n            var codewords = this.detectionResultColumns[barcodeColumn].getCodewords();\n            for (var codewordsRow /*int*/ = 0; codewordsRow < codewords.length; codewordsRow++) {\n                if (codewords[codewordsRow] == null) {\n                    continue;\n                }\n                if (!codewords[codewordsRow].hasValidRowNumber()) {\n                    this.adjustRowNumbers(barcodeColumn, codewordsRow, codewords);\n                }\n            }\n        }\n        return unadjustedCount;\n    };\n    DetectionResult.prototype.adjustRowNumbersByRow = function () {\n        this.adjustRowNumbersFromBothRI();\n        // TODO we should only do full row adjustments if row numbers of left and right row indicator column match.\n        // Maybe it's even better to calculated the height (rows: d) and divide it by the number of barcode\n        // rows. This, together with the LRI and RRI row numbers should allow us to get a good estimate where a row\n        // number starts and ends.\n        var unadjustedCount = this.adjustRowNumbersFromLRI();\n        return unadjustedCount + this.adjustRowNumbersFromRRI();\n    };\n    DetectionResult.prototype.adjustRowNumbersFromBothRI = function () {\n        if (this.detectionResultColumns[0] == null || this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {\n            return;\n        }\n        var LRIcodewords = this.detectionResultColumns[0].getCodewords();\n        var RRIcodewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();\n        for (var codewordsRow /*int*/ = 0; codewordsRow < LRIcodewords.length; codewordsRow++) {\n            if (LRIcodewords[codewordsRow] != null &&\n                RRIcodewords[codewordsRow] != null &&\n                LRIcodewords[codewordsRow].getRowNumber() === RRIcodewords[codewordsRow].getRowNumber()) {\n                for (var barcodeColumn /*int*/ = 1; barcodeColumn <= this.barcodeColumnCount; barcodeColumn++) {\n                    var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];\n                    if (codeword == null) {\n                        continue;\n                    }\n                    codeword.setRowNumber(LRIcodewords[codewordsRow].getRowNumber());\n                    if (!codeword.hasValidRowNumber()) {\n                        this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow] = null;\n                    }\n                }\n            }\n        }\n    };\n    DetectionResult.prototype.adjustRowNumbersFromRRI = function () {\n        if (this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {\n            return 0;\n        }\n        var unadjustedCount = 0;\n        var codewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();\n        for (var codewordsRow /*int*/ = 0; codewordsRow < codewords.length; codewordsRow++) {\n            if (codewords[codewordsRow] == null) {\n                continue;\n            }\n            var rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();\n            var invalidRowCounts = 0;\n            for (var barcodeColumn /*int*/ = this.barcodeColumnCount + 1; barcodeColumn > 0 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn--) {\n                var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];\n                if (codeword != null) {\n                    invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);\n                    if (!codeword.hasValidRowNumber()) {\n                        unadjustedCount++;\n                    }\n                }\n            }\n        }\n        return unadjustedCount;\n    };\n    DetectionResult.prototype.adjustRowNumbersFromLRI = function () {\n        if (this.detectionResultColumns[0] == null) {\n            return 0;\n        }\n        var unadjustedCount = 0;\n        var codewords = this.detectionResultColumns[0].getCodewords();\n        for (var codewordsRow /*int*/ = 0; codewordsRow < codewords.length; codewordsRow++) {\n            if (codewords[codewordsRow] == null) {\n                continue;\n            }\n            var rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();\n            var invalidRowCounts = 0;\n            for (var barcodeColumn /*int*/ = 1; barcodeColumn < this.barcodeColumnCount + 1 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn++) {\n                var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];\n                if (codeword != null) {\n                    invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);\n                    if (!codeword.hasValidRowNumber()) {\n                        unadjustedCount++;\n                    }\n                }\n            }\n        }\n        return unadjustedCount;\n    };\n    DetectionResult.adjustRowNumberIfValid = function (rowIndicatorRowNumber, invalidRowCounts, codeword) {\n        if (codeword == null) {\n            return invalidRowCounts;\n        }\n        if (!codeword.hasValidRowNumber()) {\n            if (codeword.isValidRowNumber(rowIndicatorRowNumber)) {\n                codeword.setRowNumber(rowIndicatorRowNumber);\n                invalidRowCounts = 0;\n            }\n            else {\n                ++invalidRowCounts;\n            }\n        }\n        return invalidRowCounts;\n    };\n    DetectionResult.prototype.adjustRowNumbers = function (barcodeColumn, codewordsRow, codewords) {\n        var e_1, _a;\n        var codeword = codewords[codewordsRow];\n        var previousColumnCodewords = this.detectionResultColumns[barcodeColumn - 1].getCodewords();\n        var nextColumnCodewords = previousColumnCodewords;\n        if (this.detectionResultColumns[barcodeColumn + 1] != null) {\n            nextColumnCodewords = this.detectionResultColumns[barcodeColumn + 1].getCodewords();\n        }\n        // let otherCodewords: Codeword[] = new Codeword[14];\n        var otherCodewords = new Array(14);\n        otherCodewords[2] = previousColumnCodewords[codewordsRow];\n        otherCodewords[3] = nextColumnCodewords[codewordsRow];\n        if (codewordsRow > 0) {\n            otherCodewords[0] = codewords[codewordsRow - 1];\n            otherCodewords[4] = previousColumnCodewords[codewordsRow - 1];\n            otherCodewords[5] = nextColumnCodewords[codewordsRow - 1];\n        }\n        if (codewordsRow > 1) {\n            otherCodewords[8] = codewords[codewordsRow - 2];\n            otherCodewords[10] = previousColumnCodewords[codewordsRow - 2];\n            otherCodewords[11] = nextColumnCodewords[codewordsRow - 2];\n        }\n        if (codewordsRow < codewords.length - 1) {\n            otherCodewords[1] = codewords[codewordsRow + 1];\n            otherCodewords[6] = previousColumnCodewords[codewordsRow + 1];\n            otherCodewords[7] = nextColumnCodewords[codewordsRow + 1];\n        }\n        if (codewordsRow < codewords.length - 2) {\n            otherCodewords[9] = codewords[codewordsRow + 2];\n            otherCodewords[12] = previousColumnCodewords[codewordsRow + 2];\n            otherCodewords[13] = nextColumnCodewords[codewordsRow + 2];\n        }\n        try {\n            for (var otherCodewords_1 = __values(otherCodewords), otherCodewords_1_1 = otherCodewords_1.next(); !otherCodewords_1_1.done; otherCodewords_1_1 = otherCodewords_1.next()) {\n                var otherCodeword = otherCodewords_1_1.value;\n                if (DetectionResult.adjustRowNumber(codeword, otherCodeword)) {\n                    return;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (otherCodewords_1_1 && !otherCodewords_1_1.done && (_a = otherCodewords_1.return)) _a.call(otherCodewords_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    /**\n     * @return true, if row number was adjusted, false otherwise\n     */\n    DetectionResult.adjustRowNumber = function (codeword, otherCodeword) {\n        if (otherCodeword == null) {\n            return false;\n        }\n        if (otherCodeword.hasValidRowNumber() && otherCodeword.getBucket() === codeword.getBucket()) {\n            codeword.setRowNumber(otherCodeword.getRowNumber());\n            return true;\n        }\n        return false;\n    };\n    DetectionResult.prototype.getBarcodeColumnCount = function () {\n        return this.barcodeColumnCount;\n    };\n    DetectionResult.prototype.getBarcodeRowCount = function () {\n        return this.barcodeMetadata.getRowCount();\n    };\n    DetectionResult.prototype.getBarcodeECLevel = function () {\n        return this.barcodeMetadata.getErrorCorrectionLevel();\n    };\n    DetectionResult.prototype.setBoundingBox = function (boundingBox) {\n        this.boundingBox = boundingBox;\n    };\n    DetectionResult.prototype.getBoundingBox = function () {\n        return this.boundingBox;\n    };\n    DetectionResult.prototype.setDetectionResultColumn = function (barcodeColumn, detectionResultColumn) {\n        this.detectionResultColumns[barcodeColumn] = detectionResultColumn;\n    };\n    DetectionResult.prototype.getDetectionResultColumn = function (barcodeColumn) {\n        return this.detectionResultColumns[barcodeColumn];\n    };\n    // @Override\n    DetectionResult.prototype.toString = function () {\n        var rowIndicatorColumn = this.detectionResultColumns[0];\n        if (rowIndicatorColumn == null) {\n            rowIndicatorColumn = this.detectionResultColumns[this.barcodeColumnCount + 1];\n        }\n        // try (\n        var formatter = new Formatter_1.default();\n        // ) {\n        for (var codewordsRow /*int*/ = 0; codewordsRow < rowIndicatorColumn.getCodewords().length; codewordsRow++) {\n            formatter.format('CW %3d:', codewordsRow);\n            for (var barcodeColumn /*int*/ = 0; barcodeColumn < this.barcodeColumnCount + 2; barcodeColumn++) {\n                if (this.detectionResultColumns[barcodeColumn] == null) {\n                    formatter.format('    |   ');\n                    continue;\n                }\n                var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];\n                if (codeword == null) {\n                    formatter.format('    |   ');\n                    continue;\n                }\n                formatter.format(' %3d|%3d', codeword.getRowNumber(), codeword.getValue());\n            }\n            formatter.format('%n');\n        }\n        return formatter.toString();\n        // }\n    };\n    return DetectionResult;\n}());\nexports.default = DetectionResult;\n//# sourceMappingURL=DetectionResult.js.map"]},"metadata":{},"sourceType":"script"}