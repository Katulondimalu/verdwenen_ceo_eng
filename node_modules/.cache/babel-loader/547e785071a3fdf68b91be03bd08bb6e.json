{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar BitSource_1 = require(\"../../common/BitSource\");\n\nvar CharacterSetECI_1 = require(\"../../common/CharacterSetECI\");\n\nvar DecoderResult_1 = require(\"../../common/DecoderResult\");\n\nvar StringUtils_1 = require(\"../../common/StringUtils\");\n\nvar Mode_1 = require(\"./Mode\");\n\nvar StringBuilder_1 = require(\"../../util/StringBuilder\");\n\nvar StringEncoding_1 = require(\"../../util/StringEncoding\");\n\nvar FormatException_1 = require(\"../../FormatException\");\n/*import java.io.UnsupportedEncodingException;*/\n\n/*import java.util.ArrayList;*/\n\n/*import java.util.Collection;*/\n\n/*import java.util.List;*/\n\n/*import java.util.Map;*/\n\n/**\n * <p>QR Codes can encode text as bits in one of several modes, and can use multiple modes\n * in one QR Code. This class decodes the bits back into text.</p>\n *\n * <p>See ISO 18004:2006, 6.4.3 - 6.4.7</p>\n *\n * @author Sean Owen\n */\n\n\nvar DecodedBitStreamParser =\n/** @class */\nfunction () {\n  function DecodedBitStreamParser() {}\n\n  DecodedBitStreamParser.decode = function (bytes, version, ecLevel, hints) {\n    var bits = new BitSource_1.default(bytes);\n    var result = new StringBuilder_1.default();\n    var byteSegments = new Array(); // 1\n    // TYPESCRIPTPORT: I do not use constructor with size 1 as in original Java means capacity and the array length is checked below\n\n    var symbolSequence = -1;\n    var parityData = -1;\n\n    try {\n      var currentCharacterSetECI = null;\n      var fc1InEffect = false;\n      var mode = void 0;\n\n      do {\n        // While still another segment to read...\n        if (bits.available() < 4) {\n          // OK, assume we're done. Really, a TERMINATOR mode should have been recorded here\n          mode = Mode_1.default.TERMINATOR;\n        } else {\n          var modeBits = bits.readBits(4);\n          mode = Mode_1.default.forBits(modeBits); // mode is encoded by 4 bits\n        }\n\n        switch (mode) {\n          case Mode_1.default.TERMINATOR:\n            break;\n\n          case Mode_1.default.FNC1_FIRST_POSITION:\n          case Mode_1.default.FNC1_SECOND_POSITION:\n            // We do little with FNC1 except alter the parsed result a bit according to the spec\n            fc1InEffect = true;\n            break;\n\n          case Mode_1.default.STRUCTURED_APPEND:\n            if (bits.available() < 16) {\n              throw new FormatException_1.default();\n            } // sequence number and parity is added later to the result metadata\n            // Read next 8 bits (symbol sequence #) and 8 bits (data: parity), then continue\n\n\n            symbolSequence = bits.readBits(8);\n            parityData = bits.readBits(8);\n            break;\n\n          case Mode_1.default.ECI:\n            // Count doesn't apply to ECI\n            var value = DecodedBitStreamParser.parseECIValue(bits);\n            currentCharacterSetECI = CharacterSetECI_1.default.getCharacterSetECIByValue(value);\n\n            if (currentCharacterSetECI === null) {\n              throw new FormatException_1.default();\n            }\n\n            break;\n\n          case Mode_1.default.HANZI:\n            // First handle Hanzi mode which does not start with character count\n            // Chinese mode contains a sub set indicator right after mode indicator\n            var subset = bits.readBits(4);\n            var countHanzi = bits.readBits(mode.getCharacterCountBits(version));\n\n            if (subset === DecodedBitStreamParser.GB2312_SUBSET) {\n              DecodedBitStreamParser.decodeHanziSegment(bits, result, countHanzi);\n            }\n\n            break;\n\n          default:\n            // \"Normal\" QR code modes:\n            // How many characters will follow, encoded in this mode?\n            var count = bits.readBits(mode.getCharacterCountBits(version));\n\n            switch (mode) {\n              case Mode_1.default.NUMERIC:\n                DecodedBitStreamParser.decodeNumericSegment(bits, result, count);\n                break;\n\n              case Mode_1.default.ALPHANUMERIC:\n                DecodedBitStreamParser.decodeAlphanumericSegment(bits, result, count, fc1InEffect);\n                break;\n\n              case Mode_1.default.BYTE:\n                DecodedBitStreamParser.decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints);\n                break;\n\n              case Mode_1.default.KANJI:\n                DecodedBitStreamParser.decodeKanjiSegment(bits, result, count);\n                break;\n\n              default:\n                throw new FormatException_1.default();\n            }\n\n            break;\n        }\n      } while (mode !== Mode_1.default.TERMINATOR);\n    } catch (iae\n    /*: IllegalArgumentException*/\n    ) {\n      // from readBits() calls\n      throw new FormatException_1.default();\n    }\n\n    return new DecoderResult_1.default(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);\n  };\n  /**\n   * See specification GBT 18284-2000\n   */\n\n\n  DecodedBitStreamParser.decodeHanziSegment = function (bits, result, count\n  /*int*/\n  ) {\n    // Don't crash trying to read more bits than we have available.\n    if (count * 13 > bits.available()) {\n      throw new FormatException_1.default();\n    } // Each character will require 2 bytes. Read the characters as 2-byte pairs\n    // and decode as GB2312 afterwards\n\n\n    var buffer = new Uint8Array(2 * count);\n    var offset = 0;\n\n    while (count > 0) {\n      // Each 13 bits encodes a 2-byte character\n      var twoBytes = bits.readBits(13);\n      var assembledTwoBytes = twoBytes / 0x060 << 8 & 0xFFFFFFFF | twoBytes % 0x060;\n\n      if (assembledTwoBytes < 0x003BF) {\n        // In the 0xA1A1 to 0xAAFE range\n        assembledTwoBytes += 0x0A1A1;\n      } else {\n        // In the 0xB0A1 to 0xFAFE range\n        assembledTwoBytes += 0x0A6A1;\n      }\n\n      buffer[offset] =\n      /*(byte) */\n      assembledTwoBytes >> 8 & 0xFF;\n      buffer[offset + 1] =\n      /*(byte) */\n      assembledTwoBytes & 0xFF;\n      offset += 2;\n      count--;\n    }\n\n    try {\n      result.append(StringEncoding_1.default.decode(buffer, StringUtils_1.default.GB2312)); // TYPESCRIPTPORT: TODO: implement GB2312 decode. StringView from MDN could be a starting point\n    } catch (ignored\n    /*: UnsupportedEncodingException*/\n    ) {\n      throw new FormatException_1.default(ignored);\n    }\n  };\n\n  DecodedBitStreamParser.decodeKanjiSegment = function (bits, result, count\n  /*int*/\n  ) {\n    // Don't crash trying to read more bits than we have available.\n    if (count * 13 > bits.available()) {\n      throw new FormatException_1.default();\n    } // Each character will require 2 bytes. Read the characters as 2-byte pairs\n    // and decode as Shift_JIS afterwards\n\n\n    var buffer = new Uint8Array(2 * count);\n    var offset = 0;\n\n    while (count > 0) {\n      // Each 13 bits encodes a 2-byte character\n      var twoBytes = bits.readBits(13);\n      var assembledTwoBytes = twoBytes / 0x0C0 << 8 & 0xFFFFFFFF | twoBytes % 0x0C0;\n\n      if (assembledTwoBytes < 0x01F00) {\n        // In the 0x8140 to 0x9FFC range\n        assembledTwoBytes += 0x08140;\n      } else {\n        // In the 0xE040 to 0xEBBF range\n        assembledTwoBytes += 0x0C140;\n      }\n\n      buffer[offset] =\n      /*(byte) */\n      assembledTwoBytes >> 8;\n      buffer[offset + 1] =\n      /*(byte) */\n      assembledTwoBytes;\n      offset += 2;\n      count--;\n    } // Shift_JIS may not be supported in some environments:\n\n\n    try {\n      result.append(StringEncoding_1.default.decode(buffer, StringUtils_1.default.SHIFT_JIS)); // TYPESCRIPTPORT: TODO: implement SHIFT_JIS decode. StringView from MDN could be a starting point\n    } catch (ignored\n    /*: UnsupportedEncodingException*/\n    ) {\n      throw new FormatException_1.default(ignored);\n    }\n  };\n\n  DecodedBitStreamParser.decodeByteSegment = function (bits, result, count\n  /*int*/\n  , currentCharacterSetECI, byteSegments, hints) {\n    // Don't crash trying to read more bits than we have available.\n    if (8 * count > bits.available()) {\n      throw new FormatException_1.default();\n    }\n\n    var readBytes = new Uint8Array(count);\n\n    for (var i = 0; i < count; i++) {\n      readBytes[i] =\n      /*(byte) */\n      bits.readBits(8);\n    }\n\n    var encoding;\n\n    if (currentCharacterSetECI === null) {\n      // The spec isn't clear on this mode; see\n      // section 6.4.5: t does not say which encoding to assuming\n      // upon decoding. I have seen ISO-8859-1 used as well as\n      // Shift_JIS -- without anything like an ECI designator to\n      // give a hint.\n      encoding = StringUtils_1.default.guessEncoding(readBytes, hints);\n    } else {\n      encoding = currentCharacterSetECI.getName();\n    }\n\n    try {\n      result.append(StringEncoding_1.default.decode(readBytes, encoding));\n    } catch (ignored\n    /*: UnsupportedEncodingException*/\n    ) {\n      throw new FormatException_1.default(ignored);\n    }\n\n    byteSegments.push(readBytes);\n  };\n\n  DecodedBitStreamParser.toAlphaNumericChar = function (value\n  /*int*/\n  ) {\n    if (value >= DecodedBitStreamParser.ALPHANUMERIC_CHARS.length) {\n      throw new FormatException_1.default();\n    }\n\n    return DecodedBitStreamParser.ALPHANUMERIC_CHARS[value];\n  };\n\n  DecodedBitStreamParser.decodeAlphanumericSegment = function (bits, result, count\n  /*int*/\n  , fc1InEffect) {\n    // Read two characters at a time\n    var start = result.length();\n\n    while (count > 1) {\n      if (bits.available() < 11) {\n        throw new FormatException_1.default();\n      }\n\n      var nextTwoCharsBits = bits.readBits(11);\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(nextTwoCharsBits % 45));\n      count -= 2;\n    }\n\n    if (count === 1) {\n      // special case: one character left\n      if (bits.available() < 6) {\n        throw new FormatException_1.default();\n      }\n\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(bits.readBits(6)));\n    } // See section 6.4.8.1, 6.4.8.2\n\n\n    if (fc1InEffect) {\n      // We need to massage the result a bit if in an FNC1 mode:\n      for (var i = start; i < result.length(); i++) {\n        if (result.charAt(i) === '%') {\n          if (i < result.length() - 1 && result.charAt(i + 1) === '%') {\n            // %% is rendered as %\n            result.deleteCharAt(i + 1);\n          } else {\n            // In alpha mode, % should be converted to FNC1 separator 0x1D\n            result.setCharAt(i, String.fromCharCode(0x1D));\n          }\n        }\n      }\n    }\n  };\n\n  DecodedBitStreamParser.decodeNumericSegment = function (bits, result, count\n  /*int*/\n  ) {\n    // Read three digits at a time\n    while (count >= 3) {\n      // Each 10 bits encodes three digits\n      if (bits.available() < 10) {\n        throw new FormatException_1.default();\n      }\n\n      var threeDigitsBits = bits.readBits(10);\n\n      if (threeDigitsBits >= 1000) {\n        throw new FormatException_1.default();\n      }\n\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(threeDigitsBits % 10));\n      count -= 3;\n    }\n\n    if (count === 2) {\n      // Two digits left over to read, encoded in 7 bits\n      if (bits.available() < 7) {\n        throw new FormatException_1.default();\n      }\n\n      var twoDigitsBits = bits.readBits(7);\n\n      if (twoDigitsBits >= 100) {\n        throw new FormatException_1.default();\n      }\n\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(twoDigitsBits % 10));\n    } else if (count === 1) {\n      // One digit left over to read\n      if (bits.available() < 4) {\n        throw new FormatException_1.default();\n      }\n\n      var digitBits = bits.readBits(4);\n\n      if (digitBits >= 10) {\n        throw new FormatException_1.default();\n      }\n\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(digitBits));\n    }\n  };\n\n  DecodedBitStreamParser.parseECIValue = function (bits) {\n    var firstByte = bits.readBits(8);\n\n    if ((firstByte & 0x80) === 0) {\n      // just one byte\n      return firstByte & 0x7F;\n    }\n\n    if ((firstByte & 0xC0) === 0x80) {\n      // two bytes\n      var secondByte = bits.readBits(8);\n      return (firstByte & 0x3F) << 8 & 0xFFFFFFFF | secondByte;\n    }\n\n    if ((firstByte & 0xE0) === 0xC0) {\n      // three bytes\n      var secondThirdBytes = bits.readBits(16);\n      return (firstByte & 0x1F) << 16 & 0xFFFFFFFF | secondThirdBytes;\n    }\n\n    throw new FormatException_1.default();\n  };\n  /**\n   * See ISO 18004:2006, 6.4.4 Table 5\n   */\n\n\n  DecodedBitStreamParser.ALPHANUMERIC_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';\n  DecodedBitStreamParser.GB2312_SUBSET = 1;\n  return DecodedBitStreamParser;\n}();\n\nexports.default = DecodedBitStreamParser;\n\nfunction Uint8ArrayToString(a) {\n  var CHUNK_SZ = 0x8000;\n  var c = new StringBuilder_1.default();\n\n  for (var i = 0, length_1 = a.length; i < length_1; i += CHUNK_SZ) {\n    c.append(String.fromCharCode.apply(null, a.subarray(i, i + CHUNK_SZ)));\n  }\n\n  return c.toString();\n}","map":{"version":3,"sources":["../../../../src/core/qrcode/decoder/DecodedBitStreamParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BitSource_1 = require(\"../../common/BitSource\");\nvar CharacterSetECI_1 = require(\"../../common/CharacterSetECI\");\nvar DecoderResult_1 = require(\"../../common/DecoderResult\");\nvar StringUtils_1 = require(\"../../common/StringUtils\");\nvar Mode_1 = require(\"./Mode\");\nvar StringBuilder_1 = require(\"../../util/StringBuilder\");\nvar StringEncoding_1 = require(\"../../util/StringEncoding\");\nvar FormatException_1 = require(\"../../FormatException\");\n/*import java.io.UnsupportedEncodingException;*/\n/*import java.util.ArrayList;*/\n/*import java.util.Collection;*/\n/*import java.util.List;*/\n/*import java.util.Map;*/\n/**\n * <p>QR Codes can encode text as bits in one of several modes, and can use multiple modes\n * in one QR Code. This class decodes the bits back into text.</p>\n *\n * <p>See ISO 18004:2006, 6.4.3 - 6.4.7</p>\n *\n * @author Sean Owen\n */\nvar DecodedBitStreamParser = /** @class */ (function () {\n    function DecodedBitStreamParser() {\n    }\n    DecodedBitStreamParser.decode = function (bytes, version, ecLevel, hints) {\n        var bits = new BitSource_1.default(bytes);\n        var result = new StringBuilder_1.default();\n        var byteSegments = new Array(); // 1\n        // TYPESCRIPTPORT: I do not use constructor with size 1 as in original Java means capacity and the array length is checked below\n        var symbolSequence = -1;\n        var parityData = -1;\n        try {\n            var currentCharacterSetECI = null;\n            var fc1InEffect = false;\n            var mode = void 0;\n            do {\n                // While still another segment to read...\n                if (bits.available() < 4) {\n                    // OK, assume we're done. Really, a TERMINATOR mode should have been recorded here\n                    mode = Mode_1.default.TERMINATOR;\n                }\n                else {\n                    var modeBits = bits.readBits(4);\n                    mode = Mode_1.default.forBits(modeBits); // mode is encoded by 4 bits\n                }\n                switch (mode) {\n                    case Mode_1.default.TERMINATOR:\n                        break;\n                    case Mode_1.default.FNC1_FIRST_POSITION:\n                    case Mode_1.default.FNC1_SECOND_POSITION:\n                        // We do little with FNC1 except alter the parsed result a bit according to the spec\n                        fc1InEffect = true;\n                        break;\n                    case Mode_1.default.STRUCTURED_APPEND:\n                        if (bits.available() < 16) {\n                            throw new FormatException_1.default();\n                        }\n                        // sequence number and parity is added later to the result metadata\n                        // Read next 8 bits (symbol sequence #) and 8 bits (data: parity), then continue\n                        symbolSequence = bits.readBits(8);\n                        parityData = bits.readBits(8);\n                        break;\n                    case Mode_1.default.ECI:\n                        // Count doesn't apply to ECI\n                        var value = DecodedBitStreamParser.parseECIValue(bits);\n                        currentCharacterSetECI = CharacterSetECI_1.default.getCharacterSetECIByValue(value);\n                        if (currentCharacterSetECI === null) {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                    case Mode_1.default.HANZI:\n                        // First handle Hanzi mode which does not start with character count\n                        // Chinese mode contains a sub set indicator right after mode indicator\n                        var subset = bits.readBits(4);\n                        var countHanzi = bits.readBits(mode.getCharacterCountBits(version));\n                        if (subset === DecodedBitStreamParser.GB2312_SUBSET) {\n                            DecodedBitStreamParser.decodeHanziSegment(bits, result, countHanzi);\n                        }\n                        break;\n                    default:\n                        // \"Normal\" QR code modes:\n                        // How many characters will follow, encoded in this mode?\n                        var count = bits.readBits(mode.getCharacterCountBits(version));\n                        switch (mode) {\n                            case Mode_1.default.NUMERIC:\n                                DecodedBitStreamParser.decodeNumericSegment(bits, result, count);\n                                break;\n                            case Mode_1.default.ALPHANUMERIC:\n                                DecodedBitStreamParser.decodeAlphanumericSegment(bits, result, count, fc1InEffect);\n                                break;\n                            case Mode_1.default.BYTE:\n                                DecodedBitStreamParser.decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints);\n                                break;\n                            case Mode_1.default.KANJI:\n                                DecodedBitStreamParser.decodeKanjiSegment(bits, result, count);\n                                break;\n                            default:\n                                throw new FormatException_1.default();\n                        }\n                        break;\n                }\n            } while (mode !== Mode_1.default.TERMINATOR);\n        }\n        catch (iae /*: IllegalArgumentException*/) {\n            // from readBits() calls\n            throw new FormatException_1.default();\n        }\n        return new DecoderResult_1.default(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);\n    };\n    /**\n     * See specification GBT 18284-2000\n     */\n    DecodedBitStreamParser.decodeHanziSegment = function (bits, result, count /*int*/) {\n        // Don't crash trying to read more bits than we have available.\n        if (count * 13 > bits.available()) {\n            throw new FormatException_1.default();\n        }\n        // Each character will require 2 bytes. Read the characters as 2-byte pairs\n        // and decode as GB2312 afterwards\n        var buffer = new Uint8Array(2 * count);\n        var offset = 0;\n        while (count > 0) {\n            // Each 13 bits encodes a 2-byte character\n            var twoBytes = bits.readBits(13);\n            var assembledTwoBytes = (((twoBytes / 0x060) << 8) & 0xFFFFFFFF) | (twoBytes % 0x060);\n            if (assembledTwoBytes < 0x003BF) {\n                // In the 0xA1A1 to 0xAAFE range\n                assembledTwoBytes += 0x0A1A1;\n            }\n            else {\n                // In the 0xB0A1 to 0xFAFE range\n                assembledTwoBytes += 0x0A6A1;\n            }\n            buffer[offset] = /*(byte) */ ((assembledTwoBytes >> 8) & 0xFF);\n            buffer[offset + 1] = /*(byte) */ (assembledTwoBytes & 0xFF);\n            offset += 2;\n            count--;\n        }\n        try {\n            result.append(StringEncoding_1.default.decode(buffer, StringUtils_1.default.GB2312));\n            // TYPESCRIPTPORT: TODO: implement GB2312 decode. StringView from MDN could be a starting point\n        }\n        catch (ignored /*: UnsupportedEncodingException*/) {\n            throw new FormatException_1.default(ignored);\n        }\n    };\n    DecodedBitStreamParser.decodeKanjiSegment = function (bits, result, count /*int*/) {\n        // Don't crash trying to read more bits than we have available.\n        if (count * 13 > bits.available()) {\n            throw new FormatException_1.default();\n        }\n        // Each character will require 2 bytes. Read the characters as 2-byte pairs\n        // and decode as Shift_JIS afterwards\n        var buffer = new Uint8Array(2 * count);\n        var offset = 0;\n        while (count > 0) {\n            // Each 13 bits encodes a 2-byte character\n            var twoBytes = bits.readBits(13);\n            var assembledTwoBytes = (((twoBytes / 0x0C0) << 8) & 0xFFFFFFFF) | (twoBytes % 0x0C0);\n            if (assembledTwoBytes < 0x01F00) {\n                // In the 0x8140 to 0x9FFC range\n                assembledTwoBytes += 0x08140;\n            }\n            else {\n                // In the 0xE040 to 0xEBBF range\n                assembledTwoBytes += 0x0C140;\n            }\n            buffer[offset] = /*(byte) */ (assembledTwoBytes >> 8);\n            buffer[offset + 1] = /*(byte) */ assembledTwoBytes;\n            offset += 2;\n            count--;\n        }\n        // Shift_JIS may not be supported in some environments:\n        try {\n            result.append(StringEncoding_1.default.decode(buffer, StringUtils_1.default.SHIFT_JIS));\n            // TYPESCRIPTPORT: TODO: implement SHIFT_JIS decode. StringView from MDN could be a starting point\n        }\n        catch (ignored /*: UnsupportedEncodingException*/) {\n            throw new FormatException_1.default(ignored);\n        }\n    };\n    DecodedBitStreamParser.decodeByteSegment = function (bits, result, count /*int*/, currentCharacterSetECI, byteSegments, hints) {\n        // Don't crash trying to read more bits than we have available.\n        if (8 * count > bits.available()) {\n            throw new FormatException_1.default();\n        }\n        var readBytes = new Uint8Array(count);\n        for (var i = 0; i < count; i++) {\n            readBytes[i] = /*(byte) */ bits.readBits(8);\n        }\n        var encoding;\n        if (currentCharacterSetECI === null) {\n            // The spec isn't clear on this mode; see\n            // section 6.4.5: t does not say which encoding to assuming\n            // upon decoding. I have seen ISO-8859-1 used as well as\n            // Shift_JIS -- without anything like an ECI designator to\n            // give a hint.\n            encoding = StringUtils_1.default.guessEncoding(readBytes, hints);\n        }\n        else {\n            encoding = currentCharacterSetECI.getName();\n        }\n        try {\n            result.append(StringEncoding_1.default.decode(readBytes, encoding));\n        }\n        catch (ignored /*: UnsupportedEncodingException*/) {\n            throw new FormatException_1.default(ignored);\n        }\n        byteSegments.push(readBytes);\n    };\n    DecodedBitStreamParser.toAlphaNumericChar = function (value /*int*/) {\n        if (value >= DecodedBitStreamParser.ALPHANUMERIC_CHARS.length) {\n            throw new FormatException_1.default();\n        }\n        return DecodedBitStreamParser.ALPHANUMERIC_CHARS[value];\n    };\n    DecodedBitStreamParser.decodeAlphanumericSegment = function (bits, result, count /*int*/, fc1InEffect) {\n        // Read two characters at a time\n        var start = result.length();\n        while (count > 1) {\n            if (bits.available() < 11) {\n                throw new FormatException_1.default();\n            }\n            var nextTwoCharsBits = bits.readBits(11);\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(nextTwoCharsBits % 45));\n            count -= 2;\n        }\n        if (count === 1) {\n            // special case: one character left\n            if (bits.available() < 6) {\n                throw new FormatException_1.default();\n            }\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(bits.readBits(6)));\n        }\n        // See section 6.4.8.1, 6.4.8.2\n        if (fc1InEffect) {\n            // We need to massage the result a bit if in an FNC1 mode:\n            for (var i = start; i < result.length(); i++) {\n                if (result.charAt(i) === '%') {\n                    if (i < result.length() - 1 && result.charAt(i + 1) === '%') {\n                        // %% is rendered as %\n                        result.deleteCharAt(i + 1);\n                    }\n                    else {\n                        // In alpha mode, % should be converted to FNC1 separator 0x1D\n                        result.setCharAt(i, String.fromCharCode(0x1D));\n                    }\n                }\n            }\n        }\n    };\n    DecodedBitStreamParser.decodeNumericSegment = function (bits, result, count /*int*/) {\n        // Read three digits at a time\n        while (count >= 3) {\n            // Each 10 bits encodes three digits\n            if (bits.available() < 10) {\n                throw new FormatException_1.default();\n            }\n            var threeDigitsBits = bits.readBits(10);\n            if (threeDigitsBits >= 1000) {\n                throw new FormatException_1.default();\n            }\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(threeDigitsBits % 10));\n            count -= 3;\n        }\n        if (count === 2) {\n            // Two digits left over to read, encoded in 7 bits\n            if (bits.available() < 7) {\n                throw new FormatException_1.default();\n            }\n            var twoDigitsBits = bits.readBits(7);\n            if (twoDigitsBits >= 100) {\n                throw new FormatException_1.default();\n            }\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(twoDigitsBits % 10));\n        }\n        else if (count === 1) {\n            // One digit left over to read\n            if (bits.available() < 4) {\n                throw new FormatException_1.default();\n            }\n            var digitBits = bits.readBits(4);\n            if (digitBits >= 10) {\n                throw new FormatException_1.default();\n            }\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(digitBits));\n        }\n    };\n    DecodedBitStreamParser.parseECIValue = function (bits) {\n        var firstByte = bits.readBits(8);\n        if ((firstByte & 0x80) === 0) {\n            // just one byte\n            return firstByte & 0x7F;\n        }\n        if ((firstByte & 0xC0) === 0x80) {\n            // two bytes\n            var secondByte = bits.readBits(8);\n            return (((firstByte & 0x3F) << 8) & 0xFFFFFFFF) | secondByte;\n        }\n        if ((firstByte & 0xE0) === 0xC0) {\n            // three bytes\n            var secondThirdBytes = bits.readBits(16);\n            return (((firstByte & 0x1F) << 16) & 0xFFFFFFFF) | secondThirdBytes;\n        }\n        throw new FormatException_1.default();\n    };\n    /**\n     * See ISO 18004:2006, 6.4.4 Table 5\n     */\n    DecodedBitStreamParser.ALPHANUMERIC_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';\n    DecodedBitStreamParser.GB2312_SUBSET = 1;\n    return DecodedBitStreamParser;\n}());\nexports.default = DecodedBitStreamParser;\nfunction Uint8ArrayToString(a) {\n    var CHUNK_SZ = 0x8000;\n    var c = new StringBuilder_1.default();\n    for (var i = 0, length_1 = a.length; i < length_1; i += CHUNK_SZ) {\n        c.append(String.fromCharCode.apply(null, a.subarray(i, i + CHUNK_SZ)));\n    }\n    return c.toString();\n}\n//# sourceMappingURL=DecodedBitStreamParser.js.map"]},"metadata":{},"sourceType":"script"}