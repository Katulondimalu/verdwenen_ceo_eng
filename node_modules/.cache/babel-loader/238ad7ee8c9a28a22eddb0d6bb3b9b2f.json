{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\n\nconst XML_DECLARATION = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>`;\n/**\n * XML document builder.\n * @private\n */\n\nclass XmlBuilder {\n  /**\n   * Build an XML string from the JSON object.\n   * @param {{}} node - The node.\n   * @returns {string} The XML text.\n   */\n  build(node) {\n    this._i = 0;\n\n    const xml = this._build(node, '');\n\n    if (xml === '') return;\n    return XML_DECLARATION + xml;\n  }\n  /**\n   * Build the XML string. (This is the internal recursive method.)\n   * @param {{}} node - The node.\n   * @param {string} xml - The initial XML doc string.\n   * @returns {string} The generated XML element.\n   * @private\n   */\n\n\n  _build(node, xml) {\n    // For CPU performance, JS engines don't truly concatenate strings; they create a tree of pointers to\n    // the various concatenated strings. The downside of this is that it consumes a lot of memory, which\n    // will cause problems with large workbooks. So periodically, we grab a character from the xml, which\n    // causes the JS engine to flatten the tree into a single string. Do this too often and CPU takes a hit.\n    // Too frequently and memory takes a hit. Every 100k nodes seems to be a good balance.\n    if (this._i++ % 1000000 === 0) {\n      this._c = xml[0];\n    } // If the node has a toXml method, call it.\n\n\n    if (node && _.isFunction(node.toXml)) node = node.toXml();\n\n    if (_.isObject(node)) {\n      // If the node is an object, then it maps to an element. Check if it has a name.\n      if (!node.name) throw new Error(`XML node does not have name: ${JSON.stringify(node)}`); // Add the opening tag.\n\n      xml += `<${node.name}`; // Add any node attributes\n\n      _.forOwn(node.attributes, (value, name) => {\n        xml += ` ${name}=\"${this._escapeString(value, true)}\"`;\n      });\n\n      if (_.isEmpty(node.children)) {\n        // Self-close the tag if no children.\n        xml += \"/>\";\n      } else {\n        xml += \">\"; // Recursively add any children.\n\n        _.forEach(node.children, child => {\n          // Add the children to the XML.\n          xml = this._build(child, xml);\n        }); // Close the tag.\n\n\n        xml += `</${node.name}>`;\n      }\n    } else if (!_.isNil(node)) {\n      // It not an object, this should be a text node. Just add it.\n      xml += this._escapeString(node);\n    } // Return the updated XML element.\n\n\n    return xml;\n  }\n  /**\n   * Escape a string for use in XML by replacing &, \", ', <, and >.\n   * @param {*} value - The value to escape.\n   * @param {boolean} [isAttribute] - A flag indicating if this is an attribute.\n   * @returns {string} The escaped string.\n   * @private\n   */\n\n\n  _escapeString(value, isAttribute) {\n    if (_.isNil(value)) return value;\n    value = value.toString().replace(/&/g, \"&amp;\") // Escape '&' first as the other escapes add them.\n    .replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n\n    if (isAttribute) {\n      value = value.replace(/\"/g, \"&quot;\");\n    }\n\n    return value;\n  }\n\n}\n\nmodule.exports = XmlBuilder;","map":{"version":3,"names":["_","require","XML_DECLARATION","XmlBuilder","build","node","_i","xml","_build","_c","isFunction","toXml","isObject","name","Error","JSON","stringify","forOwn","attributes","value","_escapeString","isEmpty","children","forEach","child","isNil","isAttribute","toString","replace","module","exports"],"sources":["/Users/stichtinghelden/Documents/GitHub/de_verdwenen_ceo/node_modules/xlsx-populate/lib/XmlBuilder.js"],"sourcesContent":["\"use strict\";\n\nconst _ = require(\"lodash\");\n\nconst XML_DECLARATION = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>`;\n\n/**\n * XML document builder.\n * @private\n */\nclass XmlBuilder {\n    /**\n     * Build an XML string from the JSON object.\n     * @param {{}} node - The node.\n     * @returns {string} The XML text.\n     */\n    build(node) {\n        this._i = 0;\n        const xml = this._build(node, '');\n        if (xml === '') return;\n        return XML_DECLARATION + xml;\n    }\n\n    /**\n     * Build the XML string. (This is the internal recursive method.)\n     * @param {{}} node - The node.\n     * @param {string} xml - The initial XML doc string.\n     * @returns {string} The generated XML element.\n     * @private\n     */\n    _build(node, xml) {\n        // For CPU performance, JS engines don't truly concatenate strings; they create a tree of pointers to\n        // the various concatenated strings. The downside of this is that it consumes a lot of memory, which\n        // will cause problems with large workbooks. So periodically, we grab a character from the xml, which\n        // causes the JS engine to flatten the tree into a single string. Do this too often and CPU takes a hit.\n        // Too frequently and memory takes a hit. Every 100k nodes seems to be a good balance.\n        if (this._i++ % 1000000 === 0) {\n            this._c = xml[0];\n        }\n\n        // If the node has a toXml method, call it.\n        if (node && _.isFunction(node.toXml)) node = node.toXml();\n\n        if (_.isObject(node)) {\n            // If the node is an object, then it maps to an element. Check if it has a name.\n            if (!node.name) throw new Error(`XML node does not have name: ${JSON.stringify(node)}`);\n\n            // Add the opening tag.\n            xml += `<${node.name}`;\n\n            // Add any node attributes\n            _.forOwn(node.attributes, (value, name) => {\n                xml += ` ${name}=\"${this._escapeString(value, true)}\"`;\n            });\n\n            if (_.isEmpty(node.children)) {\n                // Self-close the tag if no children.\n                xml += \"/>\";\n            } else {\n                xml += \">\";\n                \n                // Recursively add any children.\n                _.forEach(node.children, child => {\n                    // Add the children to the XML.\n                    xml = this._build(child, xml);\n                });\n\n                // Close the tag.\n                xml += `</${node.name}>`;\n            }\n        } else if (!_.isNil(node)) {\n            // It not an object, this should be a text node. Just add it.\n            xml += this._escapeString(node);\n        }\n\n        // Return the updated XML element.\n        return xml;\n    }\n\n    /**\n     * Escape a string for use in XML by replacing &, \", ', <, and >.\n     * @param {*} value - The value to escape.\n     * @param {boolean} [isAttribute] - A flag indicating if this is an attribute.\n     * @returns {string} The escaped string.\n     * @private\n     */\n    _escapeString(value, isAttribute) {\n        if (_.isNil(value)) return value;\n        value = value.toString()\n            .replace(/&/g, \"&amp;\") // Escape '&' first as the other escapes add them.\n            .replace(/</g, \"&lt;\")\n            .replace(/>/g, \"&gt;\");\n\n        if (isAttribute) {\n            value = value.replace(/\"/g, \"&quot;\");\n        }\n\n        return value;\n    }\n}\n\nmodule.exports = XmlBuilder;\n"],"mappings":"AAAA;;AAEA,MAAMA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;;AAEA,MAAMC,eAAe,GAAI,yDAAzB;AAEA;AACA;AACA;AACA;;AACA,MAAMC,UAAN,CAAiB;EACb;AACJ;AACA;AACA;AACA;EACIC,KAAK,CAACC,IAAD,EAAO;IACR,KAAKC,EAAL,GAAU,CAAV;;IACA,MAAMC,GAAG,GAAG,KAAKC,MAAL,CAAYH,IAAZ,EAAkB,EAAlB,CAAZ;;IACA,IAAIE,GAAG,KAAK,EAAZ,EAAgB;IAChB,OAAOL,eAAe,GAAGK,GAAzB;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACIC,MAAM,CAACH,IAAD,EAAOE,GAAP,EAAY;IACd;IACA;IACA;IACA;IACA;IACA,IAAI,KAAKD,EAAL,KAAY,OAAZ,KAAwB,CAA5B,EAA+B;MAC3B,KAAKG,EAAL,GAAUF,GAAG,CAAC,CAAD,CAAb;IACH,CARa,CAUd;;;IACA,IAAIF,IAAI,IAAIL,CAAC,CAACU,UAAF,CAAaL,IAAI,CAACM,KAAlB,CAAZ,EAAsCN,IAAI,GAAGA,IAAI,CAACM,KAAL,EAAP;;IAEtC,IAAIX,CAAC,CAACY,QAAF,CAAWP,IAAX,CAAJ,EAAsB;MAClB;MACA,IAAI,CAACA,IAAI,CAACQ,IAAV,EAAgB,MAAM,IAAIC,KAAJ,CAAW,gCAA+BC,IAAI,CAACC,SAAL,CAAeX,IAAf,CAAqB,EAA/D,CAAN,CAFE,CAIlB;;MACAE,GAAG,IAAK,IAAGF,IAAI,CAACQ,IAAK,EAArB,CALkB,CAOlB;;MACAb,CAAC,CAACiB,MAAF,CAASZ,IAAI,CAACa,UAAd,EAA0B,CAACC,KAAD,EAAQN,IAAR,KAAiB;QACvCN,GAAG,IAAK,IAAGM,IAAK,KAAI,KAAKO,aAAL,CAAmBD,KAAnB,EAA0B,IAA1B,CAAgC,GAApD;MACH,CAFD;;MAIA,IAAInB,CAAC,CAACqB,OAAF,CAAUhB,IAAI,CAACiB,QAAf,CAAJ,EAA8B;QAC1B;QACAf,GAAG,IAAI,IAAP;MACH,CAHD,MAGO;QACHA,GAAG,IAAI,GAAP,CADG,CAGH;;QACAP,CAAC,CAACuB,OAAF,CAAUlB,IAAI,CAACiB,QAAf,EAAyBE,KAAK,IAAI;UAC9B;UACAjB,GAAG,GAAG,KAAKC,MAAL,CAAYgB,KAAZ,EAAmBjB,GAAnB,CAAN;QACH,CAHD,EAJG,CASH;;;QACAA,GAAG,IAAK,KAAIF,IAAI,CAACQ,IAAK,GAAtB;MACH;IACJ,CA3BD,MA2BO,IAAI,CAACb,CAAC,CAACyB,KAAF,CAAQpB,IAAR,CAAL,EAAoB;MACvB;MACAE,GAAG,IAAI,KAAKa,aAAL,CAAmBf,IAAnB,CAAP;IACH,CA3Ca,CA6Cd;;;IACA,OAAOE,GAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACIa,aAAa,CAACD,KAAD,EAAQO,WAAR,EAAqB;IAC9B,IAAI1B,CAAC,CAACyB,KAAF,CAAQN,KAAR,CAAJ,EAAoB,OAAOA,KAAP;IACpBA,KAAK,GAAGA,KAAK,CAACQ,QAAN,GACHC,OADG,CACK,IADL,EACW,OADX,EACoB;IADpB,CAEHA,OAFG,CAEK,IAFL,EAEW,MAFX,EAGHA,OAHG,CAGK,IAHL,EAGW,MAHX,CAAR;;IAKA,IAAIF,WAAJ,EAAiB;MACbP,KAAK,GAAGA,KAAK,CAACS,OAAN,CAAc,IAAd,EAAoB,QAApB,CAAR;IACH;;IAED,OAAOT,KAAP;EACH;;AAxFY;;AA2FjBU,MAAM,CAACC,OAAP,GAAiB3B,UAAjB"},"metadata":{},"sourceType":"script"}