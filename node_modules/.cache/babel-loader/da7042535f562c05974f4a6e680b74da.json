{"ast":null,"code":"\"use strict\";\n\nconst sax = require(\"sax\");\n\nconst externals = require(\"./externals\"); // Regex to check if string is all whitespace.\n\n\nconst allWhitespaceRegex = /^\\s+$/;\n/**\n * XML parser.\n * @private\n */\n\nclass XmlParser {\n  /**\n   * Parse the XML text into a JSON object.\n   * @param {string} xmlText - The XML text.\n   * @returns {{}} The JSON object.\n   */\n  parseAsync(xmlText) {\n    return new externals.Promise((resolve, reject) => {\n      // Create the SAX parser.\n      const parser = sax.parser(true); // Parsed is the full parsed object. Current is the current node being parsed. Stack is the current stack of\n      // nodes leading to the current one.\n\n      let parsed, current;\n      const stack = []; // On error: Reject the promise.\n\n      parser.onerror = reject; // On text nodes: If it is all whitespace, do nothing. Otherwise, try to convert to a number and add as a child.\n\n      parser.ontext = text => {\n        if (allWhitespaceRegex.test(text)) {\n          if (current && current.attributes['xml:space'] === 'preserve') {\n            current.children.push(text);\n          }\n        } else {\n          current.children.push(this._covertToNumberIfNumber(text));\n        }\n      }; // On open tag start: Create a child element. If this is the root element, set it as parsed. Otherwise, add\n      // it as a child to the current node.\n\n\n      parser.onopentagstart = node => {\n        const child = {\n          name: node.name,\n          attributes: {},\n          children: []\n        };\n\n        if (current) {\n          current.children.push(child);\n        } else {\n          parsed = child;\n        }\n\n        stack.push(child);\n        current = child;\n      }; // On close tag: Pop the stack.\n\n\n      parser.onclosetag = node => {\n        stack.pop();\n        current = stack[stack.length - 1];\n      }; // On attribute: Try to convert the value to a number and add to the current node.\n\n\n      parser.onattribute = attribute => {\n        current.attributes[attribute.name] = this._covertToNumberIfNumber(attribute.value);\n      }; // On end: Resolve the promise.\n\n\n      parser.onend = () => resolve(parsed); // Start parsing the text.\n\n\n      parser.write(xmlText).close();\n    });\n  }\n  /**\n   * Convert the string to a number if it looks like one.\n   * @param {string} str - The string to convert.\n   * @returns {string|number} The number if converted or the string if not.\n   * @private\n   */\n\n\n  _covertToNumberIfNumber(str) {\n    const num = Number(str);\n    return num.toString() === str ? num : str;\n  }\n\n}\n\nmodule.exports = XmlParser;","map":{"version":3,"names":["sax","require","externals","allWhitespaceRegex","XmlParser","parseAsync","xmlText","Promise","resolve","reject","parser","parsed","current","stack","onerror","ontext","text","test","attributes","children","push","_covertToNumberIfNumber","onopentagstart","node","child","name","onclosetag","pop","length","onattribute","attribute","value","onend","write","close","str","num","Number","toString","module","exports"],"sources":["/Users/stichtinghelden/Documents/GitHub/de_verdwenen_ceo/node_modules/xlsx-populate/lib/XmlParser.js"],"sourcesContent":["\"use strict\";\n\nconst sax = require(\"sax\");\nconst externals = require(\"./externals\");\n\n// Regex to check if string is all whitespace.\nconst allWhitespaceRegex = /^\\s+$/;\n\n/**\n * XML parser.\n * @private\n */\nclass XmlParser {\n    /**\n     * Parse the XML text into a JSON object.\n     * @param {string} xmlText - The XML text.\n     * @returns {{}} The JSON object.\n     */\n    parseAsync(xmlText) {\n        return new externals.Promise((resolve, reject) => {\n            // Create the SAX parser.\n            const parser = sax.parser(true);\n\n            // Parsed is the full parsed object. Current is the current node being parsed. Stack is the current stack of\n            // nodes leading to the current one.\n            let parsed, current;\n            const stack = [];\n\n            // On error: Reject the promise.\n            parser.onerror = reject;\n\n            // On text nodes: If it is all whitespace, do nothing. Otherwise, try to convert to a number and add as a child.\n            parser.ontext = text => {\n                if (allWhitespaceRegex.test(text)) {\n                    if (current && current.attributes['xml:space'] === 'preserve') {\n                        current.children.push(text);\n                    }\n                } else {\n                    current.children.push(this._covertToNumberIfNumber(text));\n                }\n            };\n\n            // On open tag start: Create a child element. If this is the root element, set it as parsed. Otherwise, add\n            // it as a child to the current node.\n            parser.onopentagstart = node => {\n                const child = { name: node.name, attributes: {}, children: [] };\n                if (current) {\n                    current.children.push(child);\n                } else {\n                    parsed = child;\n                }\n\n                stack.push(child);\n                current = child;\n            };\n\n            // On close tag: Pop the stack.\n            parser.onclosetag = node => {\n                stack.pop();\n                current = stack[stack.length - 1];\n            };\n\n            // On attribute: Try to convert the value to a number and add to the current node.\n            parser.onattribute = attribute => {\n                current.attributes[attribute.name] = this._covertToNumberIfNumber(attribute.value);\n            };\n\n            // On end: Resolve the promise.\n            parser.onend = () => resolve(parsed);\n\n            // Start parsing the text.\n            parser.write(xmlText).close();\n        });\n    }\n\n    /**\n     * Convert the string to a number if it looks like one.\n     * @param {string} str - The string to convert.\n     * @returns {string|number} The number if converted or the string if not.\n     * @private\n     */\n    _covertToNumberIfNumber(str) {\n        const num = Number(str);\n        return num.toString() === str ? num : str;\n    }\n}\n\nmodule.exports = XmlParser;\n"],"mappings":"AAAA;;AAEA,MAAMA,GAAG,GAAGC,OAAO,CAAC,KAAD,CAAnB;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,aAAD,CAAzB,C,CAEA;;;AACA,MAAME,kBAAkB,GAAG,OAA3B;AAEA;AACA;AACA;AACA;;AACA,MAAMC,SAAN,CAAgB;EACZ;AACJ;AACA;AACA;AACA;EACIC,UAAU,CAACC,OAAD,EAAU;IAChB,OAAO,IAAIJ,SAAS,CAACK,OAAd,CAAsB,CAACC,OAAD,EAAUC,MAAV,KAAqB;MAC9C;MACA,MAAMC,MAAM,GAAGV,GAAG,CAACU,MAAJ,CAAW,IAAX,CAAf,CAF8C,CAI9C;MACA;;MACA,IAAIC,MAAJ,EAAYC,OAAZ;MACA,MAAMC,KAAK,GAAG,EAAd,CAP8C,CAS9C;;MACAH,MAAM,CAACI,OAAP,GAAiBL,MAAjB,CAV8C,CAY9C;;MACAC,MAAM,CAACK,MAAP,GAAgBC,IAAI,IAAI;QACpB,IAAIb,kBAAkB,CAACc,IAAnB,CAAwBD,IAAxB,CAAJ,EAAmC;UAC/B,IAAIJ,OAAO,IAAIA,OAAO,CAACM,UAAR,CAAmB,WAAnB,MAAoC,UAAnD,EAA+D;YAC3DN,OAAO,CAACO,QAAR,CAAiBC,IAAjB,CAAsBJ,IAAtB;UACH;QACJ,CAJD,MAIO;UACHJ,OAAO,CAACO,QAAR,CAAiBC,IAAjB,CAAsB,KAAKC,uBAAL,CAA6BL,IAA7B,CAAtB;QACH;MACJ,CARD,CAb8C,CAuB9C;MACA;;;MACAN,MAAM,CAACY,cAAP,GAAwBC,IAAI,IAAI;QAC5B,MAAMC,KAAK,GAAG;UAAEC,IAAI,EAAEF,IAAI,CAACE,IAAb;UAAmBP,UAAU,EAAE,EAA/B;UAAmCC,QAAQ,EAAE;QAA7C,CAAd;;QACA,IAAIP,OAAJ,EAAa;UACTA,OAAO,CAACO,QAAR,CAAiBC,IAAjB,CAAsBI,KAAtB;QACH,CAFD,MAEO;UACHb,MAAM,GAAGa,KAAT;QACH;;QAEDX,KAAK,CAACO,IAAN,CAAWI,KAAX;QACAZ,OAAO,GAAGY,KAAV;MACH,CAVD,CAzB8C,CAqC9C;;;MACAd,MAAM,CAACgB,UAAP,GAAoBH,IAAI,IAAI;QACxBV,KAAK,CAACc,GAAN;QACAf,OAAO,GAAGC,KAAK,CAACA,KAAK,CAACe,MAAN,GAAe,CAAhB,CAAf;MACH,CAHD,CAtC8C,CA2C9C;;;MACAlB,MAAM,CAACmB,WAAP,GAAqBC,SAAS,IAAI;QAC9BlB,OAAO,CAACM,UAAR,CAAmBY,SAAS,CAACL,IAA7B,IAAqC,KAAKJ,uBAAL,CAA6BS,SAAS,CAACC,KAAvC,CAArC;MACH,CAFD,CA5C8C,CAgD9C;;;MACArB,MAAM,CAACsB,KAAP,GAAe,MAAMxB,OAAO,CAACG,MAAD,CAA5B,CAjD8C,CAmD9C;;;MACAD,MAAM,CAACuB,KAAP,CAAa3B,OAAb,EAAsB4B,KAAtB;IACH,CArDM,CAAP;EAsDH;EAED;AACJ;AACA;AACA;AACA;AACA;;;EACIb,uBAAuB,CAACc,GAAD,EAAM;IACzB,MAAMC,GAAG,GAAGC,MAAM,CAACF,GAAD,CAAlB;IACA,OAAOC,GAAG,CAACE,QAAJ,OAAmBH,GAAnB,GAAyBC,GAAzB,GAA+BD,GAAtC;EACH;;AAxEW;;AA2EhBI,MAAM,CAACC,OAAP,GAAiBpC,SAAjB"},"metadata":{},"sourceType":"script"}