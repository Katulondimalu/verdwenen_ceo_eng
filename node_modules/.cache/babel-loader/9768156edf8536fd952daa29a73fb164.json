{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\n/**\n * XML query methods.\n * @private\n */\n\n\nmodule.exports = {\n  /**\n   * Append a child to the node.\n   * @param {{}} node - The parent node.\n   * @param {{}} child - The child node.\n   * @returns {undefined}\n   */\n  appendChild(node, child) {\n    if (!node.children) node.children = [];\n    node.children.push(child);\n  },\n\n  /**\n   * Append a child if one with the given name is not found.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The child node name.\n   * @returns {{}} The child.\n   */\n  appendChildIfNotFound(node, name) {\n    let child = this.findChild(node, name);\n\n    if (!child) {\n      child = {\n        name,\n        attributes: {},\n        children: []\n      };\n      this.appendChild(node, child);\n    }\n\n    return child;\n  },\n\n  /**\n   * Find a child with the given name.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The name to find.\n   * @returns {undefined|{}} The child if found.\n   */\n  findChild(node, name) {\n    return _.find(node.children, {\n      name\n    });\n  },\n\n  /**\n   * Get an attribute from a child node.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The name of the child node.\n   * @param {string} attribute - The name of the attribute.\n   * @returns {undefined|*} The value of the attribute if found.\n   */\n  getChildAttribute(node, name, attribute) {\n    const child = this.findChild(node, name);\n    if (child) return child.attributes && child.attributes[attribute];\n  },\n\n  /**\n   * Returns a value indicating whether the node has a child with the given name.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The name of the child node.\n   * @returns {boolean} True if found, false otherwise.\n   */\n  hasChild(node, name) {\n    return _.some(node.children, {\n      name\n    });\n  },\n\n  /**\n   * Insert the child after the specified node.\n   * @param {{}} node - The parent node.\n   * @param {{}} child - The child node.\n   * @param {{}} after - The node to insert after.\n   * @returns {undefined}\n   */\n  insertAfter(node, child, after) {\n    if (!node.children) node.children = [];\n    const index = node.children.indexOf(after);\n    node.children.splice(index + 1, 0, child);\n  },\n\n  /**\n   * Insert the child before the specified node.\n   * @param {{}} node - The parent node.\n   * @param {{}} child - The child node.\n   * @param {{}} before - The node to insert before.\n   * @returns {undefined}\n   */\n  insertBefore(node, child, before) {\n    if (!node.children) node.children = [];\n    const index = node.children.indexOf(before);\n    node.children.splice(index, 0, child);\n  },\n\n  /**\n   * Insert a child node in the correct order.\n   * @param {{}} node - The parent node.\n   * @param {{}} child - The child node.\n   * @param {Array.<string>} nodeOrder - The order of the node names.\n   * @returns {undefined}\n   */\n  insertInOrder(node, child, nodeOrder) {\n    const childIndex = nodeOrder.indexOf(child.name);\n\n    if (node.children && childIndex >= 0) {\n      for (let i = childIndex + 1; i < nodeOrder.length; i++) {\n        const sibling = this.findChild(node, nodeOrder[i]);\n\n        if (sibling) {\n          this.insertBefore(node, child, sibling);\n          return;\n        }\n      }\n    }\n\n    this.appendChild(node, child);\n  },\n\n  /**\n   * Check if the node is empty (no attributes and no children).\n   * @param {{}} node - The node.\n   * @returns {boolean} True if empty, false otherwise.\n   */\n  isEmpty(node) {\n    return _.isEmpty(node.children) && _.isEmpty(node.attributes);\n  },\n\n  /**\n   * Remove a child node.\n   * @param {{}} node - The parent node.\n   * @param {string|{}} child - The child node or name of node.\n   * @returns {undefined}\n   */\n  removeChild(node, child) {\n    if (!node.children) return;\n\n    if (typeof child === 'string') {\n      _.remove(node.children, {\n        name: child\n      });\n    } else {\n      const index = node.children.indexOf(child);\n      if (index >= 0) node.children.splice(index, 1);\n    }\n  },\n\n  /**\n   * Set/unset the attributes on the node.\n   * @param {{}} node - The node.\n   * @param {{}} attributes - The attributes to set.\n   * @returns {undefined}\n   */\n  setAttributes(node, attributes) {\n    _.forOwn(attributes, (value, attribute) => {\n      if (_.isNil(value)) {\n        if (node.attributes) delete node.attributes[attribute];\n      } else {\n        if (!node.attributes) node.attributes = {};\n        node.attributes[attribute] = value;\n      }\n    });\n  },\n\n  /**\n   * Set attributes on a child node, creating the child if necessary.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The name of the child node.\n   * @param {{}} attributes - The attributes to set.\n   * @returns {{}} The child.\n   */\n  setChildAttributes(node, name, attributes) {\n    let child = this.findChild(node, name);\n\n    _.forOwn(attributes, (value, attribute) => {\n      if (_.isNil(value)) {\n        if (child && child.attributes) delete child.attributes[attribute];\n      } else {\n        if (!child) {\n          child = {\n            name,\n            attributes: {},\n            children: []\n          };\n          this.appendChild(node, child);\n        }\n\n        if (!child.attributes) child.attributes = {};\n        child.attributes[attribute] = value;\n      }\n    });\n\n    return child;\n  },\n\n  /**\n   * Remove the child node if empty.\n   * @param {{}} node - The parent node.\n   * @param {string|{}} child - The child or name of child node.\n   * @returns {undefined}\n   */\n  removeChildIfEmpty(node, child) {\n    if (typeof child === 'string') child = this.findChild(node, child);\n    if (child && this.isEmpty(child)) this.removeChild(node, child);\n  }\n\n};","map":{"version":3,"names":["_","require","module","exports","appendChild","node","child","children","push","appendChildIfNotFound","name","findChild","attributes","find","getChildAttribute","attribute","hasChild","some","insertAfter","after","index","indexOf","splice","insertBefore","before","insertInOrder","nodeOrder","childIndex","i","length","sibling","isEmpty","removeChild","remove","setAttributes","forOwn","value","isNil","setChildAttributes","removeChildIfEmpty"],"sources":["/Users/stichtinghelden/Documents/GitHub/patient_0_eng/patient0eng/node_modules/xlsx-populate/lib/xmlq.js"],"sourcesContent":["\"use strict\";\n\nconst _ = require(\"lodash\");\n\n/**\n * XML query methods.\n * @private\n */\nmodule.exports = {\n    /**\n     * Append a child to the node.\n     * @param {{}} node - The parent node.\n     * @param {{}} child - The child node.\n     * @returns {undefined}\n     */\n    appendChild(node, child) {\n        if (!node.children) node.children = [];\n        node.children.push(child);\n    },\n\n    /**\n     * Append a child if one with the given name is not found.\n     * @param {{}} node - The parent node.\n     * @param {string} name - The child node name.\n     * @returns {{}} The child.\n     */\n    appendChildIfNotFound(node, name) {\n        let child = this.findChild(node, name);\n        if (!child) {\n            child = { name, attributes: {}, children: [] };\n            this.appendChild(node, child);\n        }\n\n        return child;\n    },\n\n    /**\n     * Find a child with the given name.\n     * @param {{}} node - The parent node.\n     * @param {string} name - The name to find.\n     * @returns {undefined|{}} The child if found.\n     */\n    findChild(node, name) {\n        return _.find(node.children, { name });\n    },\n\n    /**\n     * Get an attribute from a child node.\n     * @param {{}} node - The parent node.\n     * @param {string} name - The name of the child node.\n     * @param {string} attribute - The name of the attribute.\n     * @returns {undefined|*} The value of the attribute if found.\n     */\n    getChildAttribute(node, name, attribute) {\n        const child = this.findChild(node, name);\n        if (child) return child.attributes && child.attributes[attribute];\n    },\n\n    /**\n     * Returns a value indicating whether the node has a child with the given name.\n     * @param {{}} node - The parent node.\n     * @param {string} name - The name of the child node.\n     * @returns {boolean} True if found, false otherwise.\n     */\n    hasChild(node, name) {\n        return _.some(node.children, { name });\n    },\n\n    /**\n     * Insert the child after the specified node.\n     * @param {{}} node - The parent node.\n     * @param {{}} child - The child node.\n     * @param {{}} after - The node to insert after.\n     * @returns {undefined}\n     */\n    insertAfter(node, child, after) {\n        if (!node.children) node.children = [];\n        const index = node.children.indexOf(after);\n        node.children.splice(index + 1, 0, child);\n    },\n\n    /**\n     * Insert the child before the specified node.\n     * @param {{}} node - The parent node.\n     * @param {{}} child - The child node.\n     * @param {{}} before - The node to insert before.\n     * @returns {undefined}\n     */\n    insertBefore(node, child, before) {\n        if (!node.children) node.children = [];\n        const index = node.children.indexOf(before);\n        node.children.splice(index, 0, child);\n    },\n\n    /**\n     * Insert a child node in the correct order.\n     * @param {{}} node - The parent node.\n     * @param {{}} child - The child node.\n     * @param {Array.<string>} nodeOrder - The order of the node names.\n     * @returns {undefined}\n     */\n    insertInOrder(node, child, nodeOrder) {\n        const childIndex = nodeOrder.indexOf(child.name);\n        if (node.children && childIndex >= 0) {\n            for (let i = childIndex + 1; i < nodeOrder.length; i++) {\n                const sibling = this.findChild(node, nodeOrder[i]);\n                if (sibling) {\n                    this.insertBefore(node, child, sibling);\n                    return;\n                }\n            }\n        }\n\n        this.appendChild(node, child);\n    },\n\n    /**\n     * Check if the node is empty (no attributes and no children).\n     * @param {{}} node - The node.\n     * @returns {boolean} True if empty, false otherwise.\n     */\n    isEmpty(node) {\n        return _.isEmpty(node.children) && _.isEmpty(node.attributes);\n    },\n\n    /**\n     * Remove a child node.\n     * @param {{}} node - The parent node.\n     * @param {string|{}} child - The child node or name of node.\n     * @returns {undefined}\n     */\n    removeChild(node, child) {\n        if (!node.children) return;\n        if (typeof child === 'string') {\n            _.remove(node.children, { name: child });\n        } else {\n            const index = node.children.indexOf(child);\n            if (index >= 0) node.children.splice(index, 1);\n        }\n    },\n\n    /**\n     * Set/unset the attributes on the node.\n     * @param {{}} node - The node.\n     * @param {{}} attributes - The attributes to set.\n     * @returns {undefined}\n     */\n    setAttributes(node, attributes) {\n        _.forOwn(attributes, (value, attribute) => {\n            if (_.isNil(value)) {\n                if (node.attributes) delete node.attributes[attribute];\n            } else {\n                if (!node.attributes) node.attributes = {};\n                node.attributes[attribute] = value;\n            }\n        });\n    },\n\n    /**\n     * Set attributes on a child node, creating the child if necessary.\n     * @param {{}} node - The parent node.\n     * @param {string} name - The name of the child node.\n     * @param {{}} attributes - The attributes to set.\n     * @returns {{}} The child.\n     */\n    setChildAttributes(node, name, attributes) {\n        let child = this.findChild(node, name);\n        _.forOwn(attributes, (value, attribute) => {\n            if (_.isNil(value)) {\n                if (child && child.attributes) delete child.attributes[attribute];\n            } else {\n                if (!child) {\n                    child = { name, attributes: {}, children: [] };\n                    this.appendChild(node, child);\n                }\n\n                if (!child.attributes) child.attributes = {};\n                child.attributes[attribute] = value;\n            }\n        });\n\n        return child;\n    },\n\n    /**\n     * Remove the child node if empty.\n     * @param {{}} node - The parent node.\n     * @param {string|{}} child - The child or name of child node.\n     * @returns {undefined}\n     */\n    removeChildIfEmpty(node, child) {\n        if (typeof child === 'string') child = this.findChild(node, child);\n        if (child && this.isEmpty(child)) this.removeChild(node, child);\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}