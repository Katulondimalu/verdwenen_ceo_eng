{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.common {*/\n\nvar Binarizer_1 = require(\"../Binarizer\");\n\nvar BitArray_1 = require(\"./BitArray\");\n\nvar BitMatrix_1 = require(\"./BitMatrix\");\n\nvar NotFoundException_1 = require(\"../NotFoundException\");\n/**\n * This Binarizer implementation uses the old ZXing global histogram approach. It is suitable\n * for low-end mobile devices which don't have enough CPU or memory to use a local thresholding\n * algorithm. However, because it picks a global black point, it cannot handle difficult shadows\n * and gradients.\n *\n * Faster mobile devices and all desktop applications should probably use HybridBinarizer instead.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n */\n\n\nvar GlobalHistogramBinarizer =\n/** @class */\nfunction (_super) {\n  __extends(GlobalHistogramBinarizer, _super);\n\n  function GlobalHistogramBinarizer(source) {\n    var _this = _super.call(this, source) || this;\n\n    _this.luminances = GlobalHistogramBinarizer.EMPTY;\n    _this.buckets = new Int32Array(GlobalHistogramBinarizer.LUMINANCE_BUCKETS);\n    return _this;\n  } // Applies simple sharpening to the row data to improve performance of the 1D Readers.\n\n  /*@Override*/\n\n\n  GlobalHistogramBinarizer.prototype.getBlackRow = function (y\n  /*int*/\n  , row) {\n    var source = this.getLuminanceSource();\n    var width = source.getWidth();\n\n    if (row === undefined || row === null || row.getSize() < width) {\n      row = new BitArray_1.default(width);\n    } else {\n      row.clear();\n    }\n\n    this.initArrays(width);\n    var localLuminances = source.getRow(y, this.luminances);\n    var localBuckets = this.buckets;\n\n    for (var x = 0; x < width; x++) {\n      localBuckets[(localLuminances[x] & 0xff) >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;\n    }\n\n    var blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);\n\n    if (width < 3) {\n      // Special case for very small images\n      for (var x = 0; x < width; x++) {\n        if ((localLuminances[x] & 0xff) < blackPoint) {\n          row.set(x);\n        }\n      }\n    } else {\n      var left = localLuminances[0] & 0xff;\n      var center = localLuminances[1] & 0xff;\n\n      for (var x = 1; x < width - 1; x++) {\n        var right = localLuminances[x + 1] & 0xff; // A simple -1 4 -1 box filter with a weight of 2.\n\n        if ((center * 4 - left - right) / 2 < blackPoint) {\n          row.set(x);\n        }\n\n        left = center;\n        center = right;\n      }\n    }\n\n    return row;\n  }; // Does not sharpen the data, as this call is intended to only be used by 2D Readers.\n\n  /*@Override*/\n\n\n  GlobalHistogramBinarizer.prototype.getBlackMatrix = function () {\n    var source = this.getLuminanceSource();\n    var width = source.getWidth();\n    var height = source.getHeight();\n    var matrix = new BitMatrix_1.default(width, height); // Quickly calculates the histogram by sampling four rows from the image. This proved to be\n    // more robust on the blackbox tests than sampling a diagonal as we used to do.\n\n    this.initArrays(width);\n    var localBuckets = this.buckets;\n\n    for (var y = 1; y < 5; y++) {\n      var row = Math.floor(height * y / 5);\n      var localLuminances_1 = source.getRow(row, this.luminances);\n      var right = Math.floor(width * 4 / 5);\n\n      for (var x = Math.floor(width / 5); x < right; x++) {\n        var pixel = localLuminances_1[x] & 0xff;\n        localBuckets[pixel >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;\n      }\n    }\n\n    var blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets); // We delay reading the entire image luminance until the black point estimation succeeds.\n    // Although we end up reading four rows twice, it is consistent with our motto of\n    // \"fail quickly\" which is necessary for continuous scanning.\n\n    var localLuminances = source.getMatrix();\n\n    for (var y = 0; y < height; y++) {\n      var offset = y * width;\n\n      for (var x = 0; x < width; x++) {\n        var pixel = localLuminances[offset + x] & 0xff;\n\n        if (pixel < blackPoint) {\n          matrix.set(x, y);\n        }\n      }\n    }\n\n    return matrix;\n  };\n  /*@Override*/\n\n\n  GlobalHistogramBinarizer.prototype.createBinarizer = function (source) {\n    return new GlobalHistogramBinarizer(source);\n  };\n\n  GlobalHistogramBinarizer.prototype.initArrays = function (luminanceSize\n  /*int*/\n  ) {\n    if (this.luminances.length < luminanceSize) {\n      this.luminances = new Uint8ClampedArray(luminanceSize);\n    }\n\n    var buckets = this.buckets;\n\n    for (var x = 0; x < GlobalHistogramBinarizer.LUMINANCE_BUCKETS; x++) {\n      buckets[x] = 0;\n    }\n  };\n\n  GlobalHistogramBinarizer.estimateBlackPoint = function (buckets) {\n    // Find the tallest peak in the histogram.\n    var numBuckets = buckets.length;\n    var maxBucketCount = 0;\n    var firstPeak = 0;\n    var firstPeakSize = 0;\n\n    for (var x = 0; x < numBuckets; x++) {\n      if (buckets[x] > firstPeakSize) {\n        firstPeak = x;\n        firstPeakSize = buckets[x];\n      }\n\n      if (buckets[x] > maxBucketCount) {\n        maxBucketCount = buckets[x];\n      }\n    } // Find the second-tallest peak which is somewhat far from the tallest peak.\n\n\n    var secondPeak = 0;\n    var secondPeakScore = 0;\n\n    for (var x = 0; x < numBuckets; x++) {\n      var distanceToBiggest = x - firstPeak; // Encourage more distant second peaks by multiplying by square of distance.\n\n      var score = buckets[x] * distanceToBiggest * distanceToBiggest;\n\n      if (score > secondPeakScore) {\n        secondPeak = x;\n        secondPeakScore = score;\n      }\n    } // Make sure firstPeak corresponds to the black peak.\n\n\n    if (firstPeak > secondPeak) {\n      var temp = firstPeak;\n      firstPeak = secondPeak;\n      secondPeak = temp;\n    } // If there is too little contrast in the image to pick a meaningful black point, throw rather\n    // than waste time trying to decode the image, and risk false positives.\n\n\n    if (secondPeak - firstPeak <= numBuckets / 16) {\n      throw new NotFoundException_1.default();\n    } // Find a valley between them that is low and closer to the white peak.\n\n\n    var bestValley = secondPeak - 1;\n    var bestValleyScore = -1;\n\n    for (var x = secondPeak - 1; x > firstPeak; x--) {\n      var fromFirst = x - firstPeak;\n      var score = fromFirst * fromFirst * (secondPeak - x) * (maxBucketCount - buckets[x]);\n\n      if (score > bestValleyScore) {\n        bestValley = x;\n        bestValleyScore = score;\n      }\n    }\n\n    return bestValley << GlobalHistogramBinarizer.LUMINANCE_SHIFT;\n  };\n\n  GlobalHistogramBinarizer.LUMINANCE_BITS = 5;\n  GlobalHistogramBinarizer.LUMINANCE_SHIFT = 8 - GlobalHistogramBinarizer.LUMINANCE_BITS;\n  GlobalHistogramBinarizer.LUMINANCE_BUCKETS = 1 << GlobalHistogramBinarizer.LUMINANCE_BITS;\n  GlobalHistogramBinarizer.EMPTY = Uint8ClampedArray.from([0]);\n  return GlobalHistogramBinarizer;\n}(Binarizer_1.default);\n\nexports.default = GlobalHistogramBinarizer;","map":{"version":3,"sources":["../../../src/core/common/GlobalHistogramBinarizer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.common {*/\nvar Binarizer_1 = require(\"../Binarizer\");\nvar BitArray_1 = require(\"./BitArray\");\nvar BitMatrix_1 = require(\"./BitMatrix\");\nvar NotFoundException_1 = require(\"../NotFoundException\");\n/**\n * This Binarizer implementation uses the old ZXing global histogram approach. It is suitable\n * for low-end mobile devices which don't have enough CPU or memory to use a local thresholding\n * algorithm. However, because it picks a global black point, it cannot handle difficult shadows\n * and gradients.\n *\n * Faster mobile devices and all desktop applications should probably use HybridBinarizer instead.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n */\nvar GlobalHistogramBinarizer = /** @class */ (function (_super) {\n    __extends(GlobalHistogramBinarizer, _super);\n    function GlobalHistogramBinarizer(source) {\n        var _this = _super.call(this, source) || this;\n        _this.luminances = GlobalHistogramBinarizer.EMPTY;\n        _this.buckets = new Int32Array(GlobalHistogramBinarizer.LUMINANCE_BUCKETS);\n        return _this;\n    }\n    // Applies simple sharpening to the row data to improve performance of the 1D Readers.\n    /*@Override*/\n    GlobalHistogramBinarizer.prototype.getBlackRow = function (y /*int*/, row) {\n        var source = this.getLuminanceSource();\n        var width = source.getWidth();\n        if (row === undefined || row === null || row.getSize() < width) {\n            row = new BitArray_1.default(width);\n        }\n        else {\n            row.clear();\n        }\n        this.initArrays(width);\n        var localLuminances = source.getRow(y, this.luminances);\n        var localBuckets = this.buckets;\n        for (var x = 0; x < width; x++) {\n            localBuckets[(localLuminances[x] & 0xff) >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;\n        }\n        var blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);\n        if (width < 3) {\n            // Special case for very small images\n            for (var x = 0; x < width; x++) {\n                if ((localLuminances[x] & 0xff) < blackPoint) {\n                    row.set(x);\n                }\n            }\n        }\n        else {\n            var left = localLuminances[0] & 0xff;\n            var center = localLuminances[1] & 0xff;\n            for (var x = 1; x < width - 1; x++) {\n                var right = localLuminances[x + 1] & 0xff;\n                // A simple -1 4 -1 box filter with a weight of 2.\n                if (((center * 4) - left - right) / 2 < blackPoint) {\n                    row.set(x);\n                }\n                left = center;\n                center = right;\n            }\n        }\n        return row;\n    };\n    // Does not sharpen the data, as this call is intended to only be used by 2D Readers.\n    /*@Override*/\n    GlobalHistogramBinarizer.prototype.getBlackMatrix = function () {\n        var source = this.getLuminanceSource();\n        var width = source.getWidth();\n        var height = source.getHeight();\n        var matrix = new BitMatrix_1.default(width, height);\n        // Quickly calculates the histogram by sampling four rows from the image. This proved to be\n        // more robust on the blackbox tests than sampling a diagonal as we used to do.\n        this.initArrays(width);\n        var localBuckets = this.buckets;\n        for (var y = 1; y < 5; y++) {\n            var row = Math.floor((height * y) / 5);\n            var localLuminances_1 = source.getRow(row, this.luminances);\n            var right = Math.floor((width * 4) / 5);\n            for (var x = Math.floor(width / 5); x < right; x++) {\n                var pixel = localLuminances_1[x] & 0xff;\n                localBuckets[pixel >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;\n            }\n        }\n        var blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);\n        // We delay reading the entire image luminance until the black point estimation succeeds.\n        // Although we end up reading four rows twice, it is consistent with our motto of\n        // \"fail quickly\" which is necessary for continuous scanning.\n        var localLuminances = source.getMatrix();\n        for (var y = 0; y < height; y++) {\n            var offset = y * width;\n            for (var x = 0; x < width; x++) {\n                var pixel = localLuminances[offset + x] & 0xff;\n                if (pixel < blackPoint) {\n                    matrix.set(x, y);\n                }\n            }\n        }\n        return matrix;\n    };\n    /*@Override*/\n    GlobalHistogramBinarizer.prototype.createBinarizer = function (source) {\n        return new GlobalHistogramBinarizer(source);\n    };\n    GlobalHistogramBinarizer.prototype.initArrays = function (luminanceSize /*int*/) {\n        if (this.luminances.length < luminanceSize) {\n            this.luminances = new Uint8ClampedArray(luminanceSize);\n        }\n        var buckets = this.buckets;\n        for (var x = 0; x < GlobalHistogramBinarizer.LUMINANCE_BUCKETS; x++) {\n            buckets[x] = 0;\n        }\n    };\n    GlobalHistogramBinarizer.estimateBlackPoint = function (buckets) {\n        // Find the tallest peak in the histogram.\n        var numBuckets = buckets.length;\n        var maxBucketCount = 0;\n        var firstPeak = 0;\n        var firstPeakSize = 0;\n        for (var x = 0; x < numBuckets; x++) {\n            if (buckets[x] > firstPeakSize) {\n                firstPeak = x;\n                firstPeakSize = buckets[x];\n            }\n            if (buckets[x] > maxBucketCount) {\n                maxBucketCount = buckets[x];\n            }\n        }\n        // Find the second-tallest peak which is somewhat far from the tallest peak.\n        var secondPeak = 0;\n        var secondPeakScore = 0;\n        for (var x = 0; x < numBuckets; x++) {\n            var distanceToBiggest = x - firstPeak;\n            // Encourage more distant second peaks by multiplying by square of distance.\n            var score = buckets[x] * distanceToBiggest * distanceToBiggest;\n            if (score > secondPeakScore) {\n                secondPeak = x;\n                secondPeakScore = score;\n            }\n        }\n        // Make sure firstPeak corresponds to the black peak.\n        if (firstPeak > secondPeak) {\n            var temp = firstPeak;\n            firstPeak = secondPeak;\n            secondPeak = temp;\n        }\n        // If there is too little contrast in the image to pick a meaningful black point, throw rather\n        // than waste time trying to decode the image, and risk false positives.\n        if (secondPeak - firstPeak <= numBuckets / 16) {\n            throw new NotFoundException_1.default();\n        }\n        // Find a valley between them that is low and closer to the white peak.\n        var bestValley = secondPeak - 1;\n        var bestValleyScore = -1;\n        for (var x = secondPeak - 1; x > firstPeak; x--) {\n            var fromFirst = x - firstPeak;\n            var score = fromFirst * fromFirst * (secondPeak - x) * (maxBucketCount - buckets[x]);\n            if (score > bestValleyScore) {\n                bestValley = x;\n                bestValleyScore = score;\n            }\n        }\n        return bestValley << GlobalHistogramBinarizer.LUMINANCE_SHIFT;\n    };\n    GlobalHistogramBinarizer.LUMINANCE_BITS = 5;\n    GlobalHistogramBinarizer.LUMINANCE_SHIFT = 8 - GlobalHistogramBinarizer.LUMINANCE_BITS;\n    GlobalHistogramBinarizer.LUMINANCE_BUCKETS = 1 << GlobalHistogramBinarizer.LUMINANCE_BITS;\n    GlobalHistogramBinarizer.EMPTY = Uint8ClampedArray.from([0]);\n    return GlobalHistogramBinarizer;\n}(Binarizer_1.default));\nexports.default = GlobalHistogramBinarizer;\n//# sourceMappingURL=GlobalHistogramBinarizer.js.map"]},"metadata":{},"sourceType":"script"}