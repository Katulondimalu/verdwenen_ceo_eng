{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.common {*/\n\n/*import java.util.Arrays;*/\n\nvar System_1 = require(\"../util/System\");\n\nvar Integer_1 = require(\"../util/Integer\");\n\nvar Arrays_1 = require(\"../util/Arrays\");\n\nvar IllegalArgumentException_1 = require(\"../IllegalArgumentException\");\n/**\n * <p>A simple, fast array of bits, represented compactly by an array of ints internally.</p>\n *\n * @author Sean Owen\n */\n\n\nvar BitArray\n/*implements Cloneable*/\n=\n/** @class */\nfunction () {\n  // public constructor() {\n  //   this.size = 0\n  //   this.bits = new Int32Array(1)\n  // }\n  // public constructor(size?: number /*int*/) {\n  //   if (undefined === size) {\n  //     this.size = 0\n  //   } else {\n  //     this.size = size\n  //   }\n  //   this.bits = this.makeArray(size)\n  // }\n  // For testing only\n  function BitArray(size\n  /*int*/\n  , bits) {\n    if (undefined === size) {\n      this.size = 0;\n      this.bits = new Int32Array(1);\n    } else {\n      this.size = size;\n\n      if (undefined === bits || null === bits) {\n        this.bits = BitArray.makeArray(size);\n      } else {\n        this.bits = bits;\n      }\n    }\n  }\n\n  BitArray.prototype.getSize = function () {\n    return this.size;\n  };\n\n  BitArray.prototype.getSizeInBytes = function () {\n    return Math.floor((this.size + 7) / 8);\n  };\n\n  BitArray.prototype.ensureCapacity = function (size\n  /*int*/\n  ) {\n    if (size > this.bits.length * 32) {\n      var newBits = BitArray.makeArray(size);\n      System_1.default.arraycopy(this.bits, 0, newBits, 0, this.bits.length);\n      this.bits = newBits;\n    }\n  };\n  /**\n   * @param i bit to get\n   * @return true iff bit i is set\n   */\n\n\n  BitArray.prototype.get = function (i\n  /*int*/\n  ) {\n    return (this.bits[Math.floor(i / 32)] & 1 << (i & 0x1F)) !== 0;\n  };\n  /**\n   * Sets bit i.\n   *\n   * @param i bit to set\n   */\n\n\n  BitArray.prototype.set = function (i\n  /*int*/\n  ) {\n    this.bits[Math.floor(i / 32)] |= 1 << (i & 0x1F);\n  };\n  /**\n   * Flips bit i.\n   *\n   * @param i bit to set\n   */\n\n\n  BitArray.prototype.flip = function (i\n  /*int*/\n  ) {\n    this.bits[Math.floor(i / 32)] ^= 1 << (i & 0x1F);\n  };\n  /**\n   * @param from first bit to check\n   * @return index of first bit that is set, starting from the given index, or size if none are set\n   *  at or beyond this given index\n   * @see #getNextUnset(int)\n   */\n\n\n  BitArray.prototype.getNextSet = function (from\n  /*int*/\n  ) {\n    var size = this.size;\n\n    if (from >= size) {\n      return size;\n    }\n\n    var bits = this.bits;\n    var bitsOffset = Math.floor(from / 32);\n    var currentBits = bits[bitsOffset]; // mask off lesser bits first\n\n    currentBits &= ~((1 << (from & 0x1F)) - 1);\n    var length = bits.length;\n\n    while (currentBits === 0) {\n      if (++bitsOffset === length) {\n        return size;\n      }\n\n      currentBits = bits[bitsOffset];\n    }\n\n    var result = bitsOffset * 32 + Integer_1.default.numberOfTrailingZeros(currentBits);\n    return result > size ? size : result;\n  };\n  /**\n   * @param from index to start looking for unset bit\n   * @return index of next unset bit, or {@code size} if none are unset until the end\n   * @see #getNextSet(int)\n   */\n\n\n  BitArray.prototype.getNextUnset = function (from\n  /*int*/\n  ) {\n    var size = this.size;\n\n    if (from >= size) {\n      return size;\n    }\n\n    var bits = this.bits;\n    var bitsOffset = Math.floor(from / 32);\n    var currentBits = ~bits[bitsOffset]; // mask off lesser bits first\n\n    currentBits &= ~((1 << (from & 0x1F)) - 1);\n    var length = bits.length;\n\n    while (currentBits === 0) {\n      if (++bitsOffset === length) {\n        return size;\n      }\n\n      currentBits = ~bits[bitsOffset];\n    }\n\n    var result = bitsOffset * 32 + Integer_1.default.numberOfTrailingZeros(currentBits);\n    return result > size ? size : result;\n  };\n  /**\n   * Sets a block of 32 bits, starting at bit i.\n   *\n   * @param i first bit to set\n   * @param newBits the new value of the next 32 bits. Note again that the least-significant bit\n   * corresponds to bit i, the next-least-significant to i+1, and so on.\n   */\n\n\n  BitArray.prototype.setBulk = function (i\n  /*int*/\n  , newBits\n  /*int*/\n  ) {\n    this.bits[Math.floor(i / 32)] = newBits;\n  };\n  /**\n   * Sets a range of bits.\n   *\n   * @param start start of range, inclusive.\n   * @param end end of range, exclusive\n   */\n\n\n  BitArray.prototype.setRange = function (start\n  /*int*/\n  , end\n  /*int*/\n  ) {\n    if (end < start || start < 0 || end > this.size) {\n      throw new IllegalArgumentException_1.default();\n    }\n\n    if (end === start) {\n      return;\n    }\n\n    end--; // will be easier to treat this as the last actually set bit -- inclusive\n\n    var firstInt = Math.floor(start / 32);\n    var lastInt = Math.floor(end / 32);\n    var bits = this.bits;\n\n    for (var i = firstInt; i <= lastInt; i++) {\n      var firstBit = i > firstInt ? 0 : start & 0x1F;\n      var lastBit = i < lastInt ? 31 : end & 0x1F; // Ones from firstBit to lastBit, inclusive\n\n      var mask = (2 << lastBit) - (1 << firstBit);\n      bits[i] |= mask;\n    }\n  };\n  /**\n   * Clears all bits (sets to false).\n   */\n\n\n  BitArray.prototype.clear = function () {\n    var max = this.bits.length;\n    var bits = this.bits;\n\n    for (var i = 0; i < max; i++) {\n      bits[i] = 0;\n    }\n  };\n  /**\n   * Efficient method to check if a range of bits is set, or not set.\n   *\n   * @param start start of range, inclusive.\n   * @param end end of range, exclusive\n   * @param value if true, checks that bits in range are set, otherwise checks that they are not set\n   * @return true iff all bits are set or not set in range, according to value argument\n   * @throws IllegalArgumentException if end is less than start or the range is not contained in the array\n   */\n\n\n  BitArray.prototype.isRange = function (start\n  /*int*/\n  , end\n  /*int*/\n  , value) {\n    if (end < start || start < 0 || end > this.size) {\n      throw new IllegalArgumentException_1.default();\n    }\n\n    if (end === start) {\n      return true; // empty range matches\n    }\n\n    end--; // will be easier to treat this as the last actually set bit -- inclusive\n\n    var firstInt = Math.floor(start / 32);\n    var lastInt = Math.floor(end / 32);\n    var bits = this.bits;\n\n    for (var i = firstInt; i <= lastInt; i++) {\n      var firstBit = i > firstInt ? 0 : start & 0x1F;\n      var lastBit = i < lastInt ? 31 : end & 0x1F; // Ones from firstBit to lastBit, inclusive\n\n      var mask = (2 << lastBit) - (1 << firstBit) & 0xFFFFFFFF; // TYPESCRIPTPORT: & 0xFFFFFFFF added to discard anything after 32 bits, as ES has 53 bits\n      // Return false if we're looking for 1s and the masked bits[i] isn't all 1s (is: that,\n      // equals the mask, or we're looking for 0s and the masked portion is not all 0s\n\n      if ((bits[i] & mask) !== (value ? mask : 0)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  BitArray.prototype.appendBit = function (bit) {\n    this.ensureCapacity(this.size + 1);\n\n    if (bit) {\n      this.bits[Math.floor(this.size / 32)] |= 1 << (this.size & 0x1F);\n    }\n\n    this.size++;\n  };\n  /**\n   * Appends the least-significant bits, from value, in order from most-significant to\n   * least-significant. For example, appending 6 bits from 0x000001E will append the bits\n   * 0, 1, 1, 1, 1, 0 in that order.\n   *\n   * @param value {@code int} containing bits to append\n   * @param numBits bits from value to append\n   */\n\n\n  BitArray.prototype.appendBits = function (value\n  /*int*/\n  , numBits\n  /*int*/\n  ) {\n    if (numBits < 0 || numBits > 32) {\n      throw new IllegalArgumentException_1.default('Num bits must be between 0 and 32');\n    }\n\n    this.ensureCapacity(this.size + numBits);\n    var appendBit = this.appendBit;\n\n    for (var numBitsLeft = numBits; numBitsLeft > 0; numBitsLeft--) {\n      this.appendBit((value >> numBitsLeft - 1 & 0x01) === 1);\n    }\n  };\n\n  BitArray.prototype.appendBitArray = function (other) {\n    var otherSize = other.size;\n    this.ensureCapacity(this.size + otherSize);\n    var appendBit = this.appendBit;\n\n    for (var i = 0; i < otherSize; i++) {\n      this.appendBit(other.get(i));\n    }\n  };\n\n  BitArray.prototype.xor = function (other) {\n    if (this.size !== other.size) {\n      throw new IllegalArgumentException_1.default('Sizes don\\'t match');\n    }\n\n    var bits = this.bits;\n\n    for (var i = 0, length_1 = bits.length; i < length_1; i++) {\n      // The last int could be incomplete (i.e. not have 32 bits in\n      // it) but there is no problem since 0 XOR 0 == 0.\n      bits[i] ^= other.bits[i];\n    }\n  };\n  /**\n   *\n   * @param bitOffset first bit to start writing\n   * @param array array to write into. Bytes are written most-significant byte first. This is the opposite\n   *  of the internal representation, which is exposed by {@link #getBitArray()}\n   * @param offset position in array to start writing\n   * @param numBytes how many bytes to write\n   */\n\n\n  BitArray.prototype.toBytes = function (bitOffset\n  /*int*/\n  , array, offset\n  /*int*/\n  , numBytes\n  /*int*/\n  ) {\n    for (var i = 0; i < numBytes; i++) {\n      var theByte = 0;\n\n      for (var j = 0; j < 8; j++) {\n        if (this.get(bitOffset)) {\n          theByte |= 1 << 7 - j;\n        }\n\n        bitOffset++;\n      }\n\n      array[offset + i] =\n      /*(byte)*/\n      theByte;\n    }\n  };\n  /**\n   * @return underlying array of ints. The first element holds the first 32 bits, and the least\n   *         significant bit is bit 0.\n   */\n\n\n  BitArray.prototype.getBitArray = function () {\n    return this.bits;\n  };\n  /**\n   * Reverses all bits in the array.\n   */\n\n\n  BitArray.prototype.reverse = function () {\n    var newBits = new Int32Array(this.bits.length); // reverse all int's first\n\n    var len = Math.floor((this.size - 1) / 32);\n    var oldBitsLen = len + 1;\n    var bits = this.bits;\n\n    for (var i = 0; i < oldBitsLen; i++) {\n      var x = bits[i];\n      x = x >> 1 & 0x55555555 | (x & 0x55555555) << 1;\n      x = x >> 2 & 0x33333333 | (x & 0x33333333) << 2;\n      x = x >> 4 & 0x0f0f0f0f | (x & 0x0f0f0f0f) << 4;\n      x = x >> 8 & 0x00ff00ff | (x & 0x00ff00ff) << 8;\n      x = x >> 16 & 0x0000ffff | (x & 0x0000ffff) << 16;\n      newBits[len - i] =\n      /*(int)*/\n      x;\n    } // now correct the int's if the bit size isn't a multiple of 32\n\n\n    if (this.size !== oldBitsLen * 32) {\n      var leftOffset = oldBitsLen * 32 - this.size;\n      var currentInt = newBits[0] >>> leftOffset;\n\n      for (var i = 1; i < oldBitsLen; i++) {\n        var nextInt = newBits[i];\n        currentInt |= nextInt << 32 - leftOffset;\n        newBits[i - 1] = currentInt;\n        currentInt = nextInt >>> leftOffset;\n      }\n\n      newBits[oldBitsLen - 1] = currentInt;\n    }\n\n    this.bits = newBits;\n  };\n\n  BitArray.makeArray = function (size\n  /*int*/\n  ) {\n    return new Int32Array(Math.floor((size + 31) / 32));\n  };\n  /*@Override*/\n\n\n  BitArray.prototype.equals = function (o) {\n    if (!(o instanceof BitArray)) {\n      return false;\n    }\n\n    var other = o;\n    return this.size === other.size && Arrays_1.default.equals(this.bits, other.bits);\n  };\n  /*@Override*/\n\n\n  BitArray.prototype.hashCode = function () {\n    return 31 * this.size + Arrays_1.default.hashCode(this.bits);\n  };\n  /*@Override*/\n\n\n  BitArray.prototype.toString = function () {\n    var result = '';\n\n    for (var i = 0, size = this.size; i < size; i++) {\n      if ((i & 0x07) === 0) {\n        result += ' ';\n      }\n\n      result += this.get(i) ? 'X' : '.';\n    }\n\n    return result;\n  };\n  /*@Override*/\n\n\n  BitArray.prototype.clone = function () {\n    return new BitArray(this.size, this.bits.slice());\n  };\n\n  return BitArray;\n}();\n\nexports.default = BitArray;","map":{"version":3,"sources":["../../../src/core/common/BitArray.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.common {*/\n/*import java.util.Arrays;*/\nvar System_1 = require(\"../util/System\");\nvar Integer_1 = require(\"../util/Integer\");\nvar Arrays_1 = require(\"../util/Arrays\");\nvar IllegalArgumentException_1 = require(\"../IllegalArgumentException\");\n/**\n * <p>A simple, fast array of bits, represented compactly by an array of ints internally.</p>\n *\n * @author Sean Owen\n */\nvar BitArray /*implements Cloneable*/ = /** @class */ (function () {\n    // public constructor() {\n    //   this.size = 0\n    //   this.bits = new Int32Array(1)\n    // }\n    // public constructor(size?: number /*int*/) {\n    //   if (undefined === size) {\n    //     this.size = 0\n    //   } else {\n    //     this.size = size\n    //   }\n    //   this.bits = this.makeArray(size)\n    // }\n    // For testing only\n    function BitArray(size /*int*/, bits) {\n        if (undefined === size) {\n            this.size = 0;\n            this.bits = new Int32Array(1);\n        }\n        else {\n            this.size = size;\n            if (undefined === bits || null === bits) {\n                this.bits = BitArray.makeArray(size);\n            }\n            else {\n                this.bits = bits;\n            }\n        }\n    }\n    BitArray.prototype.getSize = function () {\n        return this.size;\n    };\n    BitArray.prototype.getSizeInBytes = function () {\n        return Math.floor((this.size + 7) / 8);\n    };\n    BitArray.prototype.ensureCapacity = function (size /*int*/) {\n        if (size > this.bits.length * 32) {\n            var newBits = BitArray.makeArray(size);\n            System_1.default.arraycopy(this.bits, 0, newBits, 0, this.bits.length);\n            this.bits = newBits;\n        }\n    };\n    /**\n     * @param i bit to get\n     * @return true iff bit i is set\n     */\n    BitArray.prototype.get = function (i /*int*/) {\n        return (this.bits[Math.floor(i / 32)] & (1 << (i & 0x1F))) !== 0;\n    };\n    /**\n     * Sets bit i.\n     *\n     * @param i bit to set\n     */\n    BitArray.prototype.set = function (i /*int*/) {\n        this.bits[Math.floor(i / 32)] |= 1 << (i & 0x1F);\n    };\n    /**\n     * Flips bit i.\n     *\n     * @param i bit to set\n     */\n    BitArray.prototype.flip = function (i /*int*/) {\n        this.bits[Math.floor(i / 32)] ^= 1 << (i & 0x1F);\n    };\n    /**\n     * @param from first bit to check\n     * @return index of first bit that is set, starting from the given index, or size if none are set\n     *  at or beyond this given index\n     * @see #getNextUnset(int)\n     */\n    BitArray.prototype.getNextSet = function (from /*int*/) {\n        var size = this.size;\n        if (from >= size) {\n            return size;\n        }\n        var bits = this.bits;\n        var bitsOffset = Math.floor(from / 32);\n        var currentBits = bits[bitsOffset];\n        // mask off lesser bits first\n        currentBits &= ~((1 << (from & 0x1F)) - 1);\n        var length = bits.length;\n        while (currentBits === 0) {\n            if (++bitsOffset === length) {\n                return size;\n            }\n            currentBits = bits[bitsOffset];\n        }\n        var result = (bitsOffset * 32) + Integer_1.default.numberOfTrailingZeros(currentBits);\n        return result > size ? size : result;\n    };\n    /**\n     * @param from index to start looking for unset bit\n     * @return index of next unset bit, or {@code size} if none are unset until the end\n     * @see #getNextSet(int)\n     */\n    BitArray.prototype.getNextUnset = function (from /*int*/) {\n        var size = this.size;\n        if (from >= size) {\n            return size;\n        }\n        var bits = this.bits;\n        var bitsOffset = Math.floor(from / 32);\n        var currentBits = ~bits[bitsOffset];\n        // mask off lesser bits first\n        currentBits &= ~((1 << (from & 0x1F)) - 1);\n        var length = bits.length;\n        while (currentBits === 0) {\n            if (++bitsOffset === length) {\n                return size;\n            }\n            currentBits = ~bits[bitsOffset];\n        }\n        var result = (bitsOffset * 32) + Integer_1.default.numberOfTrailingZeros(currentBits);\n        return result > size ? size : result;\n    };\n    /**\n     * Sets a block of 32 bits, starting at bit i.\n     *\n     * @param i first bit to set\n     * @param newBits the new value of the next 32 bits. Note again that the least-significant bit\n     * corresponds to bit i, the next-least-significant to i+1, and so on.\n     */\n    BitArray.prototype.setBulk = function (i /*int*/, newBits /*int*/) {\n        this.bits[Math.floor(i / 32)] = newBits;\n    };\n    /**\n     * Sets a range of bits.\n     *\n     * @param start start of range, inclusive.\n     * @param end end of range, exclusive\n     */\n    BitArray.prototype.setRange = function (start /*int*/, end /*int*/) {\n        if (end < start || start < 0 || end > this.size) {\n            throw new IllegalArgumentException_1.default();\n        }\n        if (end === start) {\n            return;\n        }\n        end--; // will be easier to treat this as the last actually set bit -- inclusive\n        var firstInt = Math.floor(start / 32);\n        var lastInt = Math.floor(end / 32);\n        var bits = this.bits;\n        for (var i = firstInt; i <= lastInt; i++) {\n            var firstBit = i > firstInt ? 0 : start & 0x1F;\n            var lastBit = i < lastInt ? 31 : end & 0x1F;\n            // Ones from firstBit to lastBit, inclusive\n            var mask = (2 << lastBit) - (1 << firstBit);\n            bits[i] |= mask;\n        }\n    };\n    /**\n     * Clears all bits (sets to false).\n     */\n    BitArray.prototype.clear = function () {\n        var max = this.bits.length;\n        var bits = this.bits;\n        for (var i = 0; i < max; i++) {\n            bits[i] = 0;\n        }\n    };\n    /**\n     * Efficient method to check if a range of bits is set, or not set.\n     *\n     * @param start start of range, inclusive.\n     * @param end end of range, exclusive\n     * @param value if true, checks that bits in range are set, otherwise checks that they are not set\n     * @return true iff all bits are set or not set in range, according to value argument\n     * @throws IllegalArgumentException if end is less than start or the range is not contained in the array\n     */\n    BitArray.prototype.isRange = function (start /*int*/, end /*int*/, value) {\n        if (end < start || start < 0 || end > this.size) {\n            throw new IllegalArgumentException_1.default();\n        }\n        if (end === start) {\n            return true; // empty range matches\n        }\n        end--; // will be easier to treat this as the last actually set bit -- inclusive\n        var firstInt = Math.floor(start / 32);\n        var lastInt = Math.floor(end / 32);\n        var bits = this.bits;\n        for (var i = firstInt; i <= lastInt; i++) {\n            var firstBit = i > firstInt ? 0 : start & 0x1F;\n            var lastBit = i < lastInt ? 31 : end & 0x1F;\n            // Ones from firstBit to lastBit, inclusive\n            var mask = (2 << lastBit) - (1 << firstBit) & 0xFFFFFFFF;\n            // TYPESCRIPTPORT: & 0xFFFFFFFF added to discard anything after 32 bits, as ES has 53 bits\n            // Return false if we're looking for 1s and the masked bits[i] isn't all 1s (is: that,\n            // equals the mask, or we're looking for 0s and the masked portion is not all 0s\n            if ((bits[i] & mask) !== (value ? mask : 0)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    BitArray.prototype.appendBit = function (bit) {\n        this.ensureCapacity(this.size + 1);\n        if (bit) {\n            this.bits[Math.floor(this.size / 32)] |= 1 << (this.size & 0x1F);\n        }\n        this.size++;\n    };\n    /**\n     * Appends the least-significant bits, from value, in order from most-significant to\n     * least-significant. For example, appending 6 bits from 0x000001E will append the bits\n     * 0, 1, 1, 1, 1, 0 in that order.\n     *\n     * @param value {@code int} containing bits to append\n     * @param numBits bits from value to append\n     */\n    BitArray.prototype.appendBits = function (value /*int*/, numBits /*int*/) {\n        if (numBits < 0 || numBits > 32) {\n            throw new IllegalArgumentException_1.default('Num bits must be between 0 and 32');\n        }\n        this.ensureCapacity(this.size + numBits);\n        var appendBit = this.appendBit;\n        for (var numBitsLeft = numBits; numBitsLeft > 0; numBitsLeft--) {\n            this.appendBit(((value >> (numBitsLeft - 1)) & 0x01) === 1);\n        }\n    };\n    BitArray.prototype.appendBitArray = function (other) {\n        var otherSize = other.size;\n        this.ensureCapacity(this.size + otherSize);\n        var appendBit = this.appendBit;\n        for (var i = 0; i < otherSize; i++) {\n            this.appendBit(other.get(i));\n        }\n    };\n    BitArray.prototype.xor = function (other) {\n        if (this.size !== other.size) {\n            throw new IllegalArgumentException_1.default('Sizes don\\'t match');\n        }\n        var bits = this.bits;\n        for (var i = 0, length_1 = bits.length; i < length_1; i++) {\n            // The last int could be incomplete (i.e. not have 32 bits in\n            // it) but there is no problem since 0 XOR 0 == 0.\n            bits[i] ^= other.bits[i];\n        }\n    };\n    /**\n     *\n     * @param bitOffset first bit to start writing\n     * @param array array to write into. Bytes are written most-significant byte first. This is the opposite\n     *  of the internal representation, which is exposed by {@link #getBitArray()}\n     * @param offset position in array to start writing\n     * @param numBytes how many bytes to write\n     */\n    BitArray.prototype.toBytes = function (bitOffset /*int*/, array, offset /*int*/, numBytes /*int*/) {\n        for (var i = 0; i < numBytes; i++) {\n            var theByte = 0;\n            for (var j = 0; j < 8; j++) {\n                if (this.get(bitOffset)) {\n                    theByte |= 1 << (7 - j);\n                }\n                bitOffset++;\n            }\n            array[offset + i] = /*(byte)*/ theByte;\n        }\n    };\n    /**\n     * @return underlying array of ints. The first element holds the first 32 bits, and the least\n     *         significant bit is bit 0.\n     */\n    BitArray.prototype.getBitArray = function () {\n        return this.bits;\n    };\n    /**\n     * Reverses all bits in the array.\n     */\n    BitArray.prototype.reverse = function () {\n        var newBits = new Int32Array(this.bits.length);\n        // reverse all int's first\n        var len = Math.floor((this.size - 1) / 32);\n        var oldBitsLen = len + 1;\n        var bits = this.bits;\n        for (var i = 0; i < oldBitsLen; i++) {\n            var x = bits[i];\n            x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);\n            x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);\n            x = ((x >> 4) & 0x0f0f0f0f) | ((x & 0x0f0f0f0f) << 4);\n            x = ((x >> 8) & 0x00ff00ff) | ((x & 0x00ff00ff) << 8);\n            x = ((x >> 16) & 0x0000ffff) | ((x & 0x0000ffff) << 16);\n            newBits[len - i] = /*(int)*/ x;\n        }\n        // now correct the int's if the bit size isn't a multiple of 32\n        if (this.size !== oldBitsLen * 32) {\n            var leftOffset = oldBitsLen * 32 - this.size;\n            var currentInt = newBits[0] >>> leftOffset;\n            for (var i = 1; i < oldBitsLen; i++) {\n                var nextInt = newBits[i];\n                currentInt |= nextInt << (32 - leftOffset);\n                newBits[i - 1] = currentInt;\n                currentInt = nextInt >>> leftOffset;\n            }\n            newBits[oldBitsLen - 1] = currentInt;\n        }\n        this.bits = newBits;\n    };\n    BitArray.makeArray = function (size /*int*/) {\n        return new Int32Array(Math.floor((size + 31) / 32));\n    };\n    /*@Override*/\n    BitArray.prototype.equals = function (o) {\n        if (!(o instanceof BitArray)) {\n            return false;\n        }\n        var other = o;\n        return this.size === other.size && Arrays_1.default.equals(this.bits, other.bits);\n    };\n    /*@Override*/\n    BitArray.prototype.hashCode = function () {\n        return 31 * this.size + Arrays_1.default.hashCode(this.bits);\n    };\n    /*@Override*/\n    BitArray.prototype.toString = function () {\n        var result = '';\n        for (var i = 0, size = this.size; i < size; i++) {\n            if ((i & 0x07) === 0) {\n                result += ' ';\n            }\n            result += this.get(i) ? 'X' : '.';\n        }\n        return result;\n    };\n    /*@Override*/\n    BitArray.prototype.clone = function () {\n        return new BitArray(this.size, this.bits.slice());\n    };\n    return BitArray;\n}());\nexports.default = BitArray;\n//# sourceMappingURL=BitArray.js.map"]},"metadata":{},"sourceType":"script"}