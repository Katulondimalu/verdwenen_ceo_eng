{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.common.reedsolomon {*/\n\nvar AbstractGenericGF_1 = require(\"./AbstractGenericGF\");\n\nvar System_1 = require(\"../../util/System\");\n\nvar IllegalArgumentException_1 = require(\"../../IllegalArgumentException\");\n/**\n * <p>Represents a polynomial whose coefficients are elements of a GF.\n * Instances of this class are immutable.</p>\n *\n * <p>Much credit is due to William Rucklidge since portions of this code are an indirect\n * port of his C++ Reed-Solomon implementation.</p>\n *\n * @author Sean Owen\n */\n\n\nvar GenericGFPoly =\n/** @class */\nfunction () {\n  /**\n   * @param field the {@link GenericGF} instance representing the field to use\n   * to perform computations\n   * @param coefficients coefficients as ints representing elements of GF(size), arranged\n   * from most significant (highest-power term) coefficient to least significant\n   * @throws IllegalArgumentException if argument is null or empty,\n   * or if leading coefficient is 0 and this is not a\n   * constant polynomial (that is, it is not the monomial \"0\")\n   */\n  function GenericGFPoly(field, coefficients) {\n    if (coefficients.length === 0) {\n      throw new IllegalArgumentException_1.default();\n    }\n\n    this.field = field;\n    var coefficientsLength = coefficients.length;\n\n    if (coefficientsLength > 1 && coefficients[0] === 0) {\n      // Leading term must be non-zero for anything except the constant polynomial \"0\"\n      var firstNonZero = 1;\n\n      while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {\n        firstNonZero++;\n      }\n\n      if (firstNonZero === coefficientsLength) {\n        this.coefficients = Int32Array.from([0]);\n      } else {\n        this.coefficients = new Int32Array(coefficientsLength - firstNonZero);\n        System_1.default.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);\n      }\n    } else {\n      this.coefficients = coefficients;\n    }\n  }\n\n  GenericGFPoly.prototype.getCoefficients = function () {\n    return this.coefficients;\n  };\n  /**\n   * @return degree of this polynomial\n   */\n\n\n  GenericGFPoly.prototype.getDegree = function () {\n    return this.coefficients.length - 1;\n  };\n  /**\n   * @return true iff this polynomial is the monomial \"0\"\n   */\n\n\n  GenericGFPoly.prototype.isZero = function () {\n    return this.coefficients[0] === 0;\n  };\n  /**\n   * @return coefficient of x^degree term in this polynomial\n   */\n\n\n  GenericGFPoly.prototype.getCoefficient = function (degree\n  /*int*/\n  ) {\n    return this.coefficients[this.coefficients.length - 1 - degree];\n  };\n  /**\n   * @return evaluation of this polynomial at a given point\n   */\n\n\n  GenericGFPoly.prototype.evaluateAt = function (a\n  /*int*/\n  ) {\n    if (a === 0) {\n      // Just return the x^0 coefficient\n      return this.getCoefficient(0);\n    }\n\n    var coefficients = this.coefficients;\n    var result;\n\n    if (a === 1) {\n      // Just the sum of the coefficients\n      result = 0;\n\n      for (var i = 0, length_1 = coefficients.length; i !== length_1; i++) {\n        var coefficient = coefficients[i];\n        result = AbstractGenericGF_1.default.addOrSubtract(result, coefficient);\n      }\n\n      return result;\n    }\n\n    result = coefficients[0];\n    var size = coefficients.length;\n    var field = this.field;\n\n    for (var i = 1; i < size; i++) {\n      result = AbstractGenericGF_1.default.addOrSubtract(field.multiply(a, result), coefficients[i]);\n    }\n\n    return result;\n  };\n\n  GenericGFPoly.prototype.addOrSubtract = function (other) {\n    if (!this.field.equals(other.field)) {\n      throw new IllegalArgumentException_1.default('GenericGFPolys do not have same GenericGF field');\n    }\n\n    if (this.isZero()) {\n      return other;\n    }\n\n    if (other.isZero()) {\n      return this;\n    }\n\n    var smallerCoefficients = this.coefficients;\n    var largerCoefficients = other.coefficients;\n\n    if (smallerCoefficients.length > largerCoefficients.length) {\n      var temp = smallerCoefficients;\n      smallerCoefficients = largerCoefficients;\n      largerCoefficients = temp;\n    }\n\n    var sumDiff = new Int32Array(largerCoefficients.length);\n    var lengthDiff = largerCoefficients.length - smallerCoefficients.length; // Copy high-order terms only found in higher-degree polynomial's coefficients\n\n    System_1.default.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);\n\n    for (var i = lengthDiff; i < largerCoefficients.length; i++) {\n      sumDiff[i] = AbstractGenericGF_1.default.addOrSubtract(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);\n    }\n\n    return new GenericGFPoly(this.field, sumDiff);\n  };\n\n  GenericGFPoly.prototype.multiply = function (other) {\n    if (!this.field.equals(other.field)) {\n      throw new IllegalArgumentException_1.default('GenericGFPolys do not have same GenericGF field');\n    }\n\n    if (this.isZero() || other.isZero()) {\n      return this.field.getZero();\n    }\n\n    var aCoefficients = this.coefficients;\n    var aLength = aCoefficients.length;\n    var bCoefficients = other.coefficients;\n    var bLength = bCoefficients.length;\n    var product = new Int32Array(aLength + bLength - 1);\n    var field = this.field;\n\n    for (var i = 0; i < aLength; i++) {\n      var aCoeff = aCoefficients[i];\n\n      for (var j = 0; j < bLength; j++) {\n        product[i + j] = AbstractGenericGF_1.default.addOrSubtract(product[i + j], field.multiply(aCoeff, bCoefficients[j]));\n      }\n    }\n\n    return new GenericGFPoly(field, product);\n  };\n\n  GenericGFPoly.prototype.multiplyScalar = function (scalar\n  /*int*/\n  ) {\n    if (scalar === 0) {\n      return this.field.getZero();\n    }\n\n    if (scalar === 1) {\n      return this;\n    }\n\n    var size = this.coefficients.length;\n    var field = this.field;\n    var product = new Int32Array(size);\n    var coefficients = this.coefficients;\n\n    for (var i = 0; i < size; i++) {\n      product[i] = field.multiply(coefficients[i], scalar);\n    }\n\n    return new GenericGFPoly(field, product);\n  };\n\n  GenericGFPoly.prototype.multiplyByMonomial = function (degree\n  /*int*/\n  , coefficient\n  /*int*/\n  ) {\n    if (degree < 0) {\n      throw new IllegalArgumentException_1.default();\n    }\n\n    if (coefficient === 0) {\n      return this.field.getZero();\n    }\n\n    var coefficients = this.coefficients;\n    var size = coefficients.length;\n    var product = new Int32Array(size + degree);\n    var field = this.field;\n\n    for (var i = 0; i < size; i++) {\n      product[i] = field.multiply(coefficients[i], coefficient);\n    }\n\n    return new GenericGFPoly(field, product);\n  };\n\n  GenericGFPoly.prototype.divide = function (other) {\n    if (!this.field.equals(other.field)) {\n      throw new IllegalArgumentException_1.default('GenericGFPolys do not have same GenericGF field');\n    }\n\n    if (other.isZero()) {\n      throw new IllegalArgumentException_1.default('Divide by 0');\n    }\n\n    var field = this.field;\n    var quotient = field.getZero();\n    var remainder = this;\n    var denominatorLeadingTerm = other.getCoefficient(other.getDegree());\n    var inverseDenominatorLeadingTerm = field.inverse(denominatorLeadingTerm);\n\n    while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {\n      var degreeDifference = remainder.getDegree() - other.getDegree();\n      var scale = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);\n      var term = other.multiplyByMonomial(degreeDifference, scale);\n      var iterationQuotient = field.buildMonomial(degreeDifference, scale);\n      quotient = quotient.addOrSubtract(iterationQuotient);\n      remainder = remainder.addOrSubtract(term);\n    }\n\n    return [quotient, remainder];\n  };\n  /*@Override*/\n\n\n  GenericGFPoly.prototype.toString = function () {\n    var result = '';\n\n    for (var degree = this.getDegree(); degree >= 0; degree--) {\n      var coefficient = this.getCoefficient(degree);\n\n      if (coefficient !== 0) {\n        if (coefficient < 0) {\n          result += ' - ';\n          coefficient = -coefficient;\n        } else {\n          if (result.length > 0) {\n            result += ' + ';\n          }\n        }\n\n        if (degree === 0 || coefficient !== 1) {\n          var alphaPower = this.field.log(coefficient);\n\n          if (alphaPower === 0) {\n            result += '1';\n          } else if (alphaPower === 1) {\n            result += 'a';\n          } else {\n            result += 'a^';\n            result += alphaPower;\n          }\n        }\n\n        if (degree !== 0) {\n          if (degree === 1) {\n            result += 'x';\n          } else {\n            result += 'x^';\n            result += degree;\n          }\n        }\n      }\n    }\n\n    return result;\n  };\n\n  return GenericGFPoly;\n}();\n\nexports.default = GenericGFPoly;","map":{"version":3,"sources":["../../../../src/core/common/reedsolomon/GenericGFPoly.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.common.reedsolomon {*/\nvar AbstractGenericGF_1 = require(\"./AbstractGenericGF\");\nvar System_1 = require(\"../../util/System\");\nvar IllegalArgumentException_1 = require(\"../../IllegalArgumentException\");\n/**\n * <p>Represents a polynomial whose coefficients are elements of a GF.\n * Instances of this class are immutable.</p>\n *\n * <p>Much credit is due to William Rucklidge since portions of this code are an indirect\n * port of his C++ Reed-Solomon implementation.</p>\n *\n * @author Sean Owen\n */\nvar GenericGFPoly = /** @class */ (function () {\n    /**\n     * @param field the {@link GenericGF} instance representing the field to use\n     * to perform computations\n     * @param coefficients coefficients as ints representing elements of GF(size), arranged\n     * from most significant (highest-power term) coefficient to least significant\n     * @throws IllegalArgumentException if argument is null or empty,\n     * or if leading coefficient is 0 and this is not a\n     * constant polynomial (that is, it is not the monomial \"0\")\n     */\n    function GenericGFPoly(field, coefficients) {\n        if (coefficients.length === 0) {\n            throw new IllegalArgumentException_1.default();\n        }\n        this.field = field;\n        var coefficientsLength = coefficients.length;\n        if (coefficientsLength > 1 && coefficients[0] === 0) {\n            // Leading term must be non-zero for anything except the constant polynomial \"0\"\n            var firstNonZero = 1;\n            while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {\n                firstNonZero++;\n            }\n            if (firstNonZero === coefficientsLength) {\n                this.coefficients = Int32Array.from([0]);\n            }\n            else {\n                this.coefficients = new Int32Array(coefficientsLength - firstNonZero);\n                System_1.default.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);\n            }\n        }\n        else {\n            this.coefficients = coefficients;\n        }\n    }\n    GenericGFPoly.prototype.getCoefficients = function () {\n        return this.coefficients;\n    };\n    /**\n     * @return degree of this polynomial\n     */\n    GenericGFPoly.prototype.getDegree = function () {\n        return this.coefficients.length - 1;\n    };\n    /**\n     * @return true iff this polynomial is the monomial \"0\"\n     */\n    GenericGFPoly.prototype.isZero = function () {\n        return this.coefficients[0] === 0;\n    };\n    /**\n     * @return coefficient of x^degree term in this polynomial\n     */\n    GenericGFPoly.prototype.getCoefficient = function (degree /*int*/) {\n        return this.coefficients[this.coefficients.length - 1 - degree];\n    };\n    /**\n     * @return evaluation of this polynomial at a given point\n     */\n    GenericGFPoly.prototype.evaluateAt = function (a /*int*/) {\n        if (a === 0) {\n            // Just return the x^0 coefficient\n            return this.getCoefficient(0);\n        }\n        var coefficients = this.coefficients;\n        var result;\n        if (a === 1) {\n            // Just the sum of the coefficients\n            result = 0;\n            for (var i = 0, length_1 = coefficients.length; i !== length_1; i++) {\n                var coefficient = coefficients[i];\n                result = AbstractGenericGF_1.default.addOrSubtract(result, coefficient);\n            }\n            return result;\n        }\n        result = coefficients[0];\n        var size = coefficients.length;\n        var field = this.field;\n        for (var i = 1; i < size; i++) {\n            result = AbstractGenericGF_1.default.addOrSubtract(field.multiply(a, result), coefficients[i]);\n        }\n        return result;\n    };\n    GenericGFPoly.prototype.addOrSubtract = function (other) {\n        if (!this.field.equals(other.field)) {\n            throw new IllegalArgumentException_1.default('GenericGFPolys do not have same GenericGF field');\n        }\n        if (this.isZero()) {\n            return other;\n        }\n        if (other.isZero()) {\n            return this;\n        }\n        var smallerCoefficients = this.coefficients;\n        var largerCoefficients = other.coefficients;\n        if (smallerCoefficients.length > largerCoefficients.length) {\n            var temp = smallerCoefficients;\n            smallerCoefficients = largerCoefficients;\n            largerCoefficients = temp;\n        }\n        var sumDiff = new Int32Array(largerCoefficients.length);\n        var lengthDiff = largerCoefficients.length - smallerCoefficients.length;\n        // Copy high-order terms only found in higher-degree polynomial's coefficients\n        System_1.default.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);\n        for (var i = lengthDiff; i < largerCoefficients.length; i++) {\n            sumDiff[i] = AbstractGenericGF_1.default.addOrSubtract(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);\n        }\n        return new GenericGFPoly(this.field, sumDiff);\n    };\n    GenericGFPoly.prototype.multiply = function (other) {\n        if (!this.field.equals(other.field)) {\n            throw new IllegalArgumentException_1.default('GenericGFPolys do not have same GenericGF field');\n        }\n        if (this.isZero() || other.isZero()) {\n            return this.field.getZero();\n        }\n        var aCoefficients = this.coefficients;\n        var aLength = aCoefficients.length;\n        var bCoefficients = other.coefficients;\n        var bLength = bCoefficients.length;\n        var product = new Int32Array(aLength + bLength - 1);\n        var field = this.field;\n        for (var i = 0; i < aLength; i++) {\n            var aCoeff = aCoefficients[i];\n            for (var j = 0; j < bLength; j++) {\n                product[i + j] = AbstractGenericGF_1.default.addOrSubtract(product[i + j], field.multiply(aCoeff, bCoefficients[j]));\n            }\n        }\n        return new GenericGFPoly(field, product);\n    };\n    GenericGFPoly.prototype.multiplyScalar = function (scalar /*int*/) {\n        if (scalar === 0) {\n            return this.field.getZero();\n        }\n        if (scalar === 1) {\n            return this;\n        }\n        var size = this.coefficients.length;\n        var field = this.field;\n        var product = new Int32Array(size);\n        var coefficients = this.coefficients;\n        for (var i = 0; i < size; i++) {\n            product[i] = field.multiply(coefficients[i], scalar);\n        }\n        return new GenericGFPoly(field, product);\n    };\n    GenericGFPoly.prototype.multiplyByMonomial = function (degree /*int*/, coefficient /*int*/) {\n        if (degree < 0) {\n            throw new IllegalArgumentException_1.default();\n        }\n        if (coefficient === 0) {\n            return this.field.getZero();\n        }\n        var coefficients = this.coefficients;\n        var size = coefficients.length;\n        var product = new Int32Array(size + degree);\n        var field = this.field;\n        for (var i = 0; i < size; i++) {\n            product[i] = field.multiply(coefficients[i], coefficient);\n        }\n        return new GenericGFPoly(field, product);\n    };\n    GenericGFPoly.prototype.divide = function (other) {\n        if (!this.field.equals(other.field)) {\n            throw new IllegalArgumentException_1.default('GenericGFPolys do not have same GenericGF field');\n        }\n        if (other.isZero()) {\n            throw new IllegalArgumentException_1.default('Divide by 0');\n        }\n        var field = this.field;\n        var quotient = field.getZero();\n        var remainder = this;\n        var denominatorLeadingTerm = other.getCoefficient(other.getDegree());\n        var inverseDenominatorLeadingTerm = field.inverse(denominatorLeadingTerm);\n        while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {\n            var degreeDifference = remainder.getDegree() - other.getDegree();\n            var scale = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);\n            var term = other.multiplyByMonomial(degreeDifference, scale);\n            var iterationQuotient = field.buildMonomial(degreeDifference, scale);\n            quotient = quotient.addOrSubtract(iterationQuotient);\n            remainder = remainder.addOrSubtract(term);\n        }\n        return [quotient, remainder];\n    };\n    /*@Override*/\n    GenericGFPoly.prototype.toString = function () {\n        var result = '';\n        for (var degree = this.getDegree(); degree >= 0; degree--) {\n            var coefficient = this.getCoefficient(degree);\n            if (coefficient !== 0) {\n                if (coefficient < 0) {\n                    result += ' - ';\n                    coefficient = -coefficient;\n                }\n                else {\n                    if (result.length > 0) {\n                        result += ' + ';\n                    }\n                }\n                if (degree === 0 || coefficient !== 1) {\n                    var alphaPower = this.field.log(coefficient);\n                    if (alphaPower === 0) {\n                        result += '1';\n                    }\n                    else if (alphaPower === 1) {\n                        result += 'a';\n                    }\n                    else {\n                        result += 'a^';\n                        result += alphaPower;\n                    }\n                }\n                if (degree !== 0) {\n                    if (degree === 1) {\n                        result += 'x';\n                    }\n                    else {\n                        result += 'x^';\n                        result += degree;\n                    }\n                }\n            }\n        }\n        return result;\n    };\n    return GenericGFPoly;\n}());\nexports.default = GenericGFPoly;\n//# sourceMappingURL=GenericGFPoly.js.map"]},"metadata":{},"sourceType":"script"}