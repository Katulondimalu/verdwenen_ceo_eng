{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\n\nconst Cell = require(\"./Cell\");\n\nconst Row = require(\"./Row\");\n\nconst Column = require(\"./Column\");\n\nconst Range = require(\"./Range\");\n\nconst Relationships = require(\"./Relationships\");\n\nconst xmlq = require(\"./xmlq\");\n\nconst regexify = require(\"./regexify\");\n\nconst addressConverter = require(\"./addressConverter\");\n\nconst ArgHandler = require(\"./ArgHandler\");\n\nconst colorIndexes = require(\"./colorIndexes\");\n\nconst PageBreaks = require(\"./PageBreaks\"); // Order of the nodes as defined by the spec.\n\n\nconst nodeOrder = [\"sheetPr\", \"dimension\", \"sheetViews\", \"sheetFormatPr\", \"cols\", \"sheetData\", \"sheetCalcPr\", \"sheetProtection\", \"autoFilter\", \"protectedRanges\", \"scenarios\", \"autoFilter\", \"sortState\", \"dataConsolidate\", \"customSheetViews\", \"mergeCells\", \"phoneticPr\", \"conditionalFormatting\", \"dataValidations\", \"hyperlinks\", \"printOptions\", \"pageMargins\", \"pageSetup\", \"headerFooter\", \"rowBreaks\", \"colBreaks\", \"customProperties\", \"cellWatches\", \"ignoredErrors\", \"smartTags\", \"drawing\", \"drawingHF\", \"legacyDrawing\", \"legacyDrawingHF\", \"picture\", \"oleObjects\", \"controls\", \"webPublishItems\", \"tableParts\", \"extLst\"];\n/**\n * A worksheet.\n */\n\nclass Sheet {\n  // /**\n  //  * Creates a new instance of Sheet.\n  //  * @param {Workbook} workbook - The parent workbook.\n  //  * @param {{}} idNode - The sheet ID node (from the parent workbook).\n  //  * @param {{}} node - The sheet node.\n  //  * @param {{}} [relationshipsNode] - The optional sheet relationships node.\n  //  */\n  constructor(workbook, idNode, node, relationshipsNode) {\n    this._init(workbook, idNode, node, relationshipsNode);\n  }\n  /* PUBLIC */\n\n  /**\n   * Gets a value indicating whether the sheet is the active sheet in the workbook.\n   * @returns {boolean} True if active, false otherwise.\n   */\n\n  /**\n  * Make the sheet the active sheet in the workkbok.\n  * @param {boolean} active - Must be set to `true`. Deactivating directly is not supported. To deactivate, you should activate a different sheet instead.\n  * @returns {Sheet} The sheet.\n  */\n\n\n  active() {\n    return new ArgHandler('Sheet.active').case(() => {\n      return this.workbook().activeSheet() === this;\n    }).case('boolean', active => {\n      if (!active) throw new Error(\"Deactivating sheet directly not supported. Activate a different sheet instead.\");\n      this.workbook().activeSheet(this);\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Get the active cell in the sheet.\n   * @returns {Cell} The active cell.\n   */\n\n  /**\n  * Set the active cell in the workbook.\n  * @param {string|Cell} cell - The cell or address of cell to activate.\n  * @returns {Sheet} The sheet.\n  */\n\n  /**\n  * Set the active cell in the workbook by row and column.\n  * @param {number} rowNumber - The row number of the cell.\n  * @param {string|number} columnNameOrNumber - The column name or number of the cell.\n  * @returns {Sheet} The sheet.\n  */\n\n\n  activeCell() {\n    const sheetViewNode = this._getOrCreateSheetViewNode();\n\n    let selectionNode = xmlq.findChild(sheetViewNode, \"selection\");\n    return new ArgHandler('Sheet.activeCell').case(() => {\n      const cellAddress = selectionNode ? selectionNode.attributes.activeCell : \"A1\";\n      return this.cell(cellAddress);\n    }).case(['number', '*'], (rowNumber, columnNameOrNumber) => {\n      const cell = this.cell(rowNumber, columnNameOrNumber);\n      return this.activeCell(cell);\n    }).case('*', cell => {\n      if (!selectionNode) {\n        selectionNode = {\n          name: \"selection\",\n          attributes: {},\n          children: []\n        };\n        xmlq.appendChild(sheetViewNode, selectionNode);\n      }\n\n      if (!(cell instanceof Cell)) cell = this.cell(cell);\n      selectionNode.attributes.activeCell = selectionNode.attributes.sqref = cell.address();\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Gets the cell with the given address.\n   * @param {string} address - The address of the cell.\n   * @returns {Cell} The cell.\n   */\n\n  /**\n  * Gets the cell with the given row and column numbers.\n  * @param {number} rowNumber - The row number of the cell.\n  * @param {string|number} columnNameOrNumber - The column name or number of the cell.\n  * @returns {Cell} The cell.\n  */\n\n\n  cell() {\n    return new ArgHandler('Sheet.cell').case('string', address => {\n      const ref = addressConverter.fromAddress(address);\n      if (ref.type !== 'cell') throw new Error('Sheet.cell: Invalid address.');\n      return this.row(ref.rowNumber).cell(ref.columnNumber);\n    }).case(['number', '*'], (rowNumber, columnNameOrNumber) => {\n      return this.row(rowNumber).cell(columnNameOrNumber);\n    }).handle(arguments);\n  }\n  /**\n   * Gets a column in the sheet.\n   * @param {string|number} columnNameOrNumber - The name or number of the column.\n   * @returns {Column} The column.\n   */\n\n\n  column(columnNameOrNumber) {\n    const columnNumber = typeof columnNameOrNumber === \"string\" ? addressConverter.columnNameToNumber(columnNameOrNumber) : columnNameOrNumber; // If we're already created a column for this column number, return it.\n\n    if (this._columns[columnNumber]) return this._columns[columnNumber]; // We need to create a new column, which requires a backing col node. There may already exist a node whose min/max cover our column.\n    // First, see if there is an existing col node.\n\n    const existingColNode = this._colNodes[columnNumber];\n    let colNode;\n\n    if (existingColNode) {\n      // If the existing node covered earlier columns than the new one, we need to have a col node to cover the min up to our new node.\n      if (existingColNode.attributes.min < columnNumber) {\n        // Clone the node and set the max to the column before our new col.\n        const beforeColNode = _.cloneDeep(existingColNode);\n\n        beforeColNode.attributes.max = columnNumber - 1; // Update the col nodes cache.\n\n        for (let i = beforeColNode.attributes.min; i <= beforeColNode.attributes.max; i++) {\n          this._colNodes[i] = beforeColNode;\n        }\n      } // Make a clone for the new column. Set the min/max to the column number and cache it.\n\n\n      colNode = _.cloneDeep(existingColNode);\n      colNode.attributes.min = columnNumber;\n      colNode.attributes.max = columnNumber;\n      this._colNodes[columnNumber] = colNode; // If the max of the existing node is greater than the nre one, create a col node for that too.\n\n      if (existingColNode.attributes.max > columnNumber) {\n        const afterColNode = _.cloneDeep(existingColNode);\n\n        afterColNode.attributes.min = columnNumber + 1;\n\n        for (let i = afterColNode.attributes.min; i <= afterColNode.attributes.max; i++) {\n          this._colNodes[i] = afterColNode;\n        }\n      }\n    } else {\n      // The was no existing node so create a new one.\n      colNode = {\n        name: 'col',\n        attributes: {\n          min: columnNumber,\n          max: columnNumber\n        },\n        children: []\n      };\n      this._colNodes[columnNumber] = colNode;\n    } // Create the new column and cache it.\n\n\n    const column = new Column(this, colNode);\n    this._columns[columnNumber] = column;\n    return column;\n  }\n  /**\n   * Gets a defined name scoped to the sheet.\n   * @param {string} name - The defined name.\n   * @returns {undefined|string|Cell|Range|Row|Column} What the defined name refers to or undefined if not found. Will return the string formula if not a Row, Column, Cell, or Range.\n   */\n\n  /**\n  * Set a defined name scoped to the sheet.\n  * @param {string} name - The defined name.\n  * @param {string|Cell|Range|Row|Column} refersTo - What the name refers to.\n  * @returns {Workbook} The workbook.\n  */\n\n\n  definedName() {\n    return new ArgHandler(\"Workbook.definedName\").case('string', name => {\n      return this.workbook().scopedDefinedName(this, name);\n    }).case(['string', '*'], (name, refersTo) => {\n      this.workbook().scopedDefinedName(this, name, refersTo);\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Deletes the sheet and returns the parent workbook.\n   * @returns {Workbook} The workbook.\n   */\n\n\n  delete() {\n    this.workbook().deleteSheet(this);\n    return this.workbook();\n  }\n  /**\n   * Find the given pattern in the sheet and optionally replace it.\n   * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n   * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in each cell will be replaced.\n   * @returns {Array.<Cell>} The matching cells.\n   */\n\n\n  find(pattern, replacement) {\n    pattern = regexify(pattern);\n    let matches = [];\n\n    this._rows.forEach(row => {\n      if (!row) return;\n      matches = matches.concat(row.find(pattern, replacement));\n    });\n\n    return matches;\n  }\n  /**\n   * Gets a value indicating whether this sheet's grid lines are visible.\n   * @returns {boolean} True if selected, false if not.\n   */\n\n  /**\n  * Sets whether this sheet's grid lines are visible.\n  * @param {boolean} selected - True to make visible, false to hide.\n  * @returns {Sheet} The sheet.\n  */\n\n\n  gridLinesVisible() {\n    const sheetViewNode = this._getOrCreateSheetViewNode();\n\n    return new ArgHandler('Sheet.gridLinesVisible').case(() => {\n      return sheetViewNode.attributes.showGridLines === 1 || sheetViewNode.attributes.showGridLines === undefined;\n    }).case('boolean', visible => {\n      sheetViewNode.attributes.showGridLines = visible ? 1 : 0;\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Gets a value indicating if the sheet is hidden or not.\n   * @returns {boolean|string} True if hidden, false if visible, and 'very' if very hidden.\n   */\n\n  /**\n  * Set whether the sheet is hidden or not.\n  * @param {boolean|string} hidden - True to hide, false to show, and 'very' to make very hidden.\n  * @returns {Sheet} The sheet.\n  */\n\n\n  hidden() {\n    return new ArgHandler('Sheet.hidden').case(() => {\n      if (this._idNode.attributes.state === 'hidden') return true;\n      if (this._idNode.attributes.state === 'veryHidden') return \"very\";\n      return false;\n    }).case('*', hidden => {\n      if (hidden) {\n        const visibleSheets = _.filter(this.workbook().sheets(), sheet => !sheet.hidden());\n\n        if (visibleSheets.length === 1 && visibleSheets[0] === this) {\n          throw new Error(\"This sheet may not be hidden as a workbook must contain at least one visible sheet.\");\n        } // If activate, activate the first other visible sheet.\n\n\n        if (this.active()) {\n          const activeIndex = visibleSheets[0] === this ? 1 : 0;\n          visibleSheets[activeIndex].active(true);\n        }\n      }\n\n      if (hidden === 'very') this._idNode.attributes.state = 'veryHidden';else if (hidden) this._idNode.attributes.state = 'hidden';else delete this._idNode.attributes.state;\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Move the sheet.\n   * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n   * @returns {Sheet} The sheet.\n   */\n\n\n  move(indexOrBeforeSheet) {\n    this.workbook().moveSheet(this, indexOrBeforeSheet);\n    return this;\n  }\n  /**\n   * Get the name of the sheet.\n   * @returns {string} The sheet name.\n   */\n\n  /**\n  * Set the name of the sheet. *Note: this method does not rename references to the sheet so formulas, etc. can be broken. Use with caution!*\n  * @param {string} name - The name to set to the sheet.\n  * @returns {Sheet} The sheet.\n  */\n\n\n  name() {\n    return new ArgHandler('Sheet.name').case(() => {\n      return `${this._idNode.attributes.name}`;\n    }).case('string', name => {\n      this._idNode.attributes.name = name;\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Gets a range from the given range address.\n   * @param {string} address - The range address (e.g. 'A1:B3').\n   * @returns {Range} The range.\n   */\n\n  /**\n  * Gets a range from the given cells or cell addresses.\n  * @param {string|Cell} startCell - The starting cell or cell address (e.g. 'A1').\n  * @param {string|Cell} endCell - The ending cell or cell address (e.g. 'B3').\n  * @returns {Range} The range.\n  */\n\n  /**\n  * Gets a range from the given row numbers and column names or numbers.\n  * @param {number} startRowNumber - The starting cell row number.\n  * @param {string|number} startColumnNameOrNumber - The starting cell column name or number.\n  * @param {number} endRowNumber - The ending cell row number.\n  * @param {string|number} endColumnNameOrNumber - The ending cell column name or number.\n  * @returns {Range} The range.\n  */\n\n\n  range() {\n    return new ArgHandler('Sheet.range').case('string', address => {\n      const ref = addressConverter.fromAddress(address);\n      if (ref.type !== 'range') throw new Error('Sheet.range: Invalid address');\n      return this.range(ref.startRowNumber, ref.startColumnNumber, ref.endRowNumber, ref.endColumnNumber);\n    }).case(['*', '*'], (startCell, endCell) => {\n      if (typeof startCell === \"string\") startCell = this.cell(startCell);\n      if (typeof endCell === \"string\") endCell = this.cell(endCell);\n      return new Range(startCell, endCell);\n    }).case(['number', '*', 'number', '*'], (startRowNumber, startColumnNameOrNumber, endRowNumber, endColumnNameOrNumber) => {\n      return this.range(this.cell(startRowNumber, startColumnNameOrNumber), this.cell(endRowNumber, endColumnNameOrNumber));\n    }).handle(arguments);\n  }\n  /**\n   * Unsets sheet autoFilter.\n   * @returns {Sheet} This sheet.\n   */\n\n  /**\n  * Sets sheet autoFilter to a Range.\n  * @param {Range} range - The autoFilter range.\n  * @returns {Sheet} This sheet.\n  */\n\n\n  autoFilter(range) {\n    this._autoFilter = range;\n    return this;\n  }\n  /**\n   * Gets the row with the given number.\n   * @param {number} rowNumber - The row number.\n   * @returns {Row} The row with the given number.\n   */\n\n\n  row(rowNumber) {\n    if (rowNumber < 1) throw new RangeError(`Invalid row number ${rowNumber}. Remember that spreadsheets use 1-based indexing.`);\n    if (this._rows[rowNumber]) return this._rows[rowNumber];\n    const rowNode = {\n      name: 'row',\n      attributes: {\n        r: rowNumber\n      },\n      children: []\n    };\n    const row = new Row(this, rowNode);\n    this._rows[rowNumber] = row;\n    return row;\n  }\n  /**\n   * Get the tab color. (See style [Color](#color).)\n   * @returns {undefined|Color} The color or undefined if not set.\n   */\n\n  /**\n  * Sets the tab color. (See style [Color](#color).)\n  * @returns {Color|string|number} color - Color of the tab. If string, will set an RGB color. If number, will set a theme color.\n  */\n\n\n  tabColor() {\n    return new ArgHandler(\"Sheet.tabColor\").case(() => {\n      const tabColorNode = xmlq.findChild(this._sheetPrNode, \"tabColor\");\n      if (!tabColorNode) return;\n      const color = {};\n      if (tabColorNode.attributes.hasOwnProperty('rgb')) color.rgb = tabColorNode.attributes.rgb;else if (tabColorNode.attributes.hasOwnProperty('theme')) color.theme = tabColorNode.attributes.theme;else if (tabColorNode.attributes.hasOwnProperty('indexed')) color.rgb = colorIndexes[tabColorNode.attributes.indexed];\n      if (tabColorNode.attributes.hasOwnProperty('tint')) color.tint = tabColorNode.attributes.tint;\n      return color;\n    }).case(\"string\", rgb => this.tabColor({\n      rgb\n    })).case(\"integer\", theme => this.tabColor({\n      theme\n    })).case(\"nil\", () => {\n      xmlq.removeChild(this._sheetPrNode, \"tabColor\");\n      return this;\n    }).case(\"object\", color => {\n      const tabColorNode = xmlq.appendChildIfNotFound(this._sheetPrNode, \"tabColor\");\n      xmlq.setAttributes(tabColorNode, {\n        rgb: color.rgb && color.rgb.toUpperCase(),\n        indexed: null,\n        theme: color.theme,\n        tint: color.tint\n      });\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Gets a value indicating whether this sheet is selected.\n   * @returns {boolean} True if selected, false if not.\n   */\n\n  /**\n  * Sets whether this sheet is selected.\n  * @param {boolean} selected - True to select, false to deselected.\n  * @returns {Sheet} The sheet.\n  */\n\n\n  tabSelected() {\n    const sheetViewNode = this._getOrCreateSheetViewNode();\n\n    return new ArgHandler('Sheet.tabSelected').case(() => {\n      return sheetViewNode.attributes.tabSelected === 1;\n    }).case('boolean', selected => {\n      if (selected) sheetViewNode.attributes.tabSelected = 1;else delete sheetViewNode.attributes.tabSelected;\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Gets a value indicating whether this sheet is rtl (Right To Left).\n   * @returns {boolean} True if rtl, false if ltr.\n   */\n\n  /**\n  * Sets whether this sheet is rtl.\n  * @param {boolean} rtl - True to rtl, false to ltr (Left To Right).\n  * @returns {Sheet} The sheet.\n  */\n\n\n  rightToLeft() {\n    const sheetViewNode = this._getOrCreateSheetViewNode();\n\n    return new ArgHandler('Sheet.rightToLeft').case(() => {\n      return sheetViewNode.attributes.rightToLeft;\n    }).case('boolean', rtl => {\n      if (rtl) sheetViewNode.attributes.rightToLeft = true;else delete sheetViewNode.attributes.rightToLeft;\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Get the range of cells in the sheet that have contained a value or style at any point. Useful for extracting the entire sheet contents.\n   * @returns {Range|undefined} The used range or undefined if no cells in the sheet are used.\n   */\n\n\n  usedRange() {\n    const minRowNumber = _.findIndex(this._rows);\n\n    const maxRowNumber = this._rows.length - 1;\n    let minColumnNumber = 0;\n    let maxColumnNumber = 0;\n\n    for (let i = 0; i < this._rows.length; i++) {\n      const row = this._rows[i];\n      if (!row) continue;\n      const minUsedColumnNumber = row.minUsedColumnNumber();\n      const maxUsedColumnNumber = row.maxUsedColumnNumber();\n      if (minUsedColumnNumber > 0 && (!minColumnNumber || minUsedColumnNumber < minColumnNumber)) minColumnNumber = minUsedColumnNumber;\n      if (maxUsedColumnNumber > 0 && (!maxColumnNumber || maxUsedColumnNumber > maxColumnNumber)) maxColumnNumber = maxUsedColumnNumber;\n    } // Return undefined if nothing in the sheet is used.\n\n\n    if (minRowNumber <= 0 || minColumnNumber <= 0 || maxRowNumber <= 0 || maxColumnNumber <= 0) return;\n    return this.range(minRowNumber, minColumnNumber, maxRowNumber, maxColumnNumber);\n  }\n  /**\n   * Gets the parent workbook.\n   * @returns {Workbook} The parent workbook.\n   */\n\n\n  workbook() {\n    return this._workbook;\n  }\n  /**\n   * Gets all page breaks.\n   * @returns {{}} the object holds both vertical and horizontal PageBreaks.\n   */\n\n\n  pageBreaks() {\n    return this._pageBreaks;\n  }\n  /**\n   * Gets the vertical page breaks.\n   * @returns {PageBreaks} vertical PageBreaks.\n   */\n\n\n  verticalPageBreaks() {\n    return this._pageBreaks.colBreaks;\n  }\n  /**\n   * Gets the horizontal page breaks.\n   * @returns {PageBreaks} horizontal PageBreaks.\n   */\n\n\n  horizontalPageBreaks() {\n    return this._pageBreaks.rowBreaks;\n  }\n  /* INTERNAL */\n\n  /**\n   * Clear cells that are using a given shared formula ID.\n   * @param {number} sharedFormulaId - The shared formula ID.\n   * @returns {undefined}\n   * @ignore\n   */\n\n\n  clearCellsUsingSharedFormula(sharedFormulaId) {\n    this._rows.forEach(row => {\n      if (!row) return;\n      row.clearCellsUsingSharedFormula(sharedFormulaId);\n    });\n  }\n  /**\n   * Get an existing column style ID.\n   * @param {number} columnNumber - The column number.\n   * @returns {undefined|number} The style ID.\n   * @ignore\n   */\n\n\n  existingColumnStyleId(columnNumber) {\n    // This will work after setting Column.style because Column updates the attributes live.\n    const colNode = this._colNodes[columnNumber];\n    return colNode && colNode.attributes.style;\n  }\n  /**\n   * Call a callback for each column number that has a node defined for it.\n   * @param {Function} callback - The callback.\n   * @returns {undefined}\n   * @ignore\n   */\n\n\n  forEachExistingColumnNumber(callback) {\n    _.forEach(this._colNodes, (node, columnNumber) => {\n      if (!node) return;\n      callback(columnNumber);\n    });\n  }\n  /**\n   * Call a callback for each existing row.\n   * @param {Function} callback - The callback.\n   * @returns {undefined}\n   * @ignore\n   */\n\n\n  forEachExistingRow(callback) {\n    _.forEach(this._rows, (row, rowNumber) => {\n      if (row) callback(row, rowNumber);\n    });\n\n    return this;\n  }\n  /**\n   * Get the hyperlink attached to the cell with the given address.\n   * @param {string} address - The address of the hyperlinked cell.\n   * @returns {string|undefined} The hyperlink or undefined if not set.\n   */\n\n  /**\n  * Set the hyperlink on the cell with the given address.\n  * @param {string} address - The address of the hyperlinked cell.\n  * @param {string} hyperlink - The hyperlink to set or undefined to clear.\n  * @param {boolean} [internal] - The flag to force hyperlink to be internal. If true, then autodetect is skipped.\n  * @returns {Sheet} The sheet.\n  */\n\n  /**\n  * Set the hyperlink on the cell with the given address. If opts is a Cell an internal hyperlink is added.\n  * @param {string} address - The address of the hyperlinked cell.\n  * @param {object|Cell} opts - Options.\n  * @returns {Sheet} The sheet.\n  * @ignore\n  */\n\n  /**\n  * Set the hyperlink on the cell with the given address and options.\n  * @param {string} address - The address of the hyperlinked cell.\n  * @param {{}|Cell} opts - Options or Cell. If opts is a Cell then an internal hyperlink is added.\n  * @param {string|Cell} [opts.hyperlink] - The hyperlink to set, can be a Cell or an internal/external string.\n  * @param {string} [opts.tooltip] - Additional text to help the user understand more about the hyperlink.\n  * @param {string} [opts.email] - Email address, ignored if opts.hyperlink is set.\n  * @param {string} [opts.emailSubject] - Email subject, ignored if opts.hyperlink is set.\n  * @returns {Sheet} The sheet.\n  */\n\n\n  hyperlink() {\n    return new ArgHandler('Sheet.hyperlink').case('string', address => {\n      const hyperlinkNode = this._hyperlinks[address];\n      if (!hyperlinkNode) return;\n\n      const relationship = this._relationships.findById(hyperlinkNode.attributes['r:id']);\n\n      return relationship && relationship.attributes.Target;\n    }).case(['string', 'nil'], address => {\n      // TODO: delete relationship\n      delete this._hyperlinks[address];\n      return this;\n    }).case(['string', 'string'], (address, hyperlink) => {\n      return this.hyperlink(address, hyperlink, false);\n    }).case(['string', 'string', 'boolean'], (address, hyperlink, internal) => {\n      const isHyperlinkInternalAddress = internal || addressConverter.fromAddress(hyperlink);\n      let nodeAttributes;\n\n      if (isHyperlinkInternalAddress) {\n        nodeAttributes = {\n          ref: address,\n          location: hyperlink,\n          display: hyperlink\n        };\n      } else {\n        const relationship = this._relationships.add(\"hyperlink\", hyperlink, \"External\");\n\n        nodeAttributes = {\n          ref: address,\n          'r:id': relationship.attributes.Id\n        };\n      }\n\n      this._hyperlinks[address] = {\n        name: 'hyperlink',\n        attributes: nodeAttributes,\n        children: []\n      };\n      return this;\n    }).case(['string', 'object'], (address, opts) => {\n      if (opts instanceof Cell) {\n        const cell = opts;\n        const hyperlink = cell.address({\n          includeSheetName: true\n        });\n        this.hyperlink(address, hyperlink, true);\n      } else if (opts.hyperlink) {\n        this.hyperlink(address, opts.hyperlink);\n      } else if (opts.email) {\n        const email = opts.email;\n        const subject = opts.emailSubject || '';\n        this.hyperlink(address, encodeURI(`mailto:${email}?subject=${subject}`));\n      }\n\n      const hyperlinkNode = this._hyperlinks[address];\n\n      if (hyperlinkNode) {\n        if (opts.tooltip) {\n          hyperlinkNode.attributes.tooltip = opts.tooltip;\n        }\n      }\n\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Increment and return the max shared formula ID.\n   * @returns {number} The new max shared formula ID.\n   * @ignore\n   */\n\n\n  incrementMaxSharedFormulaId() {\n    return ++this._maxSharedFormulaId;\n  }\n  /**\n   * Get a value indicating whether the cells in the given address are merged.\n   * @param {string} address - The address to check.\n   * @returns {boolean} True if merged, false if not merged.\n   * @ignore\n   */\n\n  /**\n  * Merge/unmerge cells by adding/removing a mergeCell entry.\n  * @param {string} address - The address to merge.\n  * @param {boolean} merged - True to merge, false to unmerge.\n  * @returns {Sheet} The sheet.\n  * @ignore\n  */\n\n\n  merged() {\n    return new ArgHandler('Sheet.merge').case('string', address => {\n      return this._mergeCells.hasOwnProperty(address);\n    }).case(['string', '*'], (address, merge) => {\n      if (merge) {\n        this._mergeCells[address] = {\n          name: 'mergeCell',\n          attributes: {\n            ref: address\n          },\n          children: []\n        };\n      } else {\n        delete this._mergeCells[address];\n      }\n\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Gets a Object or undefined of the cells in the given address.\n   * @param {string} address - The address to check.\n   * @returns {object|boolean} Object or false if not set\n   * @ignore\n   */\n\n  /**\n  * Removes dataValidation at the given address\n  * @param {string} address - The address to remove.\n  * @param {boolean} obj - false to delete.\n  * @returns {boolean} true if removed.\n  * @ignore\n  */\n\n  /**\n  * Add dataValidation to cells at the given address if object or string\n  * @param {string} address - The address to set.\n  * @param {object|string} obj - Object or String to set\n  * @returns {Sheet} The sheet.\n  * @ignore\n  */\n\n\n  dataValidation() {\n    return new ArgHandler('Sheet.dataValidation').case('string', address => {\n      if (this._dataValidations[address]) {\n        return {\n          type: this._dataValidations[address].attributes.type,\n          allowBlank: this._dataValidations[address].attributes.allowBlank,\n          showInputMessage: this._dataValidations[address].attributes.showInputMessage,\n          prompt: this._dataValidations[address].attributes.prompt,\n          promptTitle: this._dataValidations[address].attributes.promptTitle,\n          showErrorMessage: this._dataValidations[address].attributes.showErrorMessage,\n          error: this._dataValidations[address].attributes.error,\n          errorTitle: this._dataValidations[address].attributes.errorTitle,\n          operator: this._dataValidations[address].attributes.operator,\n          formula1: this._dataValidations[address].children[0].children[0],\n          formula2: this._dataValidations[address].children[1] ? this._dataValidations[address].children[1].children[0] : undefined\n        };\n      } else {\n        return false;\n      }\n    }).case(['string', 'boolean'], (address, obj) => {\n      if (this._dataValidations[address]) {\n        if (obj === false) return delete this._dataValidations[address];\n      } else {\n        return false;\n      }\n    }).case(['string', '*'], (address, obj) => {\n      if (typeof obj === 'string') {\n        this._dataValidations[address] = {\n          name: 'dataValidation',\n          attributes: {\n            type: 'list',\n            allowBlank: false,\n            showInputMessage: false,\n            prompt: '',\n            promptTitle: '',\n            showErrorMessage: false,\n            error: '',\n            errorTitle: '',\n            operator: '',\n            sqref: address\n          },\n          children: [{\n            name: 'formula1',\n            atrributes: {},\n            children: [obj]\n          }, {\n            name: 'formula2',\n            atrributes: {},\n            children: ['']\n          }]\n        };\n      } else if (typeof obj === 'object') {\n        this._dataValidations[address] = {\n          name: 'dataValidation',\n          attributes: {\n            type: obj.type ? obj.type : 'list',\n            allowBlank: obj.allowBlank,\n            showInputMessage: obj.showInputMessage,\n            prompt: obj.prompt,\n            promptTitle: obj.promptTitle,\n            showErrorMessage: obj.showErrorMessage,\n            error: obj.error,\n            errorTitle: obj.errorTitle,\n            operator: obj.operator,\n            sqref: address\n          },\n          children: [{\n            name: 'formula1',\n            atrributes: {},\n            children: [obj.formula1]\n          }, {\n            name: 'formula2',\n            atrributes: {},\n            children: [obj.formula2]\n          }]\n        };\n      }\n\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Convert the sheet to a collection of XML objects.\n   * @returns {{}} The XML forms.\n   * @ignore\n   */\n\n\n  toXmls() {\n    // Shallow clone the node so we don't have to remove these children later if they don't belong.\n    const node = _.clone(this._node);\n\n    node.children = node.children.slice(); // Add the columns if needed.\n\n    this._colsNode.children = _.filter(this._colNodes, (colNode, i) => {\n      // Columns should only be present if they have attributes other than min/max.\n      return colNode && i === colNode.attributes.min && Object.keys(colNode.attributes).length > 2;\n    });\n\n    if (this._colsNode.children.length) {\n      xmlq.insertInOrder(node, this._colsNode, nodeOrder);\n    } // Add the hyperlinks if needed.\n\n\n    this._hyperlinksNode.children = _.values(this._hyperlinks);\n\n    if (this._hyperlinksNode.children.length) {\n      xmlq.insertInOrder(node, this._hyperlinksNode, nodeOrder);\n    } // Add the printOptions if needed.\n\n\n    if (this._printOptionsNode) {\n      if (Object.keys(this._printOptionsNode.attributes).length) {\n        xmlq.insertInOrder(node, this._printOptionsNode, nodeOrder);\n      }\n    } // Add the pageMargins if needed.\n\n\n    if (this._pageMarginsNode && this._pageMarginsPresetName) {\n      // Clone to preserve the current state of this sheet.\n      const childNode = _.clone(this._pageMarginsNode);\n\n      if (Object.keys(this._pageMarginsNode.attributes).length) {\n        // Fill in any missing attribute values with presets.\n        childNode.attributes = _.assign(this._pageMarginsPresets[this._pageMarginsPresetName], this._pageMarginsNode.attributes);\n      } else {\n        // No need to fill in, all attributes is currently empty, simply replace.\n        childNode.attributes = this._pageMarginsPresets[this._pageMarginsPresetName];\n      }\n\n      xmlq.insertInOrder(node, childNode, nodeOrder);\n    } // Add the merge cells if needed.\n\n\n    this._mergeCellsNode.children = _.values(this._mergeCells);\n\n    if (this._mergeCellsNode.children.length) {\n      xmlq.insertInOrder(node, this._mergeCellsNode, nodeOrder);\n    } // Add the DataValidation cells if needed.\n\n\n    this._dataValidationsNode.children = _.values(this._dataValidations);\n\n    if (this._dataValidationsNode.children.length) {\n      xmlq.insertInOrder(node, this._dataValidationsNode, nodeOrder);\n    }\n\n    if (this._autoFilter) {\n      xmlq.insertInOrder(node, {\n        name: \"autoFilter\",\n        children: [],\n        attributes: {\n          ref: this._autoFilter.address()\n        }\n      }, nodeOrder);\n    } // Add the PageBreaks nodes if needed.\n\n\n    ['colBreaks', 'rowBreaks'].forEach(name => {\n      const breaks = this[`_${name}Node`];\n\n      if (breaks.attributes.count) {\n        xmlq.insertInOrder(node, breaks, nodeOrder);\n      }\n    });\n    return {\n      id: this._idNode,\n      sheet: node,\n      relationships: this._relationships\n    };\n  }\n  /**\n   * Update the max shared formula ID to the given value if greater than current.\n   * @param {number} sharedFormulaId - The new shared formula ID.\n   * @returns {undefined}\n   * @ignore\n   */\n\n\n  updateMaxSharedFormulaId(sharedFormulaId) {\n    if (sharedFormulaId > this._maxSharedFormulaId) {\n      this._maxSharedFormulaId = sharedFormulaId;\n    }\n  }\n  /**\n   * Get the print option given a valid print option attribute.\n   * @param {string} attributeName - Attribute name of the printOptions.\n   *   gridLines - Used in conjunction with gridLinesSet. If both gridLines and gridlinesSet are true, then grid lines shall print. Otherwise, they shall not (i.e., one or both have false values).\n   *   gridLinesSet - Used in conjunction with gridLines. If both gridLines and gridLinesSet are true, then grid lines shall print. Otherwise, they shall not (i.e., one or both have false values).\n   *   headings - Print row and column headings.\n   *   horizontalCentered - Center on page horizontally when printing.\n   *   verticalCentered - Center on page vertically when printing.\n   * @returns {boolean}\n   */\n\n  /**\n  * Set the print option given a valid print option attribute and a value.\n  * @param {string} attributeName - Attribute name of the printOptions. See get print option for list of valid attributes.\n  * @param {undefined|boolean} attributeEnabled - If `undefined` or `false` then the attribute is removed, otherwise the print option is enabled.\n  * @returns {Sheet} The sheet.\n  */\n\n\n  printOptions() {\n    const supportedAttributeNames = ['gridLines', 'gridLinesSet', 'headings', 'horizontalCentered', 'verticalCentered'];\n\n    const checkAttributeName = this._getCheckAttributeNameHelper('printOptions', supportedAttributeNames);\n\n    return new ArgHandler('Sheet.printOptions').case(['string'], attributeName => {\n      checkAttributeName(attributeName);\n      return this._printOptionsNode.attributes[attributeName] === 1;\n    }).case(['string', 'nil'], attributeName => {\n      checkAttributeName(attributeName);\n      delete this._printOptionsNode.attributes[attributeName];\n      return this;\n    }).case(['string', 'boolean'], (attributeName, attributeEnabled) => {\n      checkAttributeName(attributeName);\n\n      if (attributeEnabled) {\n        this._printOptionsNode.attributes[attributeName] = 1;\n        return this;\n      } else {\n        return this.printOptions(attributeName, undefined);\n      }\n    }).handle(arguments);\n  }\n  /**\n   * Get the print option for the gridLines attribute value.\n   * @returns {boolean}\n   */\n\n  /**\n  * Set the print option for the gridLines attribute value.\n  * @param {undefined|boolean} enabled - If `undefined` or `false` then attribute is removed, otherwise gridLines is enabled.\n  * @returns {Sheet} The sheet.\n  */\n\n\n  printGridLines() {\n    return new ArgHandler('Sheet.gridLines').case(() => {\n      return this.printOptions('gridLines') && this.printOptions('gridLinesSet');\n    }).case(['nil'], () => {\n      this.printOptions('gridLines', undefined);\n      this.printOptions('gridLinesSet', undefined);\n      return this;\n    }).case(['boolean'], enabled => {\n      this.printOptions('gridLines', enabled);\n      this.printOptions('gridLinesSet', enabled);\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Get the page margin given a valid attribute name.\n   * If the value is not yet defined, then it will return the current preset value.\n   * @param {string} attributeName - Attribute name of the pageMargins.\n   *     left - Left Page Margin in inches.\n   *     right - Right page margin in inches.\n   *     top - Top Page Margin in inches.\n   *     buttom - Bottom Page Margin in inches.\n   *     footer - Footer Page Margin in inches.\n   *     header - Header Page Margin in inches.\n   * @returns {number} the attribute value.\n   */\n\n  /**\n  * Set the page margin (or override the preset) given an attribute name and a value.\n  * @param {string} attributeName - Attribute name of the pageMargins. See get page margin for list of valid attributes.\n  * @param {undefined|number|string} attributeStringValue - If `undefined` then set back to preset value, otherwise, set the given attribute value.\n  * @returns {Sheet} The sheet.\n  */\n\n\n  pageMargins() {\n    if (this.pageMarginsPreset() === undefined) {\n      throw new Error('Sheet.pageMargins: preset is undefined.');\n    }\n\n    const supportedAttributeNames = ['left', 'right', 'top', 'bottom', 'header', 'footer'];\n\n    const checkAttributeName = this._getCheckAttributeNameHelper('pageMargins', supportedAttributeNames);\n\n    const checkRange = this._getCheckRangeHelper('pageMargins', 0, undefined);\n\n    return new ArgHandler('Sheet.pageMargins').case(['string'], attributeName => {\n      checkAttributeName(attributeName);\n      const attributeValue = this._pageMarginsNode.attributes[attributeName];\n\n      if (attributeValue !== undefined) {\n        return parseFloat(attributeValue);\n      } else if (this._pageMarginsPresetName) {\n        return parseFloat(this._pageMarginsPresets[this._pageMarginsPresetName][attributeName]);\n      } else {\n        return undefined;\n      }\n    }).case(['string', 'nil'], attributeName => {\n      checkAttributeName(attributeName);\n      delete this._pageMarginsNode.attributes[attributeName];\n      return this;\n    }).case(['string', 'number'], (attributeName, attributeNumberValue) => {\n      checkAttributeName(attributeName);\n      checkRange(attributeNumberValue);\n      this._pageMarginsNode.attributes[attributeName] = attributeNumberValue;\n      return this;\n    }).case(['string', 'string'], (attributeName, attributeStringValue) => {\n      return this.pageMargins(attributeName, parseFloat(attributeStringValue));\n    }).handle(arguments);\n  }\n  /**\n   * Page margins preset is a set of page margins associated with a name.\n   * The page margin preset acts as a fallback when not explicitly defined by `Sheet.pageMargins`.\n   * If a sheet already contains page margins, it attempts to auto-detect, otherwise they are defined as the template preset.\n   * If no page margins exist, then the preset is undefined and will not be included in the output of `Sheet.toXmls`.\n   * Available presets include: normal, wide, narrow, template.\n   *\n   * Get the page margins preset name. The registered name of a predefined set of attributes.\n   * @returns {string} The preset name.\n   */\n\n  /**\n  * Set the page margins preset by name, clearing any existing/temporary attribute values.\n  * @param {undefined|string} presetName - The preset name. If `undefined`, page margins will not be included in the output of `Sheet.toXmls`.\n  * @returns {Sheet} The sheet.\n  */\n\n  /**\n  * Set a new page margins preset by name and attributes object.\n  * @param {string} presetName - The preset name.\n  * @param {object} presetAttributes - The preset attributes.\n  * @returns {Sheet} The sheet.\n  */\n\n\n  pageMarginsPreset() {\n    return new ArgHandler('Sheet.pageMarginsPreset').case(() => {\n      return this._pageMarginsPresetName;\n    }).case(['nil'], () => {\n      // Remove all preset overrides and exclude from sheet\n      this._pageMarginsPresetName = undefined; // Remove all preset overrides\n\n      this._pageMarginsNode.attributes = {};\n      return this;\n    }).case(['string'], presetName => {\n      const checkPresetName = this._getCheckAttributeNameHelper('pageMarginsPreset', Object.keys(this._pageMarginsPresets));\n\n      checkPresetName(presetName); // Change to new preset\n\n      this._pageMarginsPresetName = presetName; // Remove all preset overrides\n\n      this._pageMarginsNode.attributes = {};\n      return this;\n    }).case(['string', 'object'], (presetName, presetAttributes) => {\n      if (this._pageMarginsPresets.hasOwnProperty(presetName)) {\n        throw new Error(`Sheet.pageMarginsPreset: The preset ${presetName} already exists!`);\n      } // Validate preset attribute keys.\n\n\n      const pageMarginsAttributeNames = ['left', 'right', 'top', 'bottom', 'header', 'footer'];\n\n      const isValidPresetAttributeKeys = _.isEqual(_.sortBy(pageMarginsAttributeNames), _.sortBy(Object.keys(presetAttributes)));\n\n      if (isValidPresetAttributeKeys === false) {\n        throw new Error(`Sheet.pageMarginsPreset: Invalid preset attributes for one or key(s)! - \"${Object.keys(presetAttributes)}\"`);\n      } // Validate preset attribute values.\n\n\n      _.forEach((attributeValue, attributeName) => {\n        const attributeNumberValue = parseFloat(attributeValue);\n\n        if (_.isNaN(attributeNumberValue) || _.isNumber(attributeNumberValue) === false) {\n          throw new Error(`Sheet.pageMarginsPreset: Invalid preset attribute value! - \"${attributeValue}\"`);\n        }\n      }); // Change to new preset\n\n\n      this._pageMarginsPresetName = presetName; // Remove all preset overrides\n\n      this._pageMarginsNode.attributes = {}; // Register the preset\n\n      this._pageMarginsPresets[presetName] = presetAttributes;\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * https://docs.microsoft.com/en-us/dotnet/api/documentformat.openxml.spreadsheet.pane?view=openxml-2.8.1\n   * @typedef {Object} PaneOptions\n   * @property {string} activePane=bottomRight Active Pane. The pane that is active.\n   * @property {string} state Split State. Indicates whether the pane has horizontal / vertical splits,\n   * and whether those splits are frozen.\n   * @property {string} topLeftCell Top Left Visible Cell. Location of the top left visible cell in the bottom\n   * right pane (when in Left-To-Right mode).\n   * @property {number} xSplit (Horizontal Split Position) Horizontal position of the split, in 1/20th of a point;\n   * 0 (zero) if none. If the pane is frozen, this value indicates the number of columns visible in the top pane.\n   * @property {number} ySplit (Vertical Split Position) Vertical position of the split, in 1/20th of a point; 0\n   * (zero) if none. If the pane is frozen, this value indicates the number of rows visible in the left pane.\n   */\n\n  /**\n  * Gets sheet view pane options\n  * @return {PaneOptions} sheet view pane options\n  */\n\n  /**\n  * Sets sheet view pane options\n  * @param {PaneOptions|null|undefined} paneOptions sheet view pane options\n  * @return {Sheet} The sheet\n  */\n\n\n  panes() {\n    const supportedStates = ['split', 'frozen', 'frozenSplit'];\n    const supportedActivePanes = ['bottomLeft', 'bottomRight', 'topLeft', 'topRight'];\n\n    const checkStateName = this._getCheckAttributeNameHelper('pane.state', supportedStates);\n\n    const checkActivePane = this._getCheckAttributeNameHelper('pane.activePane', supportedActivePanes);\n\n    const sheetViewNode = this._getOrCreateSheetViewNode();\n\n    let paneNode = xmlq.findChild(sheetViewNode, 'pane');\n    return new ArgHandler('Sheet.pane').case(() => {\n      if (paneNode) {\n        const result = _.cloneDeep(paneNode.attributes);\n\n        if (!result.state) result.state = 'split';\n        return result;\n      }\n    }).case(['nil'], () => {\n      xmlq.removeChild(sheetViewNode, 'pane');\n      return this;\n    }).case(['object'], paneAttributes => {\n      const attributes = _.assign({\n        activePane: 'bottomRight'\n      }, paneAttributes);\n\n      checkStateName(attributes.state);\n      checkActivePane(attributes.activePane);\n\n      if (paneNode) {\n        paneNode.attributes = attributes;\n      } else {\n        paneNode = {\n          name: \"pane\",\n          attributes,\n          children: []\n        };\n        xmlq.appendChild(sheetViewNode, paneNode);\n      }\n\n      return this;\n    }).handle(arguments);\n  }\n  /**\n   * Freezes Panes for this sheet.\n   * @param {number} xSplit the number of columns visible in the top pane. 0 (zero) if none.\n   * @param {number} ySplit the number of rows visible in the left pane. 0 (zero) if none.\n   * @return {Sheet} The sheet\n   */\n\n  /**\n  * freezes Panes for this sheet.\n  * @param {string} topLeftCell Top Left Visible Cell. Location of the top left visible cell in the bottom\n  * right pane (when in Left-To-Right mode).\n  * @return {Sheet} The sheet\n  */\n\n\n  freezePanes() {\n    return new ArgHandler('Sheet.feezePanes').case(['integer', 'integer'], (xSplit, ySplit) => {\n      const topLeftCell = addressConverter.columnNumberToName(xSplit + 1) + (ySplit + 1);\n      let activePane = xSplit === 0 ? 'bottomLeft' : 'bottomRight';\n      activePane = ySplit === 0 ? 'topRight' : activePane;\n      return this.panes({\n        state: 'frozen',\n        topLeftCell,\n        xSplit,\n        ySplit,\n        activePane\n      });\n    }).case(['string'], topLeftCell => {\n      const ref = addressConverter.fromAddress(topLeftCell);\n      const xSplit = ref.columnNumber - 1,\n            ySplit = ref.rowNumber - 1;\n      let activePane = xSplit === 0 ? 'bottomLeft' : 'bottomRight';\n      activePane = ySplit === 0 ? 'topRight' : activePane;\n      return this.panes({\n        state: 'frozen',\n        topLeftCell,\n        xSplit,\n        ySplit,\n        activePane\n      });\n    }).handle(arguments);\n  }\n  /**\n   * Splits Panes for this sheet.\n   * @param {number} xSplit (Horizontal Split Position) Horizontal position of the split,\n   * in 1/20th of a point; 0 (zero) if none.\n   * @param {number} ySplit (Vertical Split Position) VVertical position of the split,\n   * in 1/20th of a point; 0 (zero) if none.\n   * @return {Sheet} The sheet\n   */\n\n\n  splitPanes(xSplit, ySplit) {\n    return this.panes({\n      state: 'split',\n      xSplit,\n      ySplit\n    });\n  }\n  /**\n   * resets to default sheet view panes.\n   * @return {Sheet} The sheet\n   */\n\n\n  resetPanes() {\n    return this.panes(null);\n  }\n  /* PRIVATE */\n\n  /**\n   * Get a helper function to check that the attribute name provided is supported.\n   * @param {string} functionName - Name of the parent function.\n   * @param {array} supportedAttributeNames - Array of supported attribute name strings.\n   * @returns {function} The helper function, which takes an attribute name. If the array of supported attribute names does not contain the given attribute name, then an Error is thrown.\n   * @ignore\n   */\n\n\n  _getCheckAttributeNameHelper(functionName, supportedAttributeNames) {\n    return attributeName => {\n      if (!_.includes(supportedAttributeNames, attributeName)) {\n        throw new Error(`Sheet.${functionName}: \"${attributeName}\" is not supported.`);\n      }\n    };\n  }\n  /**\n   * Get a helper function to check that the value is of the expected type.\n   * @param {string} functionName - Name of the parent function.\n   * @param {string} valueType - A string produced by typeof.\n   * @returns {function} The helper function, which takes a value. If the value type is not expected, a TypeError is thrown.\n   * @ignore\n   */\n\n\n  _getCheckTypeHelper(functionName, valueType) {\n    return value => {\n      if (typeof value !== valueType) {\n        throw new TypeError(`Sheet.${functionName}: invalid type - value must be of type ${valueType}.`);\n      }\n    };\n  }\n  /**\n   * Get a helper function to check that the value is within the expected range.\n   * @param {string} functionName - Name of the parent function.\n   * @param {undefined|number} valueMin - The minimum value of the range. This value is range-inclusive.\n   * @param {undefined|number} valueMax - The maximum value of the range. This value is range-exclusive.\n   * @returns {function} The helper function, which takes a value. If the value type is not 'number', a TypeError is thrown. If the value is not within the range, a RangeError is thrown.\n   * @ignore\n   */\n\n\n  _getCheckRangeHelper(functionName, valueMin, valueMax) {\n    const checkType = this._getCheckTypeHelper(functionName, 'number');\n\n    return value => {\n      checkType(value);\n\n      if (valueMin !== undefined) {\n        if (value < valueMin) {\n          throw new RangeError(`Sheet.${functionName}: value too small - value must be greater than or equal to ${valueMin}.`);\n        }\n      }\n\n      if (valueMax !== undefined) {\n        if (valueMax <= value) {\n          throw new RangeError(`Sheet.${functionName}: value too large - value must be less than ${valueMax}.`);\n        }\n      }\n    };\n  }\n  /**\n   * Get the sheet view node if it exists or create it if it doesn't.\n   * @returns {{}} The sheet view node.\n   * @private\n   */\n\n\n  _getOrCreateSheetViewNode() {\n    let sheetViewsNode = xmlq.findChild(this._node, \"sheetViews\");\n\n    if (!sheetViewsNode) {\n      sheetViewsNode = {\n        name: \"sheetViews\",\n        attributes: {},\n        children: [{\n          name: \"sheetView\",\n          attributes: {\n            workbookViewId: 0\n          },\n          children: []\n        }]\n      };\n      xmlq.insertInOrder(this._node, sheetViewsNode, nodeOrder);\n    }\n\n    return xmlq.findChild(sheetViewsNode, \"sheetView\");\n  }\n  /**\n   * Initializes the sheet.\n   * @param {Workbook} workbook - The parent workbook.\n   * @param {{}} idNode - The sheet ID node (from the parent workbook).\n   * @param {{}} node - The sheet node.\n   * @param {{}} [relationshipsNode] - The optional sheet relationships node.\n   * @returns {undefined}\n   * @private\n   */\n\n\n  _init(workbook, idNode, node, relationshipsNode) {\n    if (!node) {\n      node = {\n        name: \"worksheet\",\n        attributes: {\n          xmlns: \"http://schemas.openxmlformats.org/spreadsheetml/2006/main\",\n          'xmlns:r': \"http://schemas.openxmlformats.org/officeDocument/2006/relationships\",\n          'xmlns:mc': \"http://schemas.openxmlformats.org/markup-compatibility/2006\",\n          'mc:Ignorable': \"x14ac\",\n          'xmlns:x14ac': \"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\"\n        },\n        children: [{\n          name: \"sheetData\",\n          attributes: {},\n          children: []\n        }]\n      };\n    }\n\n    this._workbook = workbook;\n    this._idNode = idNode;\n    this._node = node;\n    this._maxSharedFormulaId = -1;\n    this._mergeCells = {};\n    this._dataValidations = {};\n    this._hyperlinks = {};\n    this._autoFilter = null; // Create the relationships.\n\n    this._relationships = new Relationships(relationshipsNode); // Delete the optional dimension node\n\n    xmlq.removeChild(this._node, \"dimension\"); // Create the rows.\n\n    this._rows = [];\n    this._sheetDataNode = xmlq.findChild(this._node, \"sheetData\");\n\n    this._sheetDataNode.children.forEach(rowNode => {\n      const row = new Row(this, rowNode);\n      this._rows[row.rowNumber()] = row;\n    });\n\n    this._sheetDataNode.children = this._rows; // Create the columns node.\n\n    this._columns = [];\n    this._colsNode = xmlq.findChild(this._node, \"cols\");\n\n    if (this._colsNode) {\n      xmlq.removeChild(this._node, this._colsNode);\n    } else {\n      this._colsNode = {\n        name: 'cols',\n        attributes: {},\n        children: []\n      };\n    } // Cache the col nodes.\n\n\n    this._colNodes = [];\n\n    _.forEach(this._colsNode.children, colNode => {\n      const min = colNode.attributes.min;\n      const max = colNode.attributes.max;\n\n      for (let i = min; i <= max; i++) {\n        this._colNodes[i] = colNode;\n      }\n    }); // Create the sheet properties node.\n\n\n    this._sheetPrNode = xmlq.findChild(this._node, \"sheetPr\");\n\n    if (!this._sheetPrNode) {\n      this._sheetPrNode = {\n        name: 'sheetPr',\n        attributes: {},\n        children: []\n      };\n      xmlq.insertInOrder(this._node, this._sheetPrNode, nodeOrder);\n    } // Create the merge cells.\n\n\n    this._mergeCellsNode = xmlq.findChild(this._node, \"mergeCells\");\n\n    if (this._mergeCellsNode) {\n      xmlq.removeChild(this._node, this._mergeCellsNode);\n    } else {\n      this._mergeCellsNode = {\n        name: 'mergeCells',\n        attributes: {},\n        children: []\n      };\n    }\n\n    const mergeCellNodes = this._mergeCellsNode.children;\n    this._mergeCellsNode.children = [];\n    mergeCellNodes.forEach(mergeCellNode => {\n      this._mergeCells[mergeCellNode.attributes.ref] = mergeCellNode;\n    }); // Create the DataValidations.\n\n    this._dataValidationsNode = xmlq.findChild(this._node, \"dataValidations\");\n\n    if (this._dataValidationsNode) {\n      xmlq.removeChild(this._node, this._dataValidationsNode);\n    } else {\n      this._dataValidationsNode = {\n        name: 'dataValidations',\n        attributes: {},\n        children: []\n      };\n    }\n\n    const dataValidationNodes = this._dataValidationsNode.children;\n    this._dataValidationsNode.children = [];\n    dataValidationNodes.forEach(dataValidationNode => {\n      this._dataValidations[dataValidationNode.attributes.sqref] = dataValidationNode;\n    }); // Create the hyperlinks.\n\n    this._hyperlinksNode = xmlq.findChild(this._node, \"hyperlinks\");\n\n    if (this._hyperlinksNode) {\n      xmlq.removeChild(this._node, this._hyperlinksNode);\n    } else {\n      this._hyperlinksNode = {\n        name: 'hyperlinks',\n        attributes: {},\n        children: []\n      };\n    }\n\n    const hyperlinkNodes = this._hyperlinksNode.children;\n    this._hyperlinksNode.children = [];\n    hyperlinkNodes.forEach(hyperlinkNode => {\n      this._hyperlinks[hyperlinkNode.attributes.ref] = hyperlinkNode;\n    }); // Create the printOptions.\n\n    this._printOptionsNode = xmlq.findChild(this._node, \"printOptions\");\n\n    if (this._printOptionsNode) {\n      xmlq.removeChild(this._node, this._printOptionsNode);\n    } else {\n      this._printOptionsNode = {\n        name: 'printOptions',\n        attributes: {},\n        children: []\n      };\n    } // Create the pageMargins.\n\n\n    this._pageMarginsPresets = {\n      normal: {\n        left: 0.7,\n        right: 0.7,\n        top: 0.75,\n        bottom: 0.75,\n        header: 0.3,\n        footer: 0.3\n      },\n      wide: {\n        left: 1,\n        right: 1,\n        top: 1,\n        bottom: 1,\n        header: 0.5,\n        footer: 0.5\n      },\n      narrow: {\n        left: 0.25,\n        right: 0.25,\n        top: 0.75,\n        bottom: 0.75,\n        header: 0.3,\n        footer: 0.3\n      }\n    };\n    this._pageMarginsNode = xmlq.findChild(this._node, \"pageMargins\");\n\n    if (this._pageMarginsNode) {\n      // Sheet has page margins, assume preset is template.\n      this._pageMarginsPresetName = 'template'; // Search for a preset that matches existing attributes.\n\n      for (const presetName in this._pageMarginsPresets) {\n        if (_.isEqual(this._pageMarginsNode.attributes, this._pageMarginsPresets[presetName])) {\n          this._pageMarginsPresetName = presetName;\n          break;\n        }\n      } // If template preset, then register as template preset, and clear attributes.\n\n\n      if (this._pageMarginsPresetName === 'template') {\n        this._pageMarginsPresets.template = this._pageMarginsNode.attributes;\n        this._pageMarginsNode.attributes = {};\n      }\n\n      xmlq.removeChild(this._node, this._pageMarginsNode);\n    } else {\n      // Sheet has no page margins, the preset assignment is therefore undefined.\n      this._pageMarginsPresetName = undefined;\n      this._pageMarginsNode = {\n        name: 'pageMargins',\n        attributes: {},\n        children: []\n      };\n    } // Create the pageBreaks\n\n\n    ['colBreaks', 'rowBreaks'].forEach(name => {\n      this[`_${name}Node`] = xmlq.findChild(this._node, name);\n\n      if (this[`_${name}Node`]) {\n        xmlq.removeChild(this._node, this[`_${name}Node`]);\n      } else {\n        this[`_${name}Node`] = {\n          name,\n          children: [],\n          attributes: {\n            count: 0,\n            manualBreakCount: 0\n          }\n        };\n      }\n    });\n    this._pageBreaks = {\n      colBreaks: new PageBreaks(this._colBreaksNode),\n      rowBreaks: new PageBreaks(this._rowBreaksNode)\n    };\n  }\n\n}\n\nmodule.exports = Sheet;\n/*\nxl/workbook.xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<worksheet ...>\n    ...\n\n    <printOptions headings=\"1\" gridLines=\"1\" />\n    <pageMargins left=\"0.7\" right=\"0.7\" top=\"0.75\" bottom=\"0.75\" header=\"0.3\" footer=\"0.3\" />\n    <pageSetup orientation=\"portrait\" horizontalDpi=\"0\" verticalDpi=\"0\" />\n</worksheet>\n// */","map":{"version":3,"names":["_","require","Cell","Row","Column","Range","Relationships","xmlq","regexify","addressConverter","ArgHandler","colorIndexes","PageBreaks","nodeOrder","Sheet","constructor","workbook","idNode","node","relationshipsNode","_init","active","case","activeSheet","Error","handle","arguments","activeCell","sheetViewNode","_getOrCreateSheetViewNode","selectionNode","findChild","cellAddress","attributes","cell","rowNumber","columnNameOrNumber","name","children","appendChild","sqref","address","ref","fromAddress","type","row","columnNumber","column","columnNameToNumber","_columns","existingColNode","_colNodes","colNode","min","beforeColNode","cloneDeep","max","i","afterColNode","definedName","scopedDefinedName","refersTo","delete","deleteSheet","find","pattern","replacement","matches","_rows","forEach","concat","gridLinesVisible","showGridLines","undefined","visible","hidden","_idNode","state","visibleSheets","filter","sheets","sheet","length","activeIndex","move","indexOrBeforeSheet","moveSheet","range","startRowNumber","startColumnNumber","endRowNumber","endColumnNumber","startCell","endCell","startColumnNameOrNumber","endColumnNameOrNumber","autoFilter","_autoFilter","RangeError","rowNode","r","tabColor","tabColorNode","_sheetPrNode","color","hasOwnProperty","rgb","theme","indexed","tint","removeChild","appendChildIfNotFound","setAttributes","toUpperCase","tabSelected","selected","rightToLeft","rtl","usedRange","minRowNumber","findIndex","maxRowNumber","minColumnNumber","maxColumnNumber","minUsedColumnNumber","maxUsedColumnNumber","_workbook","pageBreaks","_pageBreaks","verticalPageBreaks","colBreaks","horizontalPageBreaks","rowBreaks","clearCellsUsingSharedFormula","sharedFormulaId","existingColumnStyleId","style","forEachExistingColumnNumber","callback","forEachExistingRow","hyperlink","hyperlinkNode","_hyperlinks","relationship","_relationships","findById","Target","internal","isHyperlinkInternalAddress","nodeAttributes","location","display","add","Id","opts","includeSheetName","email","subject","emailSubject","encodeURI","tooltip","incrementMaxSharedFormulaId","_maxSharedFormulaId","merged","_mergeCells","merge","dataValidation","_dataValidations","allowBlank","showInputMessage","prompt","promptTitle","showErrorMessage","error","errorTitle","operator","formula1","formula2","obj","atrributes","toXmls","clone","_node","slice","_colsNode","Object","keys","insertInOrder","_hyperlinksNode","values","_printOptionsNode","_pageMarginsNode","_pageMarginsPresetName","childNode","assign","_pageMarginsPresets","_mergeCellsNode","_dataValidationsNode","breaks","count","id","relationships","updateMaxSharedFormulaId","printOptions","supportedAttributeNames","checkAttributeName","_getCheckAttributeNameHelper","attributeName","attributeEnabled","printGridLines","enabled","pageMargins","pageMarginsPreset","checkRange","_getCheckRangeHelper","attributeValue","parseFloat","attributeNumberValue","attributeStringValue","presetName","checkPresetName","presetAttributes","pageMarginsAttributeNames","isValidPresetAttributeKeys","isEqual","sortBy","isNaN","isNumber","panes","supportedStates","supportedActivePanes","checkStateName","checkActivePane","paneNode","result","paneAttributes","activePane","freezePanes","xSplit","ySplit","topLeftCell","columnNumberToName","splitPanes","resetPanes","functionName","includes","_getCheckTypeHelper","valueType","value","TypeError","valueMin","valueMax","checkType","sheetViewsNode","workbookViewId","xmlns","_sheetDataNode","mergeCellNodes","mergeCellNode","dataValidationNodes","dataValidationNode","hyperlinkNodes","normal","left","right","top","bottom","header","footer","wide","narrow","template","manualBreakCount","_colBreaksNode","_rowBreaksNode","module","exports"],"sources":["/Users/stichtinghelden/Documents/GitHub/de_verdwenen_ceo/node_modules/xlsx-populate/lib/Sheet.js"],"sourcesContent":["\"use strict\";\n\nconst _ = require(\"lodash\");\nconst Cell = require(\"./Cell\");\nconst Row = require(\"./Row\");\nconst Column = require(\"./Column\");\nconst Range = require(\"./Range\");\nconst Relationships = require(\"./Relationships\");\nconst xmlq = require(\"./xmlq\");\nconst regexify = require(\"./regexify\");\nconst addressConverter = require(\"./addressConverter\");\nconst ArgHandler = require(\"./ArgHandler\");\nconst colorIndexes = require(\"./colorIndexes\");\nconst PageBreaks = require(\"./PageBreaks\");\n\n// Order of the nodes as defined by the spec.\nconst nodeOrder = [\n    \"sheetPr\", \"dimension\", \"sheetViews\", \"sheetFormatPr\", \"cols\", \"sheetData\",\n    \"sheetCalcPr\", \"sheetProtection\", \"autoFilter\", \"protectedRanges\", \"scenarios\", \"autoFilter\",\n    \"sortState\", \"dataConsolidate\", \"customSheetViews\", \"mergeCells\", \"phoneticPr\",\n    \"conditionalFormatting\", \"dataValidations\", \"hyperlinks\", \"printOptions\",\n    \"pageMargins\", \"pageSetup\", \"headerFooter\", \"rowBreaks\", \"colBreaks\",\n    \"customProperties\", \"cellWatches\", \"ignoredErrors\", \"smartTags\", \"drawing\",\n    \"drawingHF\", \"legacyDrawing\", \"legacyDrawingHF\", \"picture\", \"oleObjects\", \"controls\", \"webPublishItems\", \"tableParts\",\n    \"extLst\"\n];\n\n/**\n * A worksheet.\n */\nclass Sheet {\n    // /**\n    //  * Creates a new instance of Sheet.\n    //  * @param {Workbook} workbook - The parent workbook.\n    //  * @param {{}} idNode - The sheet ID node (from the parent workbook).\n    //  * @param {{}} node - The sheet node.\n    //  * @param {{}} [relationshipsNode] - The optional sheet relationships node.\n    //  */\n    constructor(workbook, idNode, node, relationshipsNode) {\n        this._init(workbook, idNode, node, relationshipsNode);\n    }\n\n    /* PUBLIC */\n\n    /**\n     * Gets a value indicating whether the sheet is the active sheet in the workbook.\n     * @returns {boolean} True if active, false otherwise.\n     *//**\n     * Make the sheet the active sheet in the workkbok.\n     * @param {boolean} active - Must be set to `true`. Deactivating directly is not supported. To deactivate, you should activate a different sheet instead.\n     * @returns {Sheet} The sheet.\n     */\n    active() {\n        return new ArgHandler('Sheet.active')\n            .case(() => {\n                return this.workbook().activeSheet() === this;\n            })\n            .case('boolean', active => {\n                if (!active) throw new Error(\"Deactivating sheet directly not supported. Activate a different sheet instead.\");\n                this.workbook().activeSheet(this);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the active cell in the sheet.\n     * @returns {Cell} The active cell.\n     *//**\n     * Set the active cell in the workbook.\n     * @param {string|Cell} cell - The cell or address of cell to activate.\n     * @returns {Sheet} The sheet.\n     *//**\n     * Set the active cell in the workbook by row and column.\n     * @param {number} rowNumber - The row number of the cell.\n     * @param {string|number} columnNameOrNumber - The column name or number of the cell.\n     * @returns {Sheet} The sheet.\n     */\n    activeCell() {\n        const sheetViewNode = this._getOrCreateSheetViewNode();\n        let selectionNode = xmlq.findChild(sheetViewNode, \"selection\");\n        return new ArgHandler('Sheet.activeCell')\n            .case(() => {\n                const cellAddress = selectionNode ? selectionNode.attributes.activeCell : \"A1\";\n                return this.cell(cellAddress);\n            })\n            .case(['number', '*'], (rowNumber, columnNameOrNumber) => {\n                const cell = this.cell(rowNumber, columnNameOrNumber);\n                return this.activeCell(cell);\n            })\n            .case('*', cell => {\n                if (!selectionNode) {\n                    selectionNode = {\n                        name: \"selection\",\n                        attributes: {},\n                        children: []\n                    };\n\n                    xmlq.appendChild(sheetViewNode, selectionNode);\n                }\n\n                if (!(cell instanceof Cell)) cell = this.cell(cell);\n                selectionNode.attributes.activeCell = selectionNode.attributes.sqref = cell.address();\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets the cell with the given address.\n     * @param {string} address - The address of the cell.\n     * @returns {Cell} The cell.\n     *//**\n     * Gets the cell with the given row and column numbers.\n     * @param {number} rowNumber - The row number of the cell.\n     * @param {string|number} columnNameOrNumber - The column name or number of the cell.\n     * @returns {Cell} The cell.\n     */\n    cell() {\n        return new ArgHandler('Sheet.cell')\n            .case('string', address => {\n                const ref = addressConverter.fromAddress(address);\n                if (ref.type !== 'cell') throw new Error('Sheet.cell: Invalid address.');\n                return this.row(ref.rowNumber).cell(ref.columnNumber);\n            })\n            .case(['number', '*'], (rowNumber, columnNameOrNumber) => {\n                return this.row(rowNumber).cell(columnNameOrNumber);\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets a column in the sheet.\n     * @param {string|number} columnNameOrNumber - The name or number of the column.\n     * @returns {Column} The column.\n     */\n    column(columnNameOrNumber) {\n        const columnNumber = typeof columnNameOrNumber === \"string\" ? addressConverter.columnNameToNumber(columnNameOrNumber) : columnNameOrNumber;\n\n        // If we're already created a column for this column number, return it.\n        if (this._columns[columnNumber]) return this._columns[columnNumber];\n\n        // We need to create a new column, which requires a backing col node. There may already exist a node whose min/max cover our column.\n        // First, see if there is an existing col node.\n        const existingColNode = this._colNodes[columnNumber];\n\n        let colNode;\n        if (existingColNode) {\n            // If the existing node covered earlier columns than the new one, we need to have a col node to cover the min up to our new node.\n            if (existingColNode.attributes.min < columnNumber) {\n                // Clone the node and set the max to the column before our new col.\n                const beforeColNode = _.cloneDeep(existingColNode);\n                beforeColNode.attributes.max = columnNumber - 1;\n\n                // Update the col nodes cache.\n                for (let i = beforeColNode.attributes.min; i <= beforeColNode.attributes.max; i++) {\n                    this._colNodes[i] = beforeColNode;\n                }\n            }\n\n            // Make a clone for the new column. Set the min/max to the column number and cache it.\n            colNode = _.cloneDeep(existingColNode);\n            colNode.attributes.min = columnNumber;\n            colNode.attributes.max = columnNumber;\n            this._colNodes[columnNumber] = colNode;\n\n            // If the max of the existing node is greater than the nre one, create a col node for that too.\n            if (existingColNode.attributes.max > columnNumber) {\n                const afterColNode = _.cloneDeep(existingColNode);\n                afterColNode.attributes.min = columnNumber + 1;\n                for (let i = afterColNode.attributes.min; i <= afterColNode.attributes.max; i++) {\n                    this._colNodes[i] = afterColNode;\n                }\n            }\n        } else {\n            // The was no existing node so create a new one.\n            colNode = {\n                name: 'col',\n                attributes: {\n                    min: columnNumber,\n                    max: columnNumber\n                },\n                children: []\n            };\n\n            this._colNodes[columnNumber] = colNode;\n        }\n\n        // Create the new column and cache it.\n        const column = new Column(this, colNode);\n        this._columns[columnNumber] = column;\n        return column;\n    }\n\n    /**\n     * Gets a defined name scoped to the sheet.\n     * @param {string} name - The defined name.\n     * @returns {undefined|string|Cell|Range|Row|Column} What the defined name refers to or undefined if not found. Will return the string formula if not a Row, Column, Cell, or Range.\n     *//**\n     * Set a defined name scoped to the sheet.\n     * @param {string} name - The defined name.\n     * @param {string|Cell|Range|Row|Column} refersTo - What the name refers to.\n     * @returns {Workbook} The workbook.\n     */\n    definedName() {\n        return new ArgHandler(\"Workbook.definedName\")\n            .case('string', name => {\n                return this.workbook().scopedDefinedName(this, name);\n            })\n            .case(['string', '*'], (name, refersTo) => {\n                this.workbook().scopedDefinedName(this, name, refersTo);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Deletes the sheet and returns the parent workbook.\n     * @returns {Workbook} The workbook.\n     */\n    delete() {\n        this.workbook().deleteSheet(this);\n        return this.workbook();\n    }\n\n    /**\n     * Find the given pattern in the sheet and optionally replace it.\n     * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n     * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in each cell will be replaced.\n     * @returns {Array.<Cell>} The matching cells.\n     */\n    find(pattern, replacement) {\n        pattern = regexify(pattern);\n\n        let matches = [];\n        this._rows.forEach(row => {\n            if (!row) return;\n            matches = matches.concat(row.find(pattern, replacement));\n        });\n\n        return matches;\n    }\n\n    /**\n     * Gets a value indicating whether this sheet's grid lines are visible.\n     * @returns {boolean} True if selected, false if not.\n     *//**\n     * Sets whether this sheet's grid lines are visible.\n     * @param {boolean} selected - True to make visible, false to hide.\n     * @returns {Sheet} The sheet.\n     */\n    gridLinesVisible() {\n        const sheetViewNode = this._getOrCreateSheetViewNode();\n        return new ArgHandler('Sheet.gridLinesVisible')\n            .case(() => {\n                return sheetViewNode.attributes.showGridLines === 1 || sheetViewNode.attributes.showGridLines === undefined;\n            })\n            .case('boolean', visible => {\n                sheetViewNode.attributes.showGridLines = visible ? 1 : 0;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets a value indicating if the sheet is hidden or not.\n     * @returns {boolean|string} True if hidden, false if visible, and 'very' if very hidden.\n     *//**\n     * Set whether the sheet is hidden or not.\n     * @param {boolean|string} hidden - True to hide, false to show, and 'very' to make very hidden.\n     * @returns {Sheet} The sheet.\n     */\n    hidden() {\n        return new ArgHandler('Sheet.hidden')\n            .case(() => {\n                if (this._idNode.attributes.state === 'hidden') return true;\n                if (this._idNode.attributes.state === 'veryHidden') return \"very\";\n                return false;\n            })\n            .case('*', hidden => {\n                if (hidden) {\n                    const visibleSheets = _.filter(this.workbook().sheets(), sheet => !sheet.hidden());\n                    if (visibleSheets.length === 1 && visibleSheets[0] === this) {\n                        throw new Error(\"This sheet may not be hidden as a workbook must contain at least one visible sheet.\");\n                    }\n\n                    // If activate, activate the first other visible sheet.\n                    if (this.active()) {\n                        const activeIndex = visibleSheets[0] === this ? 1 : 0;\n                        visibleSheets[activeIndex].active(true);\n                    }\n                }\n\n                if (hidden === 'very') this._idNode.attributes.state = 'veryHidden';\n                else if (hidden) this._idNode.attributes.state = 'hidden';\n                else delete this._idNode.attributes.state;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Move the sheet.\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Sheet} The sheet.\n     */\n    move(indexOrBeforeSheet) {\n        this.workbook().moveSheet(this, indexOrBeforeSheet);\n        return this;\n    }\n\n    /**\n     * Get the name of the sheet.\n     * @returns {string} The sheet name.\n     *//**\n     * Set the name of the sheet. *Note: this method does not rename references to the sheet so formulas, etc. can be broken. Use with caution!*\n     * @param {string} name - The name to set to the sheet.\n     * @returns {Sheet} The sheet.\n     */\n    name() {\n        return new ArgHandler('Sheet.name')\n            .case(() => {\n                return `${this._idNode.attributes.name}`;\n            })\n            .case('string', name => {\n                this._idNode.attributes.name = name;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets a range from the given range address.\n     * @param {string} address - The range address (e.g. 'A1:B3').\n     * @returns {Range} The range.\n     *//**\n     * Gets a range from the given cells or cell addresses.\n     * @param {string|Cell} startCell - The starting cell or cell address (e.g. 'A1').\n     * @param {string|Cell} endCell - The ending cell or cell address (e.g. 'B3').\n     * @returns {Range} The range.\n     *//**\n     * Gets a range from the given row numbers and column names or numbers.\n     * @param {number} startRowNumber - The starting cell row number.\n     * @param {string|number} startColumnNameOrNumber - The starting cell column name or number.\n     * @param {number} endRowNumber - The ending cell row number.\n     * @param {string|number} endColumnNameOrNumber - The ending cell column name or number.\n     * @returns {Range} The range.\n     */\n    range() {\n        return new ArgHandler('Sheet.range')\n            .case('string', address => {\n                const ref = addressConverter.fromAddress(address);\n                if (ref.type !== 'range') throw new Error('Sheet.range: Invalid address');\n                return this.range(ref.startRowNumber, ref.startColumnNumber, ref.endRowNumber, ref.endColumnNumber);\n            })\n            .case(['*', '*'], (startCell, endCell) => {\n                if (typeof startCell === \"string\") startCell = this.cell(startCell);\n                if (typeof endCell === \"string\") endCell = this.cell(endCell);\n                return new Range(startCell, endCell);\n            })\n            .case(['number', '*', 'number', '*'], (startRowNumber, startColumnNameOrNumber, endRowNumber, endColumnNameOrNumber) => {\n                return this.range(this.cell(startRowNumber, startColumnNameOrNumber), this.cell(endRowNumber, endColumnNameOrNumber));\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Unsets sheet autoFilter.\n     * @returns {Sheet} This sheet.\n     *//**\n     * Sets sheet autoFilter to a Range.\n     * @param {Range} range - The autoFilter range.\n     * @returns {Sheet} This sheet.\n     */\n    autoFilter(range) {\n        this._autoFilter = range;\n\n        return this;\n    }\n\n    /**\n     * Gets the row with the given number.\n     * @param {number} rowNumber - The row number.\n     * @returns {Row} The row with the given number.\n     */\n    row(rowNumber) {\n        if (rowNumber < 1) throw new RangeError(`Invalid row number ${rowNumber}. Remember that spreadsheets use 1-based indexing.`);\n\n        if (this._rows[rowNumber]) return this._rows[rowNumber];\n\n        const rowNode = {\n            name: 'row',\n            attributes: {\n                r: rowNumber\n            },\n            children: []\n        };\n\n        const row = new Row(this, rowNode);\n        this._rows[rowNumber] = row;\n        return row;\n    }\n\n    /**\n     * Get the tab color. (See style [Color](#color).)\n     * @returns {undefined|Color} The color or undefined if not set.\n     *//**\n     * Sets the tab color. (See style [Color](#color).)\n     * @returns {Color|string|number} color - Color of the tab. If string, will set an RGB color. If number, will set a theme color.\n     */\n    tabColor() {\n        return new ArgHandler(\"Sheet.tabColor\")\n            .case(() => {\n                const tabColorNode = xmlq.findChild(this._sheetPrNode, \"tabColor\");\n                if (!tabColorNode) return;\n\n                const color = {};\n                if (tabColorNode.attributes.hasOwnProperty('rgb')) color.rgb = tabColorNode.attributes.rgb;\n                else if (tabColorNode.attributes.hasOwnProperty('theme')) color.theme = tabColorNode.attributes.theme;\n                else if (tabColorNode.attributes.hasOwnProperty('indexed')) color.rgb = colorIndexes[tabColorNode.attributes.indexed];\n\n                if (tabColorNode.attributes.hasOwnProperty('tint')) color.tint = tabColorNode.attributes.tint;\n\n                return color;\n            })\n            .case(\"string\", rgb => this.tabColor({ rgb }))\n            .case(\"integer\", theme => this.tabColor({ theme }))\n            .case(\"nil\", () => {\n                xmlq.removeChild(this._sheetPrNode, \"tabColor\");\n                return this;\n            })\n            .case(\"object\", color => {\n                const tabColorNode = xmlq.appendChildIfNotFound(this._sheetPrNode, \"tabColor\");\n                xmlq.setAttributes(tabColorNode, {\n                    rgb: color.rgb && color.rgb.toUpperCase(),\n                    indexed: null,\n                    theme: color.theme,\n                    tint: color.tint\n                });\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets a value indicating whether this sheet is selected.\n     * @returns {boolean} True if selected, false if not.\n     *//**\n     * Sets whether this sheet is selected.\n     * @param {boolean} selected - True to select, false to deselected.\n     * @returns {Sheet} The sheet.\n     */\n    tabSelected() {\n        const sheetViewNode = this._getOrCreateSheetViewNode();\n        return new ArgHandler('Sheet.tabSelected')\n            .case(() => {\n                return sheetViewNode.attributes.tabSelected === 1;\n            })\n            .case('boolean', selected => {\n                if (selected) sheetViewNode.attributes.tabSelected = 1;\n                else delete sheetViewNode.attributes.tabSelected;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets a value indicating whether this sheet is rtl (Right To Left).\n     * @returns {boolean} True if rtl, false if ltr.\n     *//**\n     * Sets whether this sheet is rtl.\n     * @param {boolean} rtl - True to rtl, false to ltr (Left To Right).\n     * @returns {Sheet} The sheet.\n     */\n    rightToLeft() {\n        const sheetViewNode = this._getOrCreateSheetViewNode();\n        return new ArgHandler('Sheet.rightToLeft')\n            .case(() => {\n                return sheetViewNode.attributes.rightToLeft;\n            })\n            .case('boolean', rtl => {\n                if (rtl) sheetViewNode.attributes.rightToLeft = true;\n                else delete sheetViewNode.attributes.rightToLeft;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the range of cells in the sheet that have contained a value or style at any point. Useful for extracting the entire sheet contents.\n     * @returns {Range|undefined} The used range or undefined if no cells in the sheet are used.\n     */\n    usedRange() {\n        const minRowNumber = _.findIndex(this._rows);\n        const maxRowNumber = this._rows.length - 1;\n\n        let minColumnNumber = 0;\n        let maxColumnNumber = 0;\n        for (let i = 0; i < this._rows.length; i++) {\n            const row = this._rows[i];\n            if (!row) continue;\n\n            const minUsedColumnNumber = row.minUsedColumnNumber();\n            const maxUsedColumnNumber = row.maxUsedColumnNumber();\n            if (minUsedColumnNumber > 0 && (!minColumnNumber || minUsedColumnNumber < minColumnNumber)) minColumnNumber = minUsedColumnNumber;\n            if (maxUsedColumnNumber > 0 && (!maxColumnNumber || maxUsedColumnNumber > maxColumnNumber)) maxColumnNumber = maxUsedColumnNumber;\n        }\n\n        // Return undefined if nothing in the sheet is used.\n        if (minRowNumber <= 0 || minColumnNumber <= 0 || maxRowNumber <= 0 || maxColumnNumber <= 0) return;\n\n        return this.range(minRowNumber, minColumnNumber, maxRowNumber, maxColumnNumber);\n    }\n\n    /**\n     * Gets the parent workbook.\n     * @returns {Workbook} The parent workbook.\n     */\n    workbook() {\n        return this._workbook;\n    }\n\n    /**\n     * Gets all page breaks.\n     * @returns {{}} the object holds both vertical and horizontal PageBreaks.\n     */\n    pageBreaks() {\n        return this._pageBreaks;\n    }\n\n    /**\n     * Gets the vertical page breaks.\n     * @returns {PageBreaks} vertical PageBreaks.\n     */\n    verticalPageBreaks() {\n        return this._pageBreaks.colBreaks;\n    }\n\n    /**\n     * Gets the horizontal page breaks.\n     * @returns {PageBreaks} horizontal PageBreaks.\n     */\n    horizontalPageBreaks() {\n        return this._pageBreaks.rowBreaks;\n    }\n\n    /* INTERNAL */\n\n    /**\n     * Clear cells that are using a given shared formula ID.\n     * @param {number} sharedFormulaId - The shared formula ID.\n     * @returns {undefined}\n     * @ignore\n     */\n    clearCellsUsingSharedFormula(sharedFormulaId) {\n        this._rows.forEach(row => {\n            if (!row) return;\n            row.clearCellsUsingSharedFormula(sharedFormulaId);\n        });\n    }\n\n    /**\n     * Get an existing column style ID.\n     * @param {number} columnNumber - The column number.\n     * @returns {undefined|number} The style ID.\n     * @ignore\n     */\n    existingColumnStyleId(columnNumber) {\n        // This will work after setting Column.style because Column updates the attributes live.\n        const colNode = this._colNodes[columnNumber];\n        return colNode && colNode.attributes.style;\n    }\n\n    /**\n     * Call a callback for each column number that has a node defined for it.\n     * @param {Function} callback - The callback.\n     * @returns {undefined}\n     * @ignore\n     */\n    forEachExistingColumnNumber(callback) {\n        _.forEach(this._colNodes, (node, columnNumber) => {\n            if (!node) return;\n            callback(columnNumber);\n        });\n    }\n\n    /**\n     * Call a callback for each existing row.\n     * @param {Function} callback - The callback.\n     * @returns {undefined}\n     * @ignore\n     */\n    forEachExistingRow(callback) {\n        _.forEach(this._rows, (row, rowNumber) => {\n            if (row) callback(row, rowNumber);\n        });\n\n        return this;\n    }\n\n    /**\n     * Get the hyperlink attached to the cell with the given address.\n     * @param {string} address - The address of the hyperlinked cell.\n     * @returns {string|undefined} The hyperlink or undefined if not set.\n     *//**\n     * Set the hyperlink on the cell with the given address.\n     * @param {string} address - The address of the hyperlinked cell.\n     * @param {string} hyperlink - The hyperlink to set or undefined to clear.\n     * @param {boolean} [internal] - The flag to force hyperlink to be internal. If true, then autodetect is skipped.\n     * @returns {Sheet} The sheet.\n     *//**\n     * Set the hyperlink on the cell with the given address. If opts is a Cell an internal hyperlink is added.\n     * @param {string} address - The address of the hyperlinked cell.\n     * @param {object|Cell} opts - Options.\n     * @returns {Sheet} The sheet.\n     * @ignore\n     *//**\n     * Set the hyperlink on the cell with the given address and options.\n     * @param {string} address - The address of the hyperlinked cell.\n     * @param {{}|Cell} opts - Options or Cell. If opts is a Cell then an internal hyperlink is added.\n     * @param {string|Cell} [opts.hyperlink] - The hyperlink to set, can be a Cell or an internal/external string.\n     * @param {string} [opts.tooltip] - Additional text to help the user understand more about the hyperlink.\n     * @param {string} [opts.email] - Email address, ignored if opts.hyperlink is set.\n     * @param {string} [opts.emailSubject] - Email subject, ignored if opts.hyperlink is set.\n     * @returns {Sheet} The sheet.\n     */\n    hyperlink() {\n        return new ArgHandler('Sheet.hyperlink')\n            .case('string', address => {\n                const hyperlinkNode = this._hyperlinks[address];\n                if (!hyperlinkNode) return;\n                const relationship = this._relationships.findById(hyperlinkNode.attributes['r:id']);\n                return relationship && relationship.attributes.Target;\n            })\n            .case(['string', 'nil'], address => {\n                // TODO: delete relationship\n                delete this._hyperlinks[address];\n                return this;\n            })\n            .case(['string', 'string'], (address, hyperlink) => {\n                return this.hyperlink(address, hyperlink, false);\n            })\n            .case(['string', 'string', 'boolean'], (address, hyperlink, internal) => {\n                const isHyperlinkInternalAddress = internal || addressConverter.fromAddress(hyperlink);\n                let nodeAttributes;\n                if (isHyperlinkInternalAddress) {\n                    nodeAttributes = {\n                        ref: address,\n                        location: hyperlink,\n                        display: hyperlink\n                    };\n                } else {\n                    const relationship = this._relationships.add(\"hyperlink\", hyperlink, \"External\");\n                    nodeAttributes = {\n                        ref: address,\n                        'r:id': relationship.attributes.Id\n                    };\n                }\n                this._hyperlinks[address] = {\n                    name: 'hyperlink',\n                    attributes: nodeAttributes,\n                    children: []\n                };\n                return this;\n            })\n            .case(['string', 'object'], (address, opts) => {\n                if (opts instanceof Cell) {\n                    const cell = opts;\n                    const hyperlink = cell.address({ includeSheetName: true });\n                    this.hyperlink(address, hyperlink, true);\n                } else if (opts.hyperlink) {\n                    this.hyperlink(address, opts.hyperlink);\n                } else if (opts.email) {\n                    const email = opts.email;\n                    const subject = opts.emailSubject || '';\n                    this.hyperlink(address, encodeURI(`mailto:${email}?subject=${subject}`));\n                }\n                const hyperlinkNode = this._hyperlinks[address];\n                if (hyperlinkNode) {\n                    if (opts.tooltip) {\n                        hyperlinkNode.attributes.tooltip = opts.tooltip;\n                    }\n                }\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Increment and return the max shared formula ID.\n     * @returns {number} The new max shared formula ID.\n     * @ignore\n     */\n    incrementMaxSharedFormulaId() {\n        return ++this._maxSharedFormulaId;\n    }\n\n    /**\n     * Get a value indicating whether the cells in the given address are merged.\n     * @param {string} address - The address to check.\n     * @returns {boolean} True if merged, false if not merged.\n     * @ignore\n     *//**\n     * Merge/unmerge cells by adding/removing a mergeCell entry.\n     * @param {string} address - The address to merge.\n     * @param {boolean} merged - True to merge, false to unmerge.\n     * @returns {Sheet} The sheet.\n     * @ignore\n     */\n    merged() {\n        return new ArgHandler('Sheet.merge')\n            .case('string', address => {\n                return this._mergeCells.hasOwnProperty(address);\n            })\n            .case(['string', '*'], (address, merge) => {\n                if (merge) {\n                    this._mergeCells[address] = {\n                        name: 'mergeCell',\n                        attributes: { ref: address },\n                        children: []\n                    };\n                } else {\n                    delete this._mergeCells[address];\n                }\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n\n    /**\n     * Gets a Object or undefined of the cells in the given address.\n     * @param {string} address - The address to check.\n     * @returns {object|boolean} Object or false if not set\n     * @ignore\n     *//**\n     * Removes dataValidation at the given address\n     * @param {string} address - The address to remove.\n     * @param {boolean} obj - false to delete.\n     * @returns {boolean} true if removed.\n     * @ignore\n     *//**\n     * Add dataValidation to cells at the given address if object or string\n     * @param {string} address - The address to set.\n     * @param {object|string} obj - Object or String to set\n     * @returns {Sheet} The sheet.\n     * @ignore\n     */\n    dataValidation() {\n        return new ArgHandler('Sheet.dataValidation')\n            .case('string', address => {\n                if (this._dataValidations[address]) {\n                    return {\n                        type: this._dataValidations[address].attributes.type,\n                        allowBlank: this._dataValidations[address].attributes.allowBlank,\n                        showInputMessage: this._dataValidations[address].attributes.showInputMessage,\n                        prompt: this._dataValidations[address].attributes.prompt,\n                        promptTitle: this._dataValidations[address].attributes.promptTitle,\n                        showErrorMessage: this._dataValidations[address].attributes.showErrorMessage,\n                        error: this._dataValidations[address].attributes.error,\n                        errorTitle: this._dataValidations[address].attributes.errorTitle,\n                        operator: this._dataValidations[address].attributes.operator,\n                        formula1: this._dataValidations[address].children[0].children[0],\n                        formula2: this._dataValidations[address].children[1] ? this._dataValidations[address].children[1].children[0] : undefined\n                    };\n                } else {\n                    return false;\n                }\n            })\n            .case(['string', 'boolean'], (address, obj) => {\n                if (this._dataValidations[address]) {\n                    if (obj === false) return delete this._dataValidations[address];\n                } else {\n                    return false;\n                }\n            })\n            .case(['string', '*'], (address, obj) => {\n                if (typeof obj === 'string') {\n                    this._dataValidations[address] = {\n                        name: 'dataValidation',\n                        attributes: {\n                            type: 'list',\n                            allowBlank: false,\n                            showInputMessage: false,\n                            prompt: '',\n                            promptTitle: '',\n                            showErrorMessage: false,\n                            error: '',\n                            errorTitle: '',\n                            operator: '',\n                            sqref: address\n                        },\n                        children: [\n                            {\n                                name: 'formula1',\n                                atrributes: {},\n                                children: [obj]\n                            },\n                            {\n                                name: 'formula2',\n                                atrributes: {},\n                                children: ['']\n                            }\n                        ]\n                    };\n                } else if (typeof obj === 'object') {\n                    this._dataValidations[address] = {\n                        name: 'dataValidation',\n                        attributes: {\n                            type: obj.type ? obj.type : 'list',\n                            allowBlank: obj.allowBlank,\n                            showInputMessage: obj.showInputMessage,\n                            prompt: obj.prompt,\n                            promptTitle: obj.promptTitle,\n                            showErrorMessage: obj.showErrorMessage,\n                            error: obj.error,\n                            errorTitle: obj.errorTitle,\n                            operator: obj.operator,\n                            sqref: address\n                        },\n                        children: [\n                            {\n                                name: 'formula1',\n                                atrributes: {},\n                                children: [\n                                    obj.formula1\n                                ]\n                            },\n                            {\n                                name: 'formula2',\n                                atrributes: {},\n                                children: [\n                                    obj.formula2\n                                ]\n                            }\n                        ]\n                    };\n                }\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Convert the sheet to a collection of XML objects.\n     * @returns {{}} The XML forms.\n     * @ignore\n     */\n    toXmls() {\n        // Shallow clone the node so we don't have to remove these children later if they don't belong.\n        const node = _.clone(this._node);\n        node.children = node.children.slice();\n\n        // Add the columns if needed.\n        this._colsNode.children = _.filter(this._colNodes, (colNode, i) => {\n            // Columns should only be present if they have attributes other than min/max.\n            return colNode && i === colNode.attributes.min && Object.keys(colNode.attributes).length > 2;\n        });\n        if (this._colsNode.children.length) {\n            xmlq.insertInOrder(node, this._colsNode, nodeOrder);\n        }\n\n        // Add the hyperlinks if needed.\n        this._hyperlinksNode.children = _.values(this._hyperlinks);\n        if (this._hyperlinksNode.children.length) {\n            xmlq.insertInOrder(node, this._hyperlinksNode, nodeOrder);\n        }\n\n        // Add the printOptions if needed.\n        if (this._printOptionsNode) {\n            if (Object.keys(this._printOptionsNode.attributes).length) {\n                xmlq.insertInOrder(node, this._printOptionsNode, nodeOrder);\n            }\n        }\n\n        // Add the pageMargins if needed.\n        if (this._pageMarginsNode && this._pageMarginsPresetName) {\n            // Clone to preserve the current state of this sheet.\n            const childNode = _.clone(this._pageMarginsNode);\n            if (Object.keys(this._pageMarginsNode.attributes).length) {\n                // Fill in any missing attribute values with presets.\n                childNode.attributes = _.assign(\n                    this._pageMarginsPresets[this._pageMarginsPresetName],\n                    this._pageMarginsNode.attributes);\n            } else {\n                // No need to fill in, all attributes is currently empty, simply replace.\n                childNode.attributes = this._pageMarginsPresets[this._pageMarginsPresetName];\n            }\n            xmlq.insertInOrder(node, childNode, nodeOrder);\n        }\n\n        // Add the merge cells if needed.\n        this._mergeCellsNode.children = _.values(this._mergeCells);\n        if (this._mergeCellsNode.children.length) {\n            xmlq.insertInOrder(node, this._mergeCellsNode, nodeOrder);\n        }\n\n        // Add the DataValidation cells if needed.\n        this._dataValidationsNode.children = _.values(this._dataValidations);\n        if (this._dataValidationsNode.children.length) {\n            xmlq.insertInOrder(node, this._dataValidationsNode, nodeOrder);\n        }\n\n        if (this._autoFilter) {\n            xmlq.insertInOrder(node, {\n                name: \"autoFilter\",\n                children: [],\n                attributes: {\n                    ref: this._autoFilter.address()\n                }\n            }, nodeOrder);\n        }\n\n        // Add the PageBreaks nodes if needed.\n        ['colBreaks', 'rowBreaks'].forEach(name => {\n            const breaks = this[`_${name}Node`];\n            if (breaks.attributes.count) {\n                xmlq.insertInOrder(node, breaks, nodeOrder);\n            }\n        });\n\n        return {\n            id: this._idNode,\n            sheet: node,\n            relationships: this._relationships\n        };\n    }\n\n    /**\n     * Update the max shared formula ID to the given value if greater than current.\n     * @param {number} sharedFormulaId - The new shared formula ID.\n     * @returns {undefined}\n     * @ignore\n     */\n    updateMaxSharedFormulaId(sharedFormulaId) {\n        if (sharedFormulaId > this._maxSharedFormulaId) {\n            this._maxSharedFormulaId = sharedFormulaId;\n        }\n    }\n\n    /**\n     * Get the print option given a valid print option attribute.\n     * @param {string} attributeName - Attribute name of the printOptions.\n     *   gridLines - Used in conjunction with gridLinesSet. If both gridLines and gridlinesSet are true, then grid lines shall print. Otherwise, they shall not (i.e., one or both have false values).\n     *   gridLinesSet - Used in conjunction with gridLines. If both gridLines and gridLinesSet are true, then grid lines shall print. Otherwise, they shall not (i.e., one or both have false values).\n     *   headings - Print row and column headings.\n     *   horizontalCentered - Center on page horizontally when printing.\n     *   verticalCentered - Center on page vertically when printing.\n     * @returns {boolean}\n     *//**\n     * Set the print option given a valid print option attribute and a value.\n     * @param {string} attributeName - Attribute name of the printOptions. See get print option for list of valid attributes.\n     * @param {undefined|boolean} attributeEnabled - If `undefined` or `false` then the attribute is removed, otherwise the print option is enabled.\n     * @returns {Sheet} The sheet.\n     */\n    printOptions() {\n        const supportedAttributeNames = [\n            'gridLines', 'gridLinesSet', 'headings', 'horizontalCentered', 'verticalCentered'];\n        const checkAttributeName = this._getCheckAttributeNameHelper('printOptions', supportedAttributeNames);\n        return new ArgHandler('Sheet.printOptions')\n            .case(['string'], attributeName => {\n                checkAttributeName(attributeName);\n                return this._printOptionsNode.attributes[attributeName] === 1;\n            })\n            .case(['string', 'nil'], attributeName => {\n                checkAttributeName(attributeName);\n                delete this._printOptionsNode.attributes[attributeName];\n                return this;\n            })\n            .case(['string', 'boolean'], (attributeName, attributeEnabled) => {\n                checkAttributeName(attributeName);\n                if (attributeEnabled) {\n                    this._printOptionsNode.attributes[attributeName] = 1;\n                    return this;\n                } else {\n                    return this.printOptions(attributeName, undefined);\n                }\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the print option for the gridLines attribute value.\n     * @returns {boolean}\n     *//**\n     * Set the print option for the gridLines attribute value.\n     * @param {undefined|boolean} enabled - If `undefined` or `false` then attribute is removed, otherwise gridLines is enabled.\n     * @returns {Sheet} The sheet.\n     */\n    printGridLines() {\n        return new ArgHandler('Sheet.gridLines')\n            .case(() => {\n                return this.printOptions('gridLines') && this.printOptions('gridLinesSet');\n            })\n            .case(['nil'], () => {\n                this.printOptions('gridLines', undefined);\n                this.printOptions('gridLinesSet', undefined);\n                return this;\n            })\n            .case(['boolean'], enabled => {\n                this.printOptions('gridLines', enabled);\n                this.printOptions('gridLinesSet', enabled);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the page margin given a valid attribute name.\n     * If the value is not yet defined, then it will return the current preset value.\n     * @param {string} attributeName - Attribute name of the pageMargins.\n     *     left - Left Page Margin in inches.\n     *     right - Right page margin in inches.\n     *     top - Top Page Margin in inches.\n     *     buttom - Bottom Page Margin in inches.\n     *     footer - Footer Page Margin in inches.\n     *     header - Header Page Margin in inches.\n     * @returns {number} the attribute value.\n     *//**\n     * Set the page margin (or override the preset) given an attribute name and a value.\n     * @param {string} attributeName - Attribute name of the pageMargins. See get page margin for list of valid attributes.\n     * @param {undefined|number|string} attributeStringValue - If `undefined` then set back to preset value, otherwise, set the given attribute value.\n     * @returns {Sheet} The sheet.\n     */\n    pageMargins() {\n        if (this.pageMarginsPreset() === undefined) {\n            throw new Error('Sheet.pageMargins: preset is undefined.');\n        }\n        const supportedAttributeNames = [\n            'left', 'right', 'top', 'bottom', 'header', 'footer'];\n        const checkAttributeName = this._getCheckAttributeNameHelper('pageMargins', supportedAttributeNames);\n        const checkRange = this._getCheckRangeHelper('pageMargins', 0, undefined);\n        return new ArgHandler('Sheet.pageMargins')\n            .case(['string'], attributeName => {\n                checkAttributeName(attributeName);\n                const attributeValue = this._pageMarginsNode.attributes[attributeName];\n                if (attributeValue !== undefined) {\n                    return parseFloat(attributeValue);\n                } else if (this._pageMarginsPresetName) {\n                    return parseFloat(this._pageMarginsPresets[this._pageMarginsPresetName][attributeName]);\n                } else {\n                    return undefined;\n                }\n            })\n            .case(['string', 'nil'], attributeName => {\n                checkAttributeName(attributeName);\n                delete this._pageMarginsNode.attributes[attributeName];\n                return this;\n            })\n            .case(['string', 'number'], (attributeName, attributeNumberValue) => {\n                checkAttributeName(attributeName);\n                checkRange(attributeNumberValue);\n                this._pageMarginsNode.attributes[attributeName] = attributeNumberValue;\n                return this;\n            })\n            .case(['string', 'string'], (attributeName, attributeStringValue) => {\n                return this.pageMargins(attributeName, parseFloat(attributeStringValue));\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Page margins preset is a set of page margins associated with a name.\n     * The page margin preset acts as a fallback when not explicitly defined by `Sheet.pageMargins`.\n     * If a sheet already contains page margins, it attempts to auto-detect, otherwise they are defined as the template preset.\n     * If no page margins exist, then the preset is undefined and will not be included in the output of `Sheet.toXmls`.\n     * Available presets include: normal, wide, narrow, template.\n     *\n     * Get the page margins preset name. The registered name of a predefined set of attributes.\n     * @returns {string} The preset name.\n     *//**\n     * Set the page margins preset by name, clearing any existing/temporary attribute values.\n     * @param {undefined|string} presetName - The preset name. If `undefined`, page margins will not be included in the output of `Sheet.toXmls`.\n     * @returns {Sheet} The sheet.\n     *//**\n     * Set a new page margins preset by name and attributes object.\n     * @param {string} presetName - The preset name.\n     * @param {object} presetAttributes - The preset attributes.\n     * @returns {Sheet} The sheet.\n     */\n    pageMarginsPreset() {\n        return new ArgHandler('Sheet.pageMarginsPreset')\n            .case(() => {\n                return this._pageMarginsPresetName;\n            })\n            .case(['nil'], () => {\n                // Remove all preset overrides and exclude from sheet\n                this._pageMarginsPresetName = undefined;\n\n                // Remove all preset overrides\n                this._pageMarginsNode.attributes = {};\n                return this;\n            })\n            .case(['string'], presetName => {\n                const checkPresetName = this._getCheckAttributeNameHelper(\n                    'pageMarginsPreset', Object.keys(this._pageMarginsPresets));\n                checkPresetName(presetName);\n\n                // Change to new preset\n                this._pageMarginsPresetName = presetName;\n\n                // Remove all preset overrides\n                this._pageMarginsNode.attributes = {};\n                return this;\n            })\n            .case(['string', 'object'], (presetName, presetAttributes) => {\n                if (this._pageMarginsPresets.hasOwnProperty(presetName)) {\n                    throw new Error(`Sheet.pageMarginsPreset: The preset ${presetName} already exists!`);\n                }\n\n                // Validate preset attribute keys.\n                const pageMarginsAttributeNames = [\n                    'left', 'right', 'top', 'bottom', 'header', 'footer'];\n                const isValidPresetAttributeKeys = _.isEqual(\n                    _.sortBy(pageMarginsAttributeNames),\n                    _.sortBy(Object.keys(presetAttributes)));\n                if (isValidPresetAttributeKeys === false) {\n                    throw new Error(`Sheet.pageMarginsPreset: Invalid preset attributes for one or key(s)! - \"${Object.keys(presetAttributes)}\"`);\n                }\n\n                // Validate preset attribute values.\n                _.forEach((attributeValue, attributeName) => {\n                    const attributeNumberValue = parseFloat(attributeValue);\n                    if (_.isNaN(attributeNumberValue) || _.isNumber(attributeNumberValue) === false) {\n                        throw new Error(`Sheet.pageMarginsPreset: Invalid preset attribute value! - \"${attributeValue}\"`);\n                    }\n                });\n\n                // Change to new preset\n                this._pageMarginsPresetName = presetName;\n\n                // Remove all preset overrides\n                this._pageMarginsNode.attributes = {};\n\n                // Register the preset\n                this._pageMarginsPresets[presetName] = presetAttributes;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * https://docs.microsoft.com/en-us/dotnet/api/documentformat.openxml.spreadsheet.pane?view=openxml-2.8.1\n     * @typedef {Object} PaneOptions\n     * @property {string} activePane=bottomRight Active Pane. The pane that is active.\n     * @property {string} state Split State. Indicates whether the pane has horizontal / vertical splits,\n     * and whether those splits are frozen.\n     * @property {string} topLeftCell Top Left Visible Cell. Location of the top left visible cell in the bottom\n     * right pane (when in Left-To-Right mode).\n     * @property {number} xSplit (Horizontal Split Position) Horizontal position of the split, in 1/20th of a point;\n     * 0 (zero) if none. If the pane is frozen, this value indicates the number of columns visible in the top pane.\n     * @property {number} ySplit (Vertical Split Position) Vertical position of the split, in 1/20th of a point; 0\n     * (zero) if none. If the pane is frozen, this value indicates the number of rows visible in the left pane.\n     *//**\n     * Gets sheet view pane options\n     * @return {PaneOptions} sheet view pane options\n     *//**\n     * Sets sheet view pane options\n     * @param {PaneOptions|null|undefined} paneOptions sheet view pane options\n     * @return {Sheet} The sheet\n     */\n    panes() {\n        const supportedStates = ['split', 'frozen', 'frozenSplit'];\n        const supportedActivePanes = ['bottomLeft', 'bottomRight', 'topLeft', 'topRight'];\n        const checkStateName = this._getCheckAttributeNameHelper('pane.state', supportedStates);\n        const checkActivePane = this._getCheckAttributeNameHelper('pane.activePane', supportedActivePanes);\n        const sheetViewNode = this._getOrCreateSheetViewNode();\n        let paneNode = xmlq.findChild(sheetViewNode, 'pane');\n        return new ArgHandler('Sheet.pane')\n            .case(() => {\n                if (paneNode) {\n                    const result = _.cloneDeep(paneNode.attributes);\n                    if (!result.state) result.state = 'split';\n                    return result;\n                }\n            })\n            .case(['nil'], () => {\n                xmlq.removeChild(sheetViewNode, 'pane');\n                return this;\n            })\n            .case(['object'], paneAttributes => {\n                const attributes = _.assign({ activePane: 'bottomRight' }, paneAttributes);\n                checkStateName(attributes.state);\n                checkActivePane(attributes.activePane);\n                if (paneNode) {\n                    paneNode.attributes = attributes;\n                } else {\n                    paneNode = {\n                        name: \"pane\",\n                        attributes,\n                        children: []\n                    };\n                    xmlq.appendChild(sheetViewNode, paneNode);\n                }\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Freezes Panes for this sheet.\n     * @param {number} xSplit the number of columns visible in the top pane. 0 (zero) if none.\n     * @param {number} ySplit the number of rows visible in the left pane. 0 (zero) if none.\n     * @return {Sheet} The sheet\n     *//**\n     * freezes Panes for this sheet.\n     * @param {string} topLeftCell Top Left Visible Cell. Location of the top left visible cell in the bottom\n     * right pane (when in Left-To-Right mode).\n     * @return {Sheet} The sheet\n     */\n    freezePanes() {\n        return new ArgHandler('Sheet.feezePanes')\n            .case(['integer', 'integer'], (xSplit, ySplit) => {\n                const topLeftCell = addressConverter.columnNumberToName(xSplit + 1) + (ySplit + 1);\n                let activePane = xSplit === 0 ? 'bottomLeft' : 'bottomRight';\n                activePane = ySplit === 0 ? 'topRight' : activePane;\n                return this.panes({ state: 'frozen', topLeftCell, xSplit, ySplit, activePane });\n            })\n            .case(['string'], topLeftCell => {\n                const ref = addressConverter.fromAddress(topLeftCell);\n                const xSplit = ref.columnNumber - 1, ySplit = ref.rowNumber - 1;\n                let activePane = xSplit === 0 ? 'bottomLeft' : 'bottomRight';\n                activePane = ySplit === 0 ? 'topRight' : activePane;\n                return this.panes({ state: 'frozen', topLeftCell, xSplit, ySplit, activePane });\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Splits Panes for this sheet.\n     * @param {number} xSplit (Horizontal Split Position) Horizontal position of the split,\n     * in 1/20th of a point; 0 (zero) if none.\n     * @param {number} ySplit (Vertical Split Position) VVertical position of the split,\n     * in 1/20th of a point; 0 (zero) if none.\n     * @return {Sheet} The sheet\n     */\n    splitPanes(xSplit, ySplit) {\n        return this.panes({ state: 'split', xSplit, ySplit });\n    }\n\n    /**\n     * resets to default sheet view panes.\n     * @return {Sheet} The sheet\n     */\n    resetPanes() {\n        return this.panes(null);\n    }\n\n    /* PRIVATE */\n\n    /**\n     * Get a helper function to check that the attribute name provided is supported.\n     * @param {string} functionName - Name of the parent function.\n     * @param {array} supportedAttributeNames - Array of supported attribute name strings.\n     * @returns {function} The helper function, which takes an attribute name. If the array of supported attribute names does not contain the given attribute name, then an Error is thrown.\n     * @ignore\n     */\n    _getCheckAttributeNameHelper(functionName, supportedAttributeNames) {\n        return attributeName => {\n            if (!_.includes(supportedAttributeNames, attributeName)) {\n                throw new Error(`Sheet.${functionName}: \"${attributeName}\" is not supported.`);\n            }\n        };\n    }\n\n    /**\n     * Get a helper function to check that the value is of the expected type.\n     * @param {string} functionName - Name of the parent function.\n     * @param {string} valueType - A string produced by typeof.\n     * @returns {function} The helper function, which takes a value. If the value type is not expected, a TypeError is thrown.\n     * @ignore\n     */\n    _getCheckTypeHelper(functionName, valueType) {\n        return value => {\n            if (typeof value !== valueType) {\n                throw new TypeError(`Sheet.${functionName}: invalid type - value must be of type ${valueType}.`);\n            }\n        };\n    }\n\n    /**\n     * Get a helper function to check that the value is within the expected range.\n     * @param {string} functionName - Name of the parent function.\n     * @param {undefined|number} valueMin - The minimum value of the range. This value is range-inclusive.\n     * @param {undefined|number} valueMax - The maximum value of the range. This value is range-exclusive.\n     * @returns {function} The helper function, which takes a value. If the value type is not 'number', a TypeError is thrown. If the value is not within the range, a RangeError is thrown.\n     * @ignore\n     */\n    _getCheckRangeHelper(functionName, valueMin, valueMax) {\n        const checkType = this._getCheckTypeHelper(functionName, 'number');\n        return value => {\n            checkType(value);\n            if (valueMin !== undefined) {\n                if (value < valueMin) {\n                    throw new RangeError(`Sheet.${functionName}: value too small - value must be greater than or equal to ${valueMin}.`);\n                }\n            }\n            if (valueMax !== undefined) {\n                if (valueMax <= value) {\n                    throw new RangeError(`Sheet.${functionName}: value too large - value must be less than ${valueMax}.`);\n                }\n            }\n        };\n    }\n\n    /**\n     * Get the sheet view node if it exists or create it if it doesn't.\n     * @returns {{}} The sheet view node.\n     * @private\n     */\n    _getOrCreateSheetViewNode() {\n        let sheetViewsNode = xmlq.findChild(this._node, \"sheetViews\");\n        if (!sheetViewsNode) {\n            sheetViewsNode = {\n                name: \"sheetViews\",\n                attributes: {},\n                children: [{\n                    name: \"sheetView\",\n                    attributes: {\n                        workbookViewId: 0\n                    },\n                    children: []\n                }]\n            };\n\n            xmlq.insertInOrder(this._node, sheetViewsNode, nodeOrder);\n        }\n\n        return xmlq.findChild(sheetViewsNode, \"sheetView\");\n    }\n\n    /**\n     * Initializes the sheet.\n     * @param {Workbook} workbook - The parent workbook.\n     * @param {{}} idNode - The sheet ID node (from the parent workbook).\n     * @param {{}} node - The sheet node.\n     * @param {{}} [relationshipsNode] - The optional sheet relationships node.\n     * @returns {undefined}\n     * @private\n     */\n    _init(workbook, idNode, node, relationshipsNode) {\n        if (!node) {\n            node = {\n                name: \"worksheet\",\n                attributes: {\n                    xmlns: \"http://schemas.openxmlformats.org/spreadsheetml/2006/main\",\n                    'xmlns:r': \"http://schemas.openxmlformats.org/officeDocument/2006/relationships\",\n                    'xmlns:mc': \"http://schemas.openxmlformats.org/markup-compatibility/2006\",\n                    'mc:Ignorable': \"x14ac\",\n                    'xmlns:x14ac': \"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\"\n                },\n                children: [{\n                    name: \"sheetData\",\n                    attributes: {},\n                    children: []\n                }]\n            };\n        }\n\n        this._workbook = workbook;\n        this._idNode = idNode;\n        this._node = node;\n        this._maxSharedFormulaId = -1;\n        this._mergeCells = {};\n        this._dataValidations = {};\n        this._hyperlinks = {};\n        this._autoFilter = null;\n\n        // Create the relationships.\n        this._relationships = new Relationships(relationshipsNode);\n\n        // Delete the optional dimension node\n        xmlq.removeChild(this._node, \"dimension\");\n\n        // Create the rows.\n        this._rows = [];\n        this._sheetDataNode = xmlq.findChild(this._node, \"sheetData\");\n        this._sheetDataNode.children.forEach(rowNode => {\n            const row = new Row(this, rowNode);\n            this._rows[row.rowNumber()] = row;\n        });\n        this._sheetDataNode.children = this._rows;\n\n        // Create the columns node.\n        this._columns = [];\n        this._colsNode = xmlq.findChild(this._node, \"cols\");\n        if (this._colsNode) {\n            xmlq.removeChild(this._node, this._colsNode);\n        } else {\n            this._colsNode = { name: 'cols', attributes: {}, children: [] };\n        }\n\n        // Cache the col nodes.\n        this._colNodes = [];\n        _.forEach(this._colsNode.children, colNode => {\n            const min = colNode.attributes.min;\n            const max = colNode.attributes.max;\n            for (let i = min; i <= max; i++) {\n                this._colNodes[i] = colNode;\n            }\n        });\n\n        // Create the sheet properties node.\n        this._sheetPrNode = xmlq.findChild(this._node, \"sheetPr\");\n        if (!this._sheetPrNode) {\n            this._sheetPrNode = { name: 'sheetPr', attributes: {}, children: [] };\n            xmlq.insertInOrder(this._node, this._sheetPrNode, nodeOrder);\n        }\n\n        // Create the merge cells.\n        this._mergeCellsNode = xmlq.findChild(this._node, \"mergeCells\");\n        if (this._mergeCellsNode) {\n            xmlq.removeChild(this._node, this._mergeCellsNode);\n        } else {\n            this._mergeCellsNode = { name: 'mergeCells', attributes: {}, children: [] };\n        }\n\n        const mergeCellNodes = this._mergeCellsNode.children;\n        this._mergeCellsNode.children = [];\n        mergeCellNodes.forEach(mergeCellNode => {\n            this._mergeCells[mergeCellNode.attributes.ref] = mergeCellNode;\n        });\n\n\n        // Create the DataValidations.\n        this._dataValidationsNode = xmlq.findChild(this._node, \"dataValidations\");\n        if (this._dataValidationsNode) {\n            xmlq.removeChild(this._node, this._dataValidationsNode);\n        } else {\n            this._dataValidationsNode = { name: 'dataValidations', attributes: {}, children: [] };\n        }\n\n        const dataValidationNodes = this._dataValidationsNode.children;\n        this._dataValidationsNode.children = [];\n        dataValidationNodes.forEach(dataValidationNode => {\n            this._dataValidations[dataValidationNode.attributes.sqref] = dataValidationNode;\n        });\n\n\n        // Create the hyperlinks.\n        this._hyperlinksNode = xmlq.findChild(this._node, \"hyperlinks\");\n        if (this._hyperlinksNode) {\n            xmlq.removeChild(this._node, this._hyperlinksNode);\n        } else {\n            this._hyperlinksNode = { name: 'hyperlinks', attributes: {}, children: [] };\n        }\n\n        const hyperlinkNodes = this._hyperlinksNode.children;\n        this._hyperlinksNode.children = [];\n        hyperlinkNodes.forEach(hyperlinkNode => {\n            this._hyperlinks[hyperlinkNode.attributes.ref] = hyperlinkNode;\n        });\n\n\n        // Create the printOptions.\n        this._printOptionsNode = xmlq.findChild(this._node, \"printOptions\");\n        if (this._printOptionsNode) {\n            xmlq.removeChild(this._node, this._printOptionsNode);\n        } else {\n            this._printOptionsNode = { name: 'printOptions', attributes: {}, children: [] };\n        }\n\n\n        // Create the pageMargins.\n        this._pageMarginsPresets = {\n            normal: {\n                left: 0.7,\n                right: 0.7,\n                top: 0.75,\n                bottom: 0.75,\n                header: 0.3,\n                footer: 0.3\n            },\n            wide: {\n                left: 1,\n                right: 1,\n                top: 1,\n                bottom: 1,\n                header: 0.5,\n                footer: 0.5\n            },\n            narrow: {\n                left: 0.25,\n                right: 0.25,\n                top: 0.75,\n                bottom: 0.75,\n                header: 0.3,\n                footer: 0.3\n            }\n        };\n        this._pageMarginsNode = xmlq.findChild(this._node, \"pageMargins\");\n        if (this._pageMarginsNode) {\n            // Sheet has page margins, assume preset is template.\n            this._pageMarginsPresetName = 'template';\n\n            // Search for a preset that matches existing attributes.\n            for (const presetName in this._pageMarginsPresets) {\n                if (_.isEqual(this._pageMarginsNode.attributes, this._pageMarginsPresets[presetName])) {\n                    this._pageMarginsPresetName = presetName;\n                    break;\n                }\n            }\n\n            // If template preset, then register as template preset, and clear attributes.\n            if (this._pageMarginsPresetName === 'template') {\n                this._pageMarginsPresets.template = this._pageMarginsNode.attributes;\n                this._pageMarginsNode.attributes = {};\n            }\n\n            xmlq.removeChild(this._node, this._pageMarginsNode);\n        } else {\n            // Sheet has no page margins, the preset assignment is therefore undefined.\n            this._pageMarginsPresetName = undefined;\n            this._pageMarginsNode = { name: 'pageMargins', attributes: {}, children: [] };\n        }\n\n        // Create the pageBreaks\n        ['colBreaks', 'rowBreaks'].forEach(name => {\n            this[`_${name}Node`] = xmlq.findChild(this._node, name);\n            if (this[`_${name}Node`]) {\n                xmlq.removeChild(this._node, this[`_${name}Node`]);\n            } else {\n                this[`_${name}Node`] = {\n                    name,\n                    children: [],\n                    attributes: {\n                        count: 0,\n                        manualBreakCount: 0\n                    }\n                };\n            }\n        });\n        this._pageBreaks = {\n            colBreaks: new PageBreaks(this._colBreaksNode),\n            rowBreaks: new PageBreaks(this._rowBreaksNode)\n        };\n    }\n}\n\nmodule.exports = Sheet;\n\n/*\nxl/workbook.xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<worksheet ...>\n    ...\n\n    <printOptions headings=\"1\" gridLines=\"1\" />\n    <pageMargins left=\"0.7\" right=\"0.7\" top=\"0.75\" bottom=\"0.75\" header=\"0.3\" footer=\"0.3\" />\n    <pageSetup orientation=\"portrait\" horizontalDpi=\"0\" verticalDpi=\"0\" />\n</worksheet>\n// */\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}