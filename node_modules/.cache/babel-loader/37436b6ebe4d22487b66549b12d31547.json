{"ast":null,"code":"\"use strict\";\n/*\n* Copyright 2013 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // package com.google.zxing.pdf417.decoder;\n// import com.google.zxing.ChecksumException;\n\nvar ChecksumException_1 = require(\"../../ChecksumException\"); // import com.google.zxing.FormatException;\n\n\nvar FormatException_1 = require(\"../../FormatException\"); // import com.google.zxing.NotFoundException;\n\n\nvar NotFoundException_1 = require(\"../../NotFoundException\"); // import com.google.zxing.common.detector.MathUtils;\n\n\nvar MathUtils_1 = require(\"../../common/detector/MathUtils\"); // import com.google.zxing.pdf417.PDF417Common;\n\n\nvar PDF417Common_1 = require(\"../PDF417Common\"); // import com.google.zxing.pdf417.decoder.ec.ErrorCorrection;\n\n\nvar ErrorCorrection_1 = require(\"./ec/ErrorCorrection\"); // local\n\n\nvar BoundingBox_1 = require(\"./BoundingBox\");\n\nvar DetectionResultRowIndicatorColumn_1 = require(\"./DetectionResultRowIndicatorColumn\");\n\nvar DetectionResult_1 = require(\"./DetectionResult\");\n\nvar DetectionResultColumn_1 = require(\"./DetectionResultColumn\");\n\nvar Codeword_1 = require(\"./Codeword\");\n\nvar BarcodeValue_1 = require(\"./BarcodeValue\");\n\nvar PDF417CodewordDecoder_1 = require(\"./PDF417CodewordDecoder\");\n\nvar DecodedBitStreamParser_1 = require(\"./DecodedBitStreamParser\"); // utils\n\n\nvar Formatter_1 = require(\"../../util/Formatter\"); // import java.util.ArrayList;\n// import java.util.Collection;\n// import java.util.Formatter;\n// import java.util.List;\n\n/**\n * @author Guenther Grau\n */\n\n\nvar PDF417ScanningDecoder =\n/** @class */\nfunction () {\n  function PDF417ScanningDecoder() {}\n  /**\n   * @TODO don't pass in minCodewordWidth and maxCodewordWidth, pass in barcode columns for start and stop pattern\n   *\n   * columns. That way width can be deducted from the pattern column.\n   * This approach also allows to detect more details about the barcode, e.g. if a bar type (white or black) is wider\n   * than it should be. This can happen if the scanner used a bad blackpoint.\n   *\n   * @param BitMatrix\n   * @param image\n   * @param ResultPoint\n   * @param imageTopLeft\n   * @param ResultPoint\n   * @param imageBottomLeft\n   * @param ResultPoint\n   * @param imageTopRight\n   * @param ResultPoint\n   * @param imageBottomRight\n   * @param int\n   * @param minCodewordWidth\n   * @param int\n   * @param maxCodewordWidth\n   *\n   * @throws NotFoundException\n   * @throws FormatException\n   * @throws ChecksumException\n   */\n\n\n  PDF417ScanningDecoder.decode = function (image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight, minCodewordWidth, maxCodewordWidth) {\n    var boundingBox = new BoundingBox_1.default(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight);\n    var leftRowIndicatorColumn = null;\n    var rightRowIndicatorColumn = null;\n    var detectionResult;\n\n    for (var firstPass\n    /*boolean*/\n    = true;; firstPass = false) {\n      if (imageTopLeft != null) {\n        leftRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopLeft, true, minCodewordWidth, maxCodewordWidth);\n      }\n\n      if (imageTopRight != null) {\n        rightRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopRight, false, minCodewordWidth, maxCodewordWidth);\n      }\n\n      detectionResult = PDF417ScanningDecoder.merge(leftRowIndicatorColumn, rightRowIndicatorColumn);\n\n      if (detectionResult == null) {\n        throw NotFoundException_1.default.getNotFoundInstance();\n      }\n\n      var resultBox = detectionResult.getBoundingBox();\n\n      if (firstPass && resultBox != null && (resultBox.getMinY() < boundingBox.getMinY() || resultBox.getMaxY() > boundingBox.getMaxY())) {\n        boundingBox = resultBox;\n      } else {\n        break;\n      }\n    }\n\n    detectionResult.setBoundingBox(boundingBox);\n    var maxBarcodeColumn = detectionResult.getBarcodeColumnCount() + 1;\n    detectionResult.setDetectionResultColumn(0, leftRowIndicatorColumn);\n    detectionResult.setDetectionResultColumn(maxBarcodeColumn, rightRowIndicatorColumn);\n    var leftToRight = leftRowIndicatorColumn != null;\n\n    for (var barcodeColumnCount\n    /*int*/\n    = 1; barcodeColumnCount <= maxBarcodeColumn; barcodeColumnCount++) {\n      var barcodeColumn = leftToRight ? barcodeColumnCount : maxBarcodeColumn - barcodeColumnCount;\n\n      if (detectionResult.getDetectionResultColumn(barcodeColumn) !==\n      /* null */\n      undefined) {\n        // This will be the case for the opposite row indicator column, which doesn't need to be decoded again.\n        continue;\n      }\n\n      var detectionResultColumn = void 0;\n\n      if (barcodeColumn === 0 || barcodeColumn === maxBarcodeColumn) {\n        detectionResultColumn = new DetectionResultRowIndicatorColumn_1.default(boundingBox, barcodeColumn === 0);\n      } else {\n        detectionResultColumn = new DetectionResultColumn_1.default(boundingBox);\n      }\n\n      detectionResult.setDetectionResultColumn(barcodeColumn, detectionResultColumn);\n      var startColumn = -1;\n      var previousStartColumn = startColumn; // TODO start at a row for which we know the start position, then detect upwards and downwards from there.\n\n      for (var imageRow\n      /*int*/\n      = boundingBox.getMinY(); imageRow <= boundingBox.getMaxY(); imageRow++) {\n        startColumn = PDF417ScanningDecoder.getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight);\n\n        if (startColumn < 0 || startColumn > boundingBox.getMaxX()) {\n          if (previousStartColumn === -1) {\n            continue;\n          }\n\n          startColumn = previousStartColumn;\n        }\n\n        var codeword = PDF417ScanningDecoder.detectCodeword(image, boundingBox.getMinX(), boundingBox.getMaxX(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);\n\n        if (codeword != null) {\n          detectionResultColumn.setCodeword(imageRow, codeword);\n          previousStartColumn = startColumn;\n          minCodewordWidth = Math.min(minCodewordWidth, codeword.getWidth());\n          maxCodewordWidth = Math.max(maxCodewordWidth, codeword.getWidth());\n        }\n      }\n    }\n\n    return PDF417ScanningDecoder.createDecoderResult(detectionResult);\n  };\n  /**\n   *\n   * @param leftRowIndicatorColumn\n   * @param rightRowIndicatorColumn\n   *\n   * @throws NotFoundException\n   */\n\n\n  PDF417ScanningDecoder.merge = function (leftRowIndicatorColumn, rightRowIndicatorColumn) {\n    if (leftRowIndicatorColumn == null && rightRowIndicatorColumn == null) {\n      return null;\n    }\n\n    var barcodeMetadata = PDF417ScanningDecoder.getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn);\n\n    if (barcodeMetadata == null) {\n      return null;\n    }\n\n    var boundingBox = BoundingBox_1.default.merge(PDF417ScanningDecoder.adjustBoundingBox(leftRowIndicatorColumn), PDF417ScanningDecoder.adjustBoundingBox(rightRowIndicatorColumn));\n    return new DetectionResult_1.default(barcodeMetadata, boundingBox);\n  };\n  /**\n   *\n   * @param rowIndicatorColumn\n   *\n   * @throws NotFoundException\n   */\n\n\n  PDF417ScanningDecoder.adjustBoundingBox = function (rowIndicatorColumn) {\n    var e_1, _a;\n\n    if (rowIndicatorColumn == null) {\n      return null;\n    }\n\n    var rowHeights = rowIndicatorColumn.getRowHeights();\n\n    if (rowHeights == null) {\n      return null;\n    }\n\n    var maxRowHeight = PDF417ScanningDecoder.getMax(rowHeights);\n    var missingStartRows = 0;\n\n    try {\n      for (var rowHeights_1 = __values(rowHeights), rowHeights_1_1 = rowHeights_1.next(); !rowHeights_1_1.done; rowHeights_1_1 = rowHeights_1.next()) {\n        var rowHeight = rowHeights_1_1.value\n        /*int*/\n        ;\n        missingStartRows += maxRowHeight - rowHeight;\n\n        if (rowHeight > 0) {\n          break;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (rowHeights_1_1 && !rowHeights_1_1.done && (_a = rowHeights_1.return)) _a.call(rowHeights_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    var codewords = rowIndicatorColumn.getCodewords();\n\n    for (var row\n    /*int*/\n    = 0; missingStartRows > 0 && codewords[row] == null; row++) {\n      missingStartRows--;\n    }\n\n    var missingEndRows = 0;\n\n    for (var row\n    /*int*/\n    = rowHeights.length - 1; row >= 0; row--) {\n      missingEndRows += maxRowHeight - rowHeights[row];\n\n      if (rowHeights[row] > 0) {\n        break;\n      }\n    }\n\n    for (var row\n    /*int*/\n    = codewords.length - 1; missingEndRows > 0 && codewords[row] == null; row--) {\n      missingEndRows--;\n    }\n\n    return rowIndicatorColumn.getBoundingBox().addMissingRows(missingStartRows, missingEndRows, rowIndicatorColumn.isLeft());\n  };\n\n  PDF417ScanningDecoder.getMax = function (values) {\n    var e_2, _a;\n\n    var maxValue = -1;\n\n    try {\n      for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {\n        var value = values_1_1.value\n        /*int*/\n        ;\n        maxValue = Math.max(maxValue, value);\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    return maxValue;\n  };\n\n  PDF417ScanningDecoder.getBarcodeMetadata = function (leftRowIndicatorColumn, rightRowIndicatorColumn) {\n    var leftBarcodeMetadata;\n\n    if (leftRowIndicatorColumn == null || (leftBarcodeMetadata = leftRowIndicatorColumn.getBarcodeMetadata()) == null) {\n      return rightRowIndicatorColumn == null ? null : rightRowIndicatorColumn.getBarcodeMetadata();\n    }\n\n    var rightBarcodeMetadata;\n\n    if (rightRowIndicatorColumn == null || (rightBarcodeMetadata = rightRowIndicatorColumn.getBarcodeMetadata()) == null) {\n      return leftBarcodeMetadata;\n    }\n\n    if (leftBarcodeMetadata.getColumnCount() !== rightBarcodeMetadata.getColumnCount() && leftBarcodeMetadata.getErrorCorrectionLevel() !== rightBarcodeMetadata.getErrorCorrectionLevel() && leftBarcodeMetadata.getRowCount() !== rightBarcodeMetadata.getRowCount()) {\n      return null;\n    }\n\n    return leftBarcodeMetadata;\n  };\n\n  PDF417ScanningDecoder.getRowIndicatorColumn = function (image, boundingBox, startPoint, leftToRight, minCodewordWidth, maxCodewordWidth) {\n    var rowIndicatorColumn = new DetectionResultRowIndicatorColumn_1.default(boundingBox, leftToRight);\n\n    for (var i\n    /*int*/\n    = 0; i < 2; i++) {\n      var increment = i === 0 ? 1 : -1;\n      var startColumn = Math.trunc(Math.trunc(startPoint.getX()));\n\n      for (var imageRow\n      /*int*/\n      = Math.trunc(Math.trunc(startPoint.getY())); imageRow <= boundingBox.getMaxY() && imageRow >= boundingBox.getMinY(); imageRow += increment) {\n        var codeword = PDF417ScanningDecoder.detectCodeword(image, 0, image.getWidth(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);\n\n        if (codeword != null) {\n          rowIndicatorColumn.setCodeword(imageRow, codeword);\n\n          if (leftToRight) {\n            startColumn = codeword.getStartX();\n          } else {\n            startColumn = codeword.getEndX();\n          }\n        }\n      }\n    }\n\n    return rowIndicatorColumn;\n  };\n  /**\n   *\n   * @param detectionResult\n   * @param BarcodeValue\n   * @param param2\n   * @param param3\n   * @param barcodeMatrix\n   *\n   * @throws NotFoundException\n   */\n\n\n  PDF417ScanningDecoder.adjustCodewordCount = function (detectionResult, barcodeMatrix) {\n    var barcodeMatrix01 = barcodeMatrix[0][1];\n    var numberOfCodewords = barcodeMatrix01.getValue();\n    var calculatedNumberOfCodewords = detectionResult.getBarcodeColumnCount() * detectionResult.getBarcodeRowCount() - PDF417ScanningDecoder.getNumberOfECCodeWords(detectionResult.getBarcodeECLevel());\n\n    if (numberOfCodewords.length === 0) {\n      if (calculatedNumberOfCodewords < 1 || calculatedNumberOfCodewords > PDF417Common_1.default.MAX_CODEWORDS_IN_BARCODE) {\n        throw NotFoundException_1.default.getNotFoundInstance();\n      }\n\n      barcodeMatrix01.setValue(calculatedNumberOfCodewords);\n    } else if (numberOfCodewords[0] !== calculatedNumberOfCodewords) {\n      // The calculated one is more reliable as it is derived from the row indicator columns\n      barcodeMatrix01.setValue(calculatedNumberOfCodewords);\n    }\n  };\n  /**\n   *\n   * @param detectionResult\n   *\n   * @throws FormatException\n   * @throws ChecksumException\n   * @throws NotFoundException\n   */\n\n\n  PDF417ScanningDecoder.createDecoderResult = function (detectionResult) {\n    var barcodeMatrix = PDF417ScanningDecoder.createBarcodeMatrix(detectionResult);\n    PDF417ScanningDecoder.adjustCodewordCount(detectionResult, barcodeMatrix);\n    var erasures\n    /*Collection<Integer>*/\n    = new Array();\n    var codewords = new Int32Array(detectionResult.getBarcodeRowCount() * detectionResult.getBarcodeColumnCount());\n    var ambiguousIndexValuesList =\n    /*List<int[]>*/\n    [];\n    var ambiguousIndexesList =\n    /*Collection<Integer>*/\n    new Array();\n\n    for (var row\n    /*int*/\n    = 0; row < detectionResult.getBarcodeRowCount(); row++) {\n      for (var column\n      /*int*/\n      = 0; column < detectionResult.getBarcodeColumnCount(); column++) {\n        var values = barcodeMatrix[row][column + 1].getValue();\n        var codewordIndex = row * detectionResult.getBarcodeColumnCount() + column;\n\n        if (values.length === 0) {\n          erasures.push(codewordIndex);\n        } else if (values.length === 1) {\n          codewords[codewordIndex] = values[0];\n        } else {\n          ambiguousIndexesList.push(codewordIndex);\n          ambiguousIndexValuesList.push(values);\n        }\n      }\n    }\n\n    var ambiguousIndexValues = new Array(ambiguousIndexValuesList.length);\n\n    for (var i\n    /*int*/\n    = 0; i < ambiguousIndexValues.length; i++) {\n      ambiguousIndexValues[i] = ambiguousIndexValuesList[i];\n    }\n\n    return PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues(detectionResult.getBarcodeECLevel(), codewords, PDF417Common_1.default.toIntArray(erasures), PDF417Common_1.default.toIntArray(ambiguousIndexesList), ambiguousIndexValues);\n  };\n  /**\n   * This method deals with the fact, that the decoding process doesn't always yield a single most likely value. The\n   * current error correction implementation doesn't deal with erasures very well, so it's better to provide a value\n   * for these ambiguous codewords instead of treating it as an erasure. The problem is that we don't know which of\n   * the ambiguous values to choose. We try decode using the first value, and if that fails, we use another of the\n   * ambiguous values and try to decode again. This usually only happens on very hard to read and decode barcodes,\n   * so decoding the normal barcodes is not affected by this.\n   *\n   * @param erasureArray contains the indexes of erasures\n   * @param ambiguousIndexes array with the indexes that have more than one most likely value\n   * @param ambiguousIndexValues two dimensional array that contains the ambiguous values. The first dimension must\n   * be the same length as the ambiguousIndexes array\n   *\n   * @throws FormatException\n   * @throws ChecksumException\n   */\n\n\n  PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues = function (ecLevel, codewords, erasureArray, ambiguousIndexes, ambiguousIndexValues) {\n    var ambiguousIndexCount = new Int32Array(ambiguousIndexes.length);\n    var tries = 100;\n\n    while (tries-- > 0) {\n      for (var i\n      /*int*/\n      = 0; i < ambiguousIndexCount.length; i++) {\n        codewords[ambiguousIndexes[i]] = ambiguousIndexValues[i][ambiguousIndexCount[i]];\n      }\n\n      try {\n        return PDF417ScanningDecoder.decodeCodewords(codewords, ecLevel, erasureArray);\n      } catch (err) {\n        var ignored = err instanceof ChecksumException_1.default;\n\n        if (!ignored) {\n          throw err;\n        }\n      }\n\n      if (ambiguousIndexCount.length === 0) {\n        throw ChecksumException_1.default.getChecksumInstance();\n      }\n\n      for (var i\n      /*int*/\n      = 0; i < ambiguousIndexCount.length; i++) {\n        if (ambiguousIndexCount[i] < ambiguousIndexValues[i].length - 1) {\n          ambiguousIndexCount[i]++;\n          break;\n        } else {\n          ambiguousIndexCount[i] = 0;\n\n          if (i === ambiguousIndexCount.length - 1) {\n            throw ChecksumException_1.default.getChecksumInstance();\n          }\n        }\n      }\n    }\n\n    throw ChecksumException_1.default.getChecksumInstance();\n  };\n\n  PDF417ScanningDecoder.createBarcodeMatrix = function (detectionResult) {\n    var e_3, _a, e_4, _b; // let barcodeMatrix: BarcodeValue[][] =\n    // new BarcodeValue[detectionResult.getBarcodeRowCount()][detectionResult.getBarcodeColumnCount() + 2];\n\n\n    var barcodeMatrix = Array.from({\n      length: detectionResult.getBarcodeRowCount()\n    }, function () {\n      return new Array(detectionResult.getBarcodeColumnCount() + 2);\n    });\n\n    for (var row\n    /*int*/\n    = 0; row < barcodeMatrix.length; row++) {\n      for (var column_1\n      /*int*/\n      = 0; column_1 < barcodeMatrix[row].length; column_1++) {\n        barcodeMatrix[row][column_1] = new BarcodeValue_1.default();\n      }\n    }\n\n    var column = 0;\n\n    try {\n      for (var _c = __values(detectionResult.getDetectionResultColumns()), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var detectionResultColumn = _d.value\n        /*DetectionResultColumn*/\n        ;\n\n        if (detectionResultColumn != null) {\n          try {\n            for (var _e = __values(detectionResultColumn.getCodewords()), _f = _e.next(); !_f.done; _f = _e.next()) {\n              var codeword = _f.value\n              /*Codeword*/\n              ;\n\n              if (codeword != null) {\n                var rowNumber = codeword.getRowNumber();\n\n                if (rowNumber >= 0) {\n                  if (rowNumber >= barcodeMatrix.length) {\n                    // We have more rows than the barcode metadata allows for, ignore them.\n                    continue;\n                  }\n\n                  barcodeMatrix[rowNumber][column].setValue(codeword.getValue());\n                }\n              }\n            }\n          } catch (e_4_1) {\n            e_4 = {\n              error: e_4_1\n            };\n          } finally {\n            try {\n              if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            } finally {\n              if (e_4) throw e_4.error;\n            }\n          }\n        }\n\n        column++;\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    return barcodeMatrix;\n  };\n\n  PDF417ScanningDecoder.isValidBarcodeColumn = function (detectionResult, barcodeColumn) {\n    return barcodeColumn >= 0 && barcodeColumn <= detectionResult.getBarcodeColumnCount() + 1;\n  };\n\n  PDF417ScanningDecoder.getStartColumn = function (detectionResult, barcodeColumn, imageRow, leftToRight) {\n    var e_5, _a;\n\n    var offset = leftToRight ? 1 : -1;\n    var codeword = null;\n\n    if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n      codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodeword(imageRow);\n    }\n\n    if (codeword != null) {\n      return leftToRight ? codeword.getEndX() : codeword.getStartX();\n    }\n\n    codeword = detectionResult.getDetectionResultColumn(barcodeColumn).getCodewordNearby(imageRow);\n\n    if (codeword != null) {\n      return leftToRight ? codeword.getStartX() : codeword.getEndX();\n    }\n\n    if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n      codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodewordNearby(imageRow);\n    }\n\n    if (codeword != null) {\n      return leftToRight ? codeword.getEndX() : codeword.getStartX();\n    }\n\n    var skippedColumns = 0;\n\n    while (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n      barcodeColumn -= offset;\n\n      try {\n        for (var _b = __values(detectionResult.getDetectionResultColumn(barcodeColumn).getCodewords()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var previousRowCodeword = _c.value\n          /*Codeword*/\n          ;\n\n          if (previousRowCodeword != null) {\n            return (leftToRight ? previousRowCodeword.getEndX() : previousRowCodeword.getStartX()) + offset * skippedColumns * (previousRowCodeword.getEndX() - previousRowCodeword.getStartX());\n          }\n        }\n      } catch (e_5_1) {\n        e_5 = {\n          error: e_5_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_5) throw e_5.error;\n        }\n      }\n\n      skippedColumns++;\n    }\n\n    return leftToRight ? detectionResult.getBoundingBox().getMinX() : detectionResult.getBoundingBox().getMaxX();\n  };\n\n  PDF417ScanningDecoder.detectCodeword = function (image, minColumn, maxColumn, leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth) {\n    startColumn = PDF417ScanningDecoder.adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, startColumn, imageRow); // we usually know fairly exact now how long a codeword is. We should provide minimum and maximum expected length\n    // and try to adjust the read pixels, e.g. remove single pixel errors or try to cut off exceeding pixels.\n    // min and maxCodewordWidth should not be used as they are calculated for the whole barcode an can be inaccurate\n    // for the current position\n\n    var moduleBitCount = PDF417ScanningDecoder.getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);\n\n    if (moduleBitCount == null) {\n      return null;\n    }\n\n    var endColumn;\n    var codewordBitCount = MathUtils_1.default.sum(moduleBitCount);\n\n    if (leftToRight) {\n      endColumn = startColumn + codewordBitCount;\n    } else {\n      for (var i\n      /*int*/\n      = 0; i < moduleBitCount.length / 2; i++) {\n        var tmpCount = moduleBitCount[i];\n        moduleBitCount[i] = moduleBitCount[moduleBitCount.length - 1 - i];\n        moduleBitCount[moduleBitCount.length - 1 - i] = tmpCount;\n      }\n\n      endColumn = startColumn;\n      startColumn = endColumn - codewordBitCount;\n    } // TODO implement check for width and correction of black and white bars\n    // use start (and maybe stop pattern) to determine if black bars are wider than white bars. If so, adjust.\n    // should probably done only for codewords with a lot more than 17 bits.\n    // The following fixes 10-1.png, which has wide black bars and small white bars\n    //    for (let i /*int*/ = 0; i < moduleBitCount.length; i++) {\n    //      if (i % 2 === 0) {\n    //        moduleBitCount[i]--;\n    //      } else {\n    //        moduleBitCount[i]++;\n    //      }\n    //    }\n    // We could also use the width of surrounding codewords for more accurate results, but this seems\n    // sufficient for now\n\n\n    if (!PDF417ScanningDecoder.checkCodewordSkew(codewordBitCount, minCodewordWidth, maxCodewordWidth)) {\n      // We could try to use the startX and endX position of the codeword in the same column in the previous row,\n      // create the bit count from it and normalize it to 8. This would help with single pixel errors.\n      return null;\n    }\n\n    var decodedValue = PDF417CodewordDecoder_1.default.getDecodedValue(moduleBitCount);\n    var codeword = PDF417Common_1.default.getCodeword(decodedValue);\n\n    if (codeword === -1) {\n      return null;\n    }\n\n    return new Codeword_1.default(startColumn, endColumn, PDF417ScanningDecoder.getCodewordBucketNumber(decodedValue), codeword);\n  };\n\n  PDF417ScanningDecoder.getModuleBitCount = function (image, minColumn, maxColumn, leftToRight, startColumn, imageRow) {\n    var imageColumn = startColumn;\n    var moduleBitCount = new Int32Array(8);\n    var moduleNumber = 0;\n    var increment = leftToRight ? 1 : -1;\n    var previousPixelValue = leftToRight;\n\n    while ((leftToRight ? imageColumn < maxColumn : imageColumn >= minColumn) && moduleNumber < moduleBitCount.length) {\n      if (image.get(imageColumn, imageRow) === previousPixelValue) {\n        moduleBitCount[moduleNumber]++;\n        imageColumn += increment;\n      } else {\n        moduleNumber++;\n        previousPixelValue = !previousPixelValue;\n      }\n    }\n\n    if (moduleNumber === moduleBitCount.length || imageColumn === (leftToRight ? maxColumn : minColumn) && moduleNumber === moduleBitCount.length - 1) {\n      return moduleBitCount;\n    }\n\n    return null;\n  };\n\n  PDF417ScanningDecoder.getNumberOfECCodeWords = function (barcodeECLevel) {\n    return 2 << barcodeECLevel;\n  };\n\n  PDF417ScanningDecoder.adjustCodewordStartColumn = function (image, minColumn, maxColumn, leftToRight, codewordStartColumn, imageRow) {\n    var correctedStartColumn = codewordStartColumn;\n    var increment = leftToRight ? -1 : 1; // there should be no black pixels before the start column. If there are, then we need to start earlier.\n\n    for (var i\n    /*int*/\n    = 0; i < 2; i++) {\n      while ((leftToRight ? correctedStartColumn >= minColumn : correctedStartColumn < maxColumn) && leftToRight === image.get(correctedStartColumn, imageRow)) {\n        if (Math.abs(codewordStartColumn - correctedStartColumn) > PDF417ScanningDecoder.CODEWORD_SKEW_SIZE) {\n          return codewordStartColumn;\n        }\n\n        correctedStartColumn += increment;\n      }\n\n      increment = -increment;\n      leftToRight = !leftToRight;\n    }\n\n    return correctedStartColumn;\n  };\n\n  PDF417ScanningDecoder.checkCodewordSkew = function (codewordSize, minCodewordWidth, maxCodewordWidth) {\n    return minCodewordWidth - PDF417ScanningDecoder.CODEWORD_SKEW_SIZE <= codewordSize && codewordSize <= maxCodewordWidth + PDF417ScanningDecoder.CODEWORD_SKEW_SIZE;\n  };\n  /**\n   * @throws FormatException,\n   * @throws ChecksumException\n   */\n\n\n  PDF417ScanningDecoder.decodeCodewords = function (codewords, ecLevel, erasures) {\n    if (codewords.length === 0) {\n      throw FormatException_1.default.getFormatInstance();\n    }\n\n    var numECCodewords = 1 << ecLevel + 1;\n    var correctedErrorsCount = PDF417ScanningDecoder.correctErrors(codewords, erasures, numECCodewords);\n    PDF417ScanningDecoder.verifyCodewordCount(codewords, numECCodewords); // Decode the codewords\n\n    var decoderResult = DecodedBitStreamParser_1.default.decode(codewords, '' + ecLevel);\n    decoderResult.setErrorsCorrected(correctedErrorsCount);\n    decoderResult.setErasures(erasures.length);\n    return decoderResult;\n  };\n  /**\n   * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\n   * correct the errors in-place.</p>\n   *\n   * @param codewords   data and error correction codewords\n   * @param erasures positions of any known erasures\n   * @param numECCodewords number of error correction codewords that are available in codewords\n   * @throws ChecksumException if error correction fails\n   */\n\n\n  PDF417ScanningDecoder.correctErrors = function (codewords, erasures, numECCodewords) {\n    if (erasures != null && erasures.length > numECCodewords / 2 + PDF417ScanningDecoder.MAX_ERRORS || numECCodewords < 0 || numECCodewords > PDF417ScanningDecoder.MAX_EC_CODEWORDS) {\n      // Too many errors or EC Codewords is corrupted\n      throw ChecksumException_1.default.getChecksumInstance();\n    }\n\n    return PDF417ScanningDecoder.errorCorrection.decode(codewords, numECCodewords, erasures);\n  };\n  /**\n   * Verify that all is OK with the codeword array.\n   * @throws FormatException\n   */\n\n\n  PDF417ScanningDecoder.verifyCodewordCount = function (codewords, numECCodewords) {\n    if (codewords.length < 4) {\n      // Codeword array size should be at least 4 allowing for\n      // Count CW, At least one Data CW, Error Correction CW, Error Correction CW\n      throw FormatException_1.default.getFormatInstance();\n    } // The first codeword, the Symbol Length Descriptor, shall always encode the total number of data\n    // codewords in the symbol, including the Symbol Length Descriptor itself, data codewords and pad\n    // codewords, but excluding the number of error correction codewords.\n\n\n    var numberOfCodewords = codewords[0];\n\n    if (numberOfCodewords > codewords.length) {\n      throw FormatException_1.default.getFormatInstance();\n    }\n\n    if (numberOfCodewords === 0) {\n      // Reset to the length of the array - 8 (Allow for at least level 3 Error Correction (8 Error Codewords)\n      if (numECCodewords < codewords.length) {\n        codewords[0] = codewords.length - numECCodewords;\n      } else {\n        throw FormatException_1.default.getFormatInstance();\n      }\n    }\n  };\n\n  PDF417ScanningDecoder.getBitCountForCodeword = function (codeword) {\n    var result = new Int32Array(8);\n    var previousValue = 0;\n    var i = result.length - 1;\n\n    while (true) {\n      if ((codeword & 0x1) !== previousValue) {\n        previousValue = codeword & 0x1;\n        i--;\n\n        if (i < 0) {\n          break;\n        }\n      }\n\n      result[i]++;\n      codeword >>= 1;\n    }\n\n    return result;\n  };\n\n  PDF417ScanningDecoder.getCodewordBucketNumber = function (codeword) {\n    if (codeword instanceof Int32Array) {\n      return this.getCodewordBucketNumber_Int32Array(codeword);\n    }\n\n    return this.getCodewordBucketNumber_number(codeword);\n  };\n\n  PDF417ScanningDecoder.getCodewordBucketNumber_number = function (codeword) {\n    return PDF417ScanningDecoder.getCodewordBucketNumber(PDF417ScanningDecoder.getBitCountForCodeword(codeword));\n  };\n\n  PDF417ScanningDecoder.getCodewordBucketNumber_Int32Array = function (moduleBitCount) {\n    return (moduleBitCount[0] - moduleBitCount[2] + moduleBitCount[4] - moduleBitCount[6] + 9) % 9;\n  };\n\n  PDF417ScanningDecoder.toString = function (barcodeMatrix) {\n    var formatter = new Formatter_1.default(); // try (let formatter = new Formatter()) {\n\n    for (var row\n    /*int*/\n    = 0; row < barcodeMatrix.length; row++) {\n      formatter.format('Row %2d: ', row);\n\n      for (var column\n      /*int*/\n      = 0; column < barcodeMatrix[row].length; column++) {\n        var barcodeValue = barcodeMatrix[row][column];\n\n        if (barcodeValue.getValue().length === 0) {\n          formatter.format('        ', null);\n        } else {\n          formatter.format('%4d(%2d)', barcodeValue.getValue()[0], barcodeValue.getConfidence(barcodeValue.getValue()[0]));\n        }\n      }\n\n      formatter.format('%n');\n    }\n\n    return formatter.toString(); // }\n  };\n  /*final*/\n\n\n  PDF417ScanningDecoder.CODEWORD_SKEW_SIZE = 2;\n  /*final*/\n\n  PDF417ScanningDecoder.MAX_ERRORS = 3;\n  /*final*/\n\n  PDF417ScanningDecoder.MAX_EC_CODEWORDS = 512;\n  /*final*/\n\n  PDF417ScanningDecoder.errorCorrection = new ErrorCorrection_1.default();\n  return PDF417ScanningDecoder;\n}();\n\nexports.default = PDF417ScanningDecoder;","map":{"version":3,"sources":["../../../../src/core/pdf417/decoder/PDF417ScanningDecoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n* Copyright 2013 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// package com.google.zxing.pdf417.decoder;\n// import com.google.zxing.ChecksumException;\nvar ChecksumException_1 = require(\"../../ChecksumException\");\n// import com.google.zxing.FormatException;\nvar FormatException_1 = require(\"../../FormatException\");\n// import com.google.zxing.NotFoundException;\nvar NotFoundException_1 = require(\"../../NotFoundException\");\n// import com.google.zxing.common.detector.MathUtils;\nvar MathUtils_1 = require(\"../../common/detector/MathUtils\");\n// import com.google.zxing.pdf417.PDF417Common;\nvar PDF417Common_1 = require(\"../PDF417Common\");\n// import com.google.zxing.pdf417.decoder.ec.ErrorCorrection;\nvar ErrorCorrection_1 = require(\"./ec/ErrorCorrection\");\n// local\nvar BoundingBox_1 = require(\"./BoundingBox\");\nvar DetectionResultRowIndicatorColumn_1 = require(\"./DetectionResultRowIndicatorColumn\");\nvar DetectionResult_1 = require(\"./DetectionResult\");\nvar DetectionResultColumn_1 = require(\"./DetectionResultColumn\");\nvar Codeword_1 = require(\"./Codeword\");\nvar BarcodeValue_1 = require(\"./BarcodeValue\");\nvar PDF417CodewordDecoder_1 = require(\"./PDF417CodewordDecoder\");\nvar DecodedBitStreamParser_1 = require(\"./DecodedBitStreamParser\");\n// utils\nvar Formatter_1 = require(\"../../util/Formatter\");\n// import java.util.ArrayList;\n// import java.util.Collection;\n// import java.util.Formatter;\n// import java.util.List;\n/**\n * @author Guenther Grau\n */\nvar PDF417ScanningDecoder = /** @class */ (function () {\n    function PDF417ScanningDecoder() {\n    }\n    /**\n     * @TODO don't pass in minCodewordWidth and maxCodewordWidth, pass in barcode columns for start and stop pattern\n     *\n     * columns. That way width can be deducted from the pattern column.\n     * This approach also allows to detect more details about the barcode, e.g. if a bar type (white or black) is wider\n     * than it should be. This can happen if the scanner used a bad blackpoint.\n     *\n     * @param BitMatrix\n     * @param image\n     * @param ResultPoint\n     * @param imageTopLeft\n     * @param ResultPoint\n     * @param imageBottomLeft\n     * @param ResultPoint\n     * @param imageTopRight\n     * @param ResultPoint\n     * @param imageBottomRight\n     * @param int\n     * @param minCodewordWidth\n     * @param int\n     * @param maxCodewordWidth\n     *\n     * @throws NotFoundException\n     * @throws FormatException\n     * @throws ChecksumException\n     */\n    PDF417ScanningDecoder.decode = function (image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight, minCodewordWidth, maxCodewordWidth) {\n        var boundingBox = new BoundingBox_1.default(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight);\n        var leftRowIndicatorColumn = null;\n        var rightRowIndicatorColumn = null;\n        var detectionResult;\n        for (var firstPass /*boolean*/ = true;; firstPass = false) {\n            if (imageTopLeft != null) {\n                leftRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopLeft, true, minCodewordWidth, maxCodewordWidth);\n            }\n            if (imageTopRight != null) {\n                rightRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopRight, false, minCodewordWidth, maxCodewordWidth);\n            }\n            detectionResult = PDF417ScanningDecoder.merge(leftRowIndicatorColumn, rightRowIndicatorColumn);\n            if (detectionResult == null) {\n                throw NotFoundException_1.default.getNotFoundInstance();\n            }\n            var resultBox = detectionResult.getBoundingBox();\n            if (firstPass && resultBox != null &&\n                (resultBox.getMinY() < boundingBox.getMinY() || resultBox.getMaxY() > boundingBox.getMaxY())) {\n                boundingBox = resultBox;\n            }\n            else {\n                break;\n            }\n        }\n        detectionResult.setBoundingBox(boundingBox);\n        var maxBarcodeColumn = detectionResult.getBarcodeColumnCount() + 1;\n        detectionResult.setDetectionResultColumn(0, leftRowIndicatorColumn);\n        detectionResult.setDetectionResultColumn(maxBarcodeColumn, rightRowIndicatorColumn);\n        var leftToRight = leftRowIndicatorColumn != null;\n        for (var barcodeColumnCount /*int*/ = 1; barcodeColumnCount <= maxBarcodeColumn; barcodeColumnCount++) {\n            var barcodeColumn = leftToRight ? barcodeColumnCount : maxBarcodeColumn - barcodeColumnCount;\n            if (detectionResult.getDetectionResultColumn(barcodeColumn) !== /* null */ undefined) {\n                // This will be the case for the opposite row indicator column, which doesn't need to be decoded again.\n                continue;\n            }\n            var detectionResultColumn = void 0;\n            if (barcodeColumn === 0 || barcodeColumn === maxBarcodeColumn) {\n                detectionResultColumn = new DetectionResultRowIndicatorColumn_1.default(boundingBox, barcodeColumn === 0);\n            }\n            else {\n                detectionResultColumn = new DetectionResultColumn_1.default(boundingBox);\n            }\n            detectionResult.setDetectionResultColumn(barcodeColumn, detectionResultColumn);\n            var startColumn = -1;\n            var previousStartColumn = startColumn;\n            // TODO start at a row for which we know the start position, then detect upwards and downwards from there.\n            for (var imageRow /*int*/ = boundingBox.getMinY(); imageRow <= boundingBox.getMaxY(); imageRow++) {\n                startColumn = PDF417ScanningDecoder.getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight);\n                if (startColumn < 0 || startColumn > boundingBox.getMaxX()) {\n                    if (previousStartColumn === -1) {\n                        continue;\n                    }\n                    startColumn = previousStartColumn;\n                }\n                var codeword = PDF417ScanningDecoder.detectCodeword(image, boundingBox.getMinX(), boundingBox.getMaxX(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);\n                if (codeword != null) {\n                    detectionResultColumn.setCodeword(imageRow, codeword);\n                    previousStartColumn = startColumn;\n                    minCodewordWidth = Math.min(minCodewordWidth, codeword.getWidth());\n                    maxCodewordWidth = Math.max(maxCodewordWidth, codeword.getWidth());\n                }\n            }\n        }\n        return PDF417ScanningDecoder.createDecoderResult(detectionResult);\n    };\n    /**\n     *\n     * @param leftRowIndicatorColumn\n     * @param rightRowIndicatorColumn\n     *\n     * @throws NotFoundException\n     */\n    PDF417ScanningDecoder.merge = function (leftRowIndicatorColumn, rightRowIndicatorColumn) {\n        if (leftRowIndicatorColumn == null && rightRowIndicatorColumn == null) {\n            return null;\n        }\n        var barcodeMetadata = PDF417ScanningDecoder.getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn);\n        if (barcodeMetadata == null) {\n            return null;\n        }\n        var boundingBox = BoundingBox_1.default.merge(PDF417ScanningDecoder.adjustBoundingBox(leftRowIndicatorColumn), PDF417ScanningDecoder.adjustBoundingBox(rightRowIndicatorColumn));\n        return new DetectionResult_1.default(barcodeMetadata, boundingBox);\n    };\n    /**\n     *\n     * @param rowIndicatorColumn\n     *\n     * @throws NotFoundException\n     */\n    PDF417ScanningDecoder.adjustBoundingBox = function (rowIndicatorColumn) {\n        var e_1, _a;\n        if (rowIndicatorColumn == null) {\n            return null;\n        }\n        var rowHeights = rowIndicatorColumn.getRowHeights();\n        if (rowHeights == null) {\n            return null;\n        }\n        var maxRowHeight = PDF417ScanningDecoder.getMax(rowHeights);\n        var missingStartRows = 0;\n        try {\n            for (var rowHeights_1 = __values(rowHeights), rowHeights_1_1 = rowHeights_1.next(); !rowHeights_1_1.done; rowHeights_1_1 = rowHeights_1.next()) {\n                var rowHeight = rowHeights_1_1.value /*int*/;\n                missingStartRows += maxRowHeight - rowHeight;\n                if (rowHeight > 0) {\n                    break;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (rowHeights_1_1 && !rowHeights_1_1.done && (_a = rowHeights_1.return)) _a.call(rowHeights_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        var codewords = rowIndicatorColumn.getCodewords();\n        for (var row /*int*/ = 0; missingStartRows > 0 && codewords[row] == null; row++) {\n            missingStartRows--;\n        }\n        var missingEndRows = 0;\n        for (var row /*int*/ = rowHeights.length - 1; row >= 0; row--) {\n            missingEndRows += maxRowHeight - rowHeights[row];\n            if (rowHeights[row] > 0) {\n                break;\n            }\n        }\n        for (var row /*int*/ = codewords.length - 1; missingEndRows > 0 && codewords[row] == null; row--) {\n            missingEndRows--;\n        }\n        return rowIndicatorColumn.getBoundingBox().addMissingRows(missingStartRows, missingEndRows, rowIndicatorColumn.isLeft());\n    };\n    PDF417ScanningDecoder.getMax = function (values) {\n        var e_2, _a;\n        var maxValue = -1;\n        try {\n            for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {\n                var value = values_1_1.value /*int*/;\n                maxValue = Math.max(maxValue, value);\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return maxValue;\n    };\n    PDF417ScanningDecoder.getBarcodeMetadata = function (leftRowIndicatorColumn, rightRowIndicatorColumn) {\n        var leftBarcodeMetadata;\n        if (leftRowIndicatorColumn == null ||\n            (leftBarcodeMetadata = leftRowIndicatorColumn.getBarcodeMetadata()) == null) {\n            return rightRowIndicatorColumn == null ? null : rightRowIndicatorColumn.getBarcodeMetadata();\n        }\n        var rightBarcodeMetadata;\n        if (rightRowIndicatorColumn == null ||\n            (rightBarcodeMetadata = rightRowIndicatorColumn.getBarcodeMetadata()) == null) {\n            return leftBarcodeMetadata;\n        }\n        if (leftBarcodeMetadata.getColumnCount() !== rightBarcodeMetadata.getColumnCount() &&\n            leftBarcodeMetadata.getErrorCorrectionLevel() !== rightBarcodeMetadata.getErrorCorrectionLevel() &&\n            leftBarcodeMetadata.getRowCount() !== rightBarcodeMetadata.getRowCount()) {\n            return null;\n        }\n        return leftBarcodeMetadata;\n    };\n    PDF417ScanningDecoder.getRowIndicatorColumn = function (image, boundingBox, startPoint, leftToRight, minCodewordWidth, maxCodewordWidth) {\n        var rowIndicatorColumn = new DetectionResultRowIndicatorColumn_1.default(boundingBox, leftToRight);\n        for (var i /*int*/ = 0; i < 2; i++) {\n            var increment = i === 0 ? 1 : -1;\n            var startColumn = Math.trunc(Math.trunc(startPoint.getX()));\n            for (var imageRow /*int*/ = Math.trunc(Math.trunc(startPoint.getY())); imageRow <= boundingBox.getMaxY() &&\n                imageRow >= boundingBox.getMinY(); imageRow += increment) {\n                var codeword = PDF417ScanningDecoder.detectCodeword(image, 0, image.getWidth(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);\n                if (codeword != null) {\n                    rowIndicatorColumn.setCodeword(imageRow, codeword);\n                    if (leftToRight) {\n                        startColumn = codeword.getStartX();\n                    }\n                    else {\n                        startColumn = codeword.getEndX();\n                    }\n                }\n            }\n        }\n        return rowIndicatorColumn;\n    };\n    /**\n     *\n     * @param detectionResult\n     * @param BarcodeValue\n     * @param param2\n     * @param param3\n     * @param barcodeMatrix\n     *\n     * @throws NotFoundException\n     */\n    PDF417ScanningDecoder.adjustCodewordCount = function (detectionResult, barcodeMatrix) {\n        var barcodeMatrix01 = barcodeMatrix[0][1];\n        var numberOfCodewords = barcodeMatrix01.getValue();\n        var calculatedNumberOfCodewords = detectionResult.getBarcodeColumnCount() *\n            detectionResult.getBarcodeRowCount() -\n            PDF417ScanningDecoder.getNumberOfECCodeWords(detectionResult.getBarcodeECLevel());\n        if (numberOfCodewords.length === 0) {\n            if (calculatedNumberOfCodewords < 1 || calculatedNumberOfCodewords > PDF417Common_1.default.MAX_CODEWORDS_IN_BARCODE) {\n                throw NotFoundException_1.default.getNotFoundInstance();\n            }\n            barcodeMatrix01.setValue(calculatedNumberOfCodewords);\n        }\n        else if (numberOfCodewords[0] !== calculatedNumberOfCodewords) {\n            // The calculated one is more reliable as it is derived from the row indicator columns\n            barcodeMatrix01.setValue(calculatedNumberOfCodewords);\n        }\n    };\n    /**\n     *\n     * @param detectionResult\n     *\n     * @throws FormatException\n     * @throws ChecksumException\n     * @throws NotFoundException\n     */\n    PDF417ScanningDecoder.createDecoderResult = function (detectionResult) {\n        var barcodeMatrix = PDF417ScanningDecoder.createBarcodeMatrix(detectionResult);\n        PDF417ScanningDecoder.adjustCodewordCount(detectionResult, barcodeMatrix);\n        var erasures /*Collection<Integer>*/ = new Array();\n        var codewords = new Int32Array(detectionResult.getBarcodeRowCount() * detectionResult.getBarcodeColumnCount());\n        var ambiguousIndexValuesList = /*List<int[]>*/ [];\n        var ambiguousIndexesList = /*Collection<Integer>*/ new Array();\n        for (var row /*int*/ = 0; row < detectionResult.getBarcodeRowCount(); row++) {\n            for (var column /*int*/ = 0; column < detectionResult.getBarcodeColumnCount(); column++) {\n                var values = barcodeMatrix[row][column + 1].getValue();\n                var codewordIndex = row * detectionResult.getBarcodeColumnCount() + column;\n                if (values.length === 0) {\n                    erasures.push(codewordIndex);\n                }\n                else if (values.length === 1) {\n                    codewords[codewordIndex] = values[0];\n                }\n                else {\n                    ambiguousIndexesList.push(codewordIndex);\n                    ambiguousIndexValuesList.push(values);\n                }\n            }\n        }\n        var ambiguousIndexValues = new Array(ambiguousIndexValuesList.length);\n        for (var i /*int*/ = 0; i < ambiguousIndexValues.length; i++) {\n            ambiguousIndexValues[i] = ambiguousIndexValuesList[i];\n        }\n        return PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues(detectionResult.getBarcodeECLevel(), codewords, PDF417Common_1.default.toIntArray(erasures), PDF417Common_1.default.toIntArray(ambiguousIndexesList), ambiguousIndexValues);\n    };\n    /**\n     * This method deals with the fact, that the decoding process doesn't always yield a single most likely value. The\n     * current error correction implementation doesn't deal with erasures very well, so it's better to provide a value\n     * for these ambiguous codewords instead of treating it as an erasure. The problem is that we don't know which of\n     * the ambiguous values to choose. We try decode using the first value, and if that fails, we use another of the\n     * ambiguous values and try to decode again. This usually only happens on very hard to read and decode barcodes,\n     * so decoding the normal barcodes is not affected by this.\n     *\n     * @param erasureArray contains the indexes of erasures\n     * @param ambiguousIndexes array with the indexes that have more than one most likely value\n     * @param ambiguousIndexValues two dimensional array that contains the ambiguous values. The first dimension must\n     * be the same length as the ambiguousIndexes array\n     *\n     * @throws FormatException\n     * @throws ChecksumException\n     */\n    PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues = function (ecLevel, codewords, erasureArray, ambiguousIndexes, ambiguousIndexValues) {\n        var ambiguousIndexCount = new Int32Array(ambiguousIndexes.length);\n        var tries = 100;\n        while (tries-- > 0) {\n            for (var i /*int*/ = 0; i < ambiguousIndexCount.length; i++) {\n                codewords[ambiguousIndexes[i]] = ambiguousIndexValues[i][ambiguousIndexCount[i]];\n            }\n            try {\n                return PDF417ScanningDecoder.decodeCodewords(codewords, ecLevel, erasureArray);\n            }\n            catch (err) {\n                var ignored = err instanceof ChecksumException_1.default;\n                if (!ignored) {\n                    throw err;\n                }\n            }\n            if (ambiguousIndexCount.length === 0) {\n                throw ChecksumException_1.default.getChecksumInstance();\n            }\n            for (var i /*int*/ = 0; i < ambiguousIndexCount.length; i++) {\n                if (ambiguousIndexCount[i] < ambiguousIndexValues[i].length - 1) {\n                    ambiguousIndexCount[i]++;\n                    break;\n                }\n                else {\n                    ambiguousIndexCount[i] = 0;\n                    if (i === ambiguousIndexCount.length - 1) {\n                        throw ChecksumException_1.default.getChecksumInstance();\n                    }\n                }\n            }\n        }\n        throw ChecksumException_1.default.getChecksumInstance();\n    };\n    PDF417ScanningDecoder.createBarcodeMatrix = function (detectionResult) {\n        var e_3, _a, e_4, _b;\n        // let barcodeMatrix: BarcodeValue[][] =\n        // new BarcodeValue[detectionResult.getBarcodeRowCount()][detectionResult.getBarcodeColumnCount() + 2];\n        var barcodeMatrix = Array.from({ length: detectionResult.getBarcodeRowCount() }, function () { return new Array(detectionResult.getBarcodeColumnCount() + 2); });\n        for (var row /*int*/ = 0; row < barcodeMatrix.length; row++) {\n            for (var column_1 /*int*/ = 0; column_1 < barcodeMatrix[row].length; column_1++) {\n                barcodeMatrix[row][column_1] = new BarcodeValue_1.default();\n            }\n        }\n        var column = 0;\n        try {\n            for (var _c = __values(detectionResult.getDetectionResultColumns()), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var detectionResultColumn = _d.value /*DetectionResultColumn*/;\n                if (detectionResultColumn != null) {\n                    try {\n                        for (var _e = __values(detectionResultColumn.getCodewords()), _f = _e.next(); !_f.done; _f = _e.next()) {\n                            var codeword = _f.value /*Codeword*/;\n                            if (codeword != null) {\n                                var rowNumber = codeword.getRowNumber();\n                                if (rowNumber >= 0) {\n                                    if (rowNumber >= barcodeMatrix.length) {\n                                        // We have more rows than the barcode metadata allows for, ignore them.\n                                        continue;\n                                    }\n                                    barcodeMatrix[rowNumber][column].setValue(codeword.getValue());\n                                }\n                            }\n                        }\n                    }\n                    catch (e_4_1) { e_4 = { error: e_4_1 }; }\n                    finally {\n                        try {\n                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                        }\n                        finally { if (e_4) throw e_4.error; }\n                    }\n                }\n                column++;\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        return barcodeMatrix;\n    };\n    PDF417ScanningDecoder.isValidBarcodeColumn = function (detectionResult, barcodeColumn) {\n        return barcodeColumn >= 0 && barcodeColumn <= detectionResult.getBarcodeColumnCount() + 1;\n    };\n    PDF417ScanningDecoder.getStartColumn = function (detectionResult, barcodeColumn, imageRow, leftToRight) {\n        var e_5, _a;\n        var offset = leftToRight ? 1 : -1;\n        var codeword = null;\n        if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n            codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodeword(imageRow);\n        }\n        if (codeword != null) {\n            return leftToRight ? codeword.getEndX() : codeword.getStartX();\n        }\n        codeword = detectionResult.getDetectionResultColumn(barcodeColumn).getCodewordNearby(imageRow);\n        if (codeword != null) {\n            return leftToRight ? codeword.getStartX() : codeword.getEndX();\n        }\n        if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n            codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodewordNearby(imageRow);\n        }\n        if (codeword != null) {\n            return leftToRight ? codeword.getEndX() : codeword.getStartX();\n        }\n        var skippedColumns = 0;\n        while (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n            barcodeColumn -= offset;\n            try {\n                for (var _b = __values(detectionResult.getDetectionResultColumn(barcodeColumn).getCodewords()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var previousRowCodeword = _c.value /*Codeword*/;\n                    if (previousRowCodeword != null) {\n                        return (leftToRight ? previousRowCodeword.getEndX() : previousRowCodeword.getStartX()) +\n                            offset *\n                                skippedColumns *\n                                (previousRowCodeword.getEndX() - previousRowCodeword.getStartX());\n                    }\n                }\n            }\n            catch (e_5_1) { e_5 = { error: e_5_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_5) throw e_5.error; }\n            }\n            skippedColumns++;\n        }\n        return leftToRight ? detectionResult.getBoundingBox().getMinX() : detectionResult.getBoundingBox().getMaxX();\n    };\n    PDF417ScanningDecoder.detectCodeword = function (image, minColumn, maxColumn, leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth) {\n        startColumn = PDF417ScanningDecoder.adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);\n        // we usually know fairly exact now how long a codeword is. We should provide minimum and maximum expected length\n        // and try to adjust the read pixels, e.g. remove single pixel errors or try to cut off exceeding pixels.\n        // min and maxCodewordWidth should not be used as they are calculated for the whole barcode an can be inaccurate\n        // for the current position\n        var moduleBitCount = PDF417ScanningDecoder.getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);\n        if (moduleBitCount == null) {\n            return null;\n        }\n        var endColumn;\n        var codewordBitCount = MathUtils_1.default.sum(moduleBitCount);\n        if (leftToRight) {\n            endColumn = startColumn + codewordBitCount;\n        }\n        else {\n            for (var i /*int*/ = 0; i < moduleBitCount.length / 2; i++) {\n                var tmpCount = moduleBitCount[i];\n                moduleBitCount[i] = moduleBitCount[moduleBitCount.length - 1 - i];\n                moduleBitCount[moduleBitCount.length - 1 - i] = tmpCount;\n            }\n            endColumn = startColumn;\n            startColumn = endColumn - codewordBitCount;\n        }\n        // TODO implement check for width and correction of black and white bars\n        // use start (and maybe stop pattern) to determine if black bars are wider than white bars. If so, adjust.\n        // should probably done only for codewords with a lot more than 17 bits.\n        // The following fixes 10-1.png, which has wide black bars and small white bars\n        //    for (let i /*int*/ = 0; i < moduleBitCount.length; i++) {\n        //      if (i % 2 === 0) {\n        //        moduleBitCount[i]--;\n        //      } else {\n        //        moduleBitCount[i]++;\n        //      }\n        //    }\n        // We could also use the width of surrounding codewords for more accurate results, but this seems\n        // sufficient for now\n        if (!PDF417ScanningDecoder.checkCodewordSkew(codewordBitCount, minCodewordWidth, maxCodewordWidth)) {\n            // We could try to use the startX and endX position of the codeword in the same column in the previous row,\n            // create the bit count from it and normalize it to 8. This would help with single pixel errors.\n            return null;\n        }\n        var decodedValue = PDF417CodewordDecoder_1.default.getDecodedValue(moduleBitCount);\n        var codeword = PDF417Common_1.default.getCodeword(decodedValue);\n        if (codeword === -1) {\n            return null;\n        }\n        return new Codeword_1.default(startColumn, endColumn, PDF417ScanningDecoder.getCodewordBucketNumber(decodedValue), codeword);\n    };\n    PDF417ScanningDecoder.getModuleBitCount = function (image, minColumn, maxColumn, leftToRight, startColumn, imageRow) {\n        var imageColumn = startColumn;\n        var moduleBitCount = new Int32Array(8);\n        var moduleNumber = 0;\n        var increment = leftToRight ? 1 : -1;\n        var previousPixelValue = leftToRight;\n        while ((leftToRight ? imageColumn < maxColumn : imageColumn >= minColumn) &&\n            moduleNumber < moduleBitCount.length) {\n            if (image.get(imageColumn, imageRow) === previousPixelValue) {\n                moduleBitCount[moduleNumber]++;\n                imageColumn += increment;\n            }\n            else {\n                moduleNumber++;\n                previousPixelValue = !previousPixelValue;\n            }\n        }\n        if (moduleNumber === moduleBitCount.length ||\n            ((imageColumn === (leftToRight ? maxColumn : minColumn)) &&\n                moduleNumber === moduleBitCount.length - 1)) {\n            return moduleBitCount;\n        }\n        return null;\n    };\n    PDF417ScanningDecoder.getNumberOfECCodeWords = function (barcodeECLevel) {\n        return 2 << barcodeECLevel;\n    };\n    PDF417ScanningDecoder.adjustCodewordStartColumn = function (image, minColumn, maxColumn, leftToRight, codewordStartColumn, imageRow) {\n        var correctedStartColumn = codewordStartColumn;\n        var increment = leftToRight ? -1 : 1;\n        // there should be no black pixels before the start column. If there are, then we need to start earlier.\n        for (var i /*int*/ = 0; i < 2; i++) {\n            while ((leftToRight ? correctedStartColumn >= minColumn : correctedStartColumn < maxColumn) &&\n                leftToRight === image.get(correctedStartColumn, imageRow)) {\n                if (Math.abs(codewordStartColumn - correctedStartColumn) > PDF417ScanningDecoder.CODEWORD_SKEW_SIZE) {\n                    return codewordStartColumn;\n                }\n                correctedStartColumn += increment;\n            }\n            increment = -increment;\n            leftToRight = !leftToRight;\n        }\n        return correctedStartColumn;\n    };\n    PDF417ScanningDecoder.checkCodewordSkew = function (codewordSize, minCodewordWidth, maxCodewordWidth) {\n        return minCodewordWidth - PDF417ScanningDecoder.CODEWORD_SKEW_SIZE <= codewordSize &&\n            codewordSize <= maxCodewordWidth + PDF417ScanningDecoder.CODEWORD_SKEW_SIZE;\n    };\n    /**\n     * @throws FormatException,\n     * @throws ChecksumException\n     */\n    PDF417ScanningDecoder.decodeCodewords = function (codewords, ecLevel, erasures) {\n        if (codewords.length === 0) {\n            throw FormatException_1.default.getFormatInstance();\n        }\n        var numECCodewords = 1 << (ecLevel + 1);\n        var correctedErrorsCount = PDF417ScanningDecoder.correctErrors(codewords, erasures, numECCodewords);\n        PDF417ScanningDecoder.verifyCodewordCount(codewords, numECCodewords);\n        // Decode the codewords\n        var decoderResult = DecodedBitStreamParser_1.default.decode(codewords, '' + ecLevel);\n        decoderResult.setErrorsCorrected(correctedErrorsCount);\n        decoderResult.setErasures(erasures.length);\n        return decoderResult;\n    };\n    /**\n     * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\n     * correct the errors in-place.</p>\n     *\n     * @param codewords   data and error correction codewords\n     * @param erasures positions of any known erasures\n     * @param numECCodewords number of error correction codewords that are available in codewords\n     * @throws ChecksumException if error correction fails\n     */\n    PDF417ScanningDecoder.correctErrors = function (codewords, erasures, numECCodewords) {\n        if (erasures != null &&\n            erasures.length > numECCodewords / 2 + PDF417ScanningDecoder.MAX_ERRORS ||\n            numECCodewords < 0 ||\n            numECCodewords > PDF417ScanningDecoder.MAX_EC_CODEWORDS) {\n            // Too many errors or EC Codewords is corrupted\n            throw ChecksumException_1.default.getChecksumInstance();\n        }\n        return PDF417ScanningDecoder.errorCorrection.decode(codewords, numECCodewords, erasures);\n    };\n    /**\n     * Verify that all is OK with the codeword array.\n     * @throws FormatException\n     */\n    PDF417ScanningDecoder.verifyCodewordCount = function (codewords, numECCodewords) {\n        if (codewords.length < 4) {\n            // Codeword array size should be at least 4 allowing for\n            // Count CW, At least one Data CW, Error Correction CW, Error Correction CW\n            throw FormatException_1.default.getFormatInstance();\n        }\n        // The first codeword, the Symbol Length Descriptor, shall always encode the total number of data\n        // codewords in the symbol, including the Symbol Length Descriptor itself, data codewords and pad\n        // codewords, but excluding the number of error correction codewords.\n        var numberOfCodewords = codewords[0];\n        if (numberOfCodewords > codewords.length) {\n            throw FormatException_1.default.getFormatInstance();\n        }\n        if (numberOfCodewords === 0) {\n            // Reset to the length of the array - 8 (Allow for at least level 3 Error Correction (8 Error Codewords)\n            if (numECCodewords < codewords.length) {\n                codewords[0] = codewords.length - numECCodewords;\n            }\n            else {\n                throw FormatException_1.default.getFormatInstance();\n            }\n        }\n    };\n    PDF417ScanningDecoder.getBitCountForCodeword = function (codeword) {\n        var result = new Int32Array(8);\n        var previousValue = 0;\n        var i = result.length - 1;\n        while (true) {\n            if ((codeword & 0x1) !== previousValue) {\n                previousValue = codeword & 0x1;\n                i--;\n                if (i < 0) {\n                    break;\n                }\n            }\n            result[i]++;\n            codeword >>= 1;\n        }\n        return result;\n    };\n    PDF417ScanningDecoder.getCodewordBucketNumber = function (codeword) {\n        if (codeword instanceof Int32Array) {\n            return this.getCodewordBucketNumber_Int32Array(codeword);\n        }\n        return this.getCodewordBucketNumber_number(codeword);\n    };\n    PDF417ScanningDecoder.getCodewordBucketNumber_number = function (codeword) {\n        return PDF417ScanningDecoder.getCodewordBucketNumber(PDF417ScanningDecoder.getBitCountForCodeword(codeword));\n    };\n    PDF417ScanningDecoder.getCodewordBucketNumber_Int32Array = function (moduleBitCount) {\n        return (moduleBitCount[0] - moduleBitCount[2] + moduleBitCount[4] - moduleBitCount[6] + 9) % 9;\n    };\n    PDF417ScanningDecoder.toString = function (barcodeMatrix) {\n        var formatter = new Formatter_1.default();\n        // try (let formatter = new Formatter()) {\n        for (var row /*int*/ = 0; row < barcodeMatrix.length; row++) {\n            formatter.format('Row %2d: ', row);\n            for (var column /*int*/ = 0; column < barcodeMatrix[row].length; column++) {\n                var barcodeValue = barcodeMatrix[row][column];\n                if (barcodeValue.getValue().length === 0) {\n                    formatter.format('        ', null);\n                }\n                else {\n                    formatter.format('%4d(%2d)', barcodeValue.getValue()[0], barcodeValue.getConfidence(barcodeValue.getValue()[0]));\n                }\n            }\n            formatter.format('%n');\n        }\n        return formatter.toString();\n        // }\n    };\n    /*final*/ PDF417ScanningDecoder.CODEWORD_SKEW_SIZE = 2;\n    /*final*/ PDF417ScanningDecoder.MAX_ERRORS = 3;\n    /*final*/ PDF417ScanningDecoder.MAX_EC_CODEWORDS = 512;\n    /*final*/ PDF417ScanningDecoder.errorCorrection = new ErrorCorrection_1.default();\n    return PDF417ScanningDecoder;\n}());\nexports.default = PDF417ScanningDecoder;\n//# sourceMappingURL=PDF417ScanningDecoder.js.map"]},"metadata":{},"sourceType":"script"}