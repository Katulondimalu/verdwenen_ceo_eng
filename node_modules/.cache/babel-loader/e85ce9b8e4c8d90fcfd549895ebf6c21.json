{"ast":null,"code":"\"use strict\";\n/**\n * OOXML uses the CFB file format with Agile Encryption. The details of the encryption are here:\n * https://msdn.microsoft.com/en-us/library/dd950165(v=office.12).aspx\n *\n * Helpful guidance also take from this Github project:\n * https://github.com/nolze/ms-offcrypto-tool\n */\n\nconst _ = require(\"lodash\");\n\nconst cfb = require(\"cfb\");\n\nconst crypto = require(\"crypto\");\n\nconst externals = require(\"./externals\");\n\nconst XmlParser = require(\"./XmlParser\");\n\nconst XmlBuilder = require(\"./XmlBuilder\");\n\nconst xmlq = require(\"./xmlq\");\n\nconst ENCRYPTION_INFO_PREFIX = Buffer.from([0x04, 0x00, 0x04, 0x00, 0x40, 0x00, 0x00, 0x00]); // First 4 bytes are the version number, second 4 bytes are reserved.\n\nconst PACKAGE_ENCRYPTION_CHUNK_SIZE = 4096;\nconst PACKAGE_OFFSET = 8; // First 8 bytes are the size of the stream\n// Block keys used for encryption\n\nconst BLOCK_KEYS = {\n  dataIntegrity: {\n    hmacKey: Buffer.from([0x5f, 0xb2, 0xad, 0x01, 0x0c, 0xb9, 0xe1, 0xf6]),\n    hmacValue: Buffer.from([0xa0, 0x67, 0x7f, 0x02, 0xb2, 0x2c, 0x84, 0x33])\n  },\n  key: Buffer.from([0x14, 0x6e, 0x0b, 0xe7, 0xab, 0xac, 0xd0, 0xd6]),\n  verifierHash: {\n    input: Buffer.from([0xfe, 0xa7, 0xd2, 0x76, 0x3b, 0x4b, 0x9e, 0x79]),\n    value: Buffer.from([0xd7, 0xaa, 0x0f, 0x6d, 0x30, 0x61, 0x34, 0x4e])\n  }\n};\n/**\n * Encrypts/decrypts XLSXs.\n * @private\n */\n\nclass Encryptor {\n  /**\n   * Encrypt the data with the password.\n   * @param {Buffer} data - The data to encrypt\n   * @param {string} password - The password\n   * @returns {Buffer} The encrypted data\n   */\n  encrypt(data, password) {\n    // Generate a random key to use to encrypt the document. Excel uses 32 bytes. We'll use the password to encrypt this key.\n    // N.B. The number of bits needs to correspond to an algorithm available in crypto (e.g. aes-256-cbc).\n    const packageKey = crypto.randomBytes(32); // Create the encryption info. We'll use this for all of the encryption operations and for building the encryption info XML entry\n\n    const encryptionInfo = {\n      package: {\n        // Info on the encryption of the package.\n        cipherAlgorithm: 'AES',\n        // Cipher algorithm to use. Excel uses AES.\n        cipherChaining: 'ChainingModeCBC',\n        // Cipher chaining mode to use. Excel uses CBC.\n        saltValue: crypto.randomBytes(16),\n        // Random value to use as encryption salt. Excel uses 16 bytes.\n        hashAlgorithm: 'SHA512',\n        // Hash algorithm to use. Excel uses SHA512.\n        hashSize: 64,\n        // The size of the hash in bytes. SHA512 results in 64-byte hashes\n        blockSize: 16,\n        // The number of bytes used to encrypt one block of data. It MUST be at least 2, no greater than 4096, and a multiple of 2. Excel uses 16\n        keyBits: packageKey.length * 8 // The number of bits in the package key.\n\n      },\n      key: {\n        // Info on the encryption of the package key.\n        cipherAlgorithm: 'AES',\n        // Cipher algorithm to use. Excel uses AES.\n        cipherChaining: 'ChainingModeCBC',\n        // Cipher chaining mode to use. Excel uses CBC.\n        saltValue: crypto.randomBytes(16),\n        // Random value to use as encryption salt. Excel uses 16 bytes.\n        hashAlgorithm: 'SHA512',\n        // Hash algorithm to use. Excel uses SHA512.\n        hashSize: 64,\n        // The size of the hash in bytes. SHA512 results in 64-byte hashes\n        blockSize: 16,\n        // The number of bytes used to encrypt one block of data. It MUST be at least 2, no greater than 4096, and a multiple of 2. Excel uses 16\n        spinCount: 100000,\n        // The number of times to iterate on a hash of a password. It MUST NOT be greater than 10,000,000. Excel uses 100,000.\n        keyBits: 256 // The length of the key to generate from the password. Must be a multiple of 8. Excel uses 256.\n\n      }\n    };\n    /* Package Encryption */\n    // Encrypt package using the package key.\n\n    const encryptedPackage = this._cryptPackage(true, encryptionInfo.package.cipherAlgorithm, encryptionInfo.package.cipherChaining, encryptionInfo.package.hashAlgorithm, encryptionInfo.package.blockSize, encryptionInfo.package.saltValue, packageKey, data);\n    /* Data Integrity */\n    // Create the data integrity fields used by clients for integrity checks.\n    // First generate a random array of bytes to use in HMAC. The docs say to use the same length as the key salt, but Excel seems to use 64.\n\n\n    const hmacKey = crypto.randomBytes(64); // Then create an initialization vector using the package encryption info and the appropriate block key.\n\n    const hmacKeyIV = this._createIV(encryptionInfo.package.hashAlgorithm, encryptionInfo.package.saltValue, encryptionInfo.package.blockSize, BLOCK_KEYS.dataIntegrity.hmacKey); // Use the package key and the IV to encrypt the HMAC key\n\n\n    const encryptedHmacKey = this._crypt(true, encryptionInfo.package.cipherAlgorithm, encryptionInfo.package.cipherChaining, packageKey, hmacKeyIV, hmacKey); // Now create the HMAC\n\n\n    const hmacValue = this._hmac(encryptionInfo.package.hashAlgorithm, hmacKey, encryptedPackage); // Next generate an initialization vector for encrypting the resulting HMAC value.\n\n\n    const hmacValueIV = this._createIV(encryptionInfo.package.hashAlgorithm, encryptionInfo.package.saltValue, encryptionInfo.package.blockSize, BLOCK_KEYS.dataIntegrity.hmacValue); // Now encrypt the value\n\n\n    const encryptedHmacValue = this._crypt(true, encryptionInfo.package.cipherAlgorithm, encryptionInfo.package.cipherChaining, packageKey, hmacValueIV, hmacValue); // Put the encrypted key and value on the encryption info\n\n\n    encryptionInfo.dataIntegrity = {\n      encryptedHmacKey,\n      encryptedHmacValue\n    };\n    /* Key Encryption */\n    // Convert the password to an encryption key\n\n    const key = this._convertPasswordToKey(password, encryptionInfo.key.hashAlgorithm, encryptionInfo.key.saltValue, encryptionInfo.key.spinCount, encryptionInfo.key.keyBits, BLOCK_KEYS.key); // Encrypt the package key with the\n\n\n    encryptionInfo.key.encryptedKeyValue = this._crypt(true, encryptionInfo.key.cipherAlgorithm, encryptionInfo.key.cipherChaining, key, encryptionInfo.key.saltValue, packageKey);\n    /* Verifier hash */\n    // Create a random byte array for hashing\n\n    const verifierHashInput = crypto.randomBytes(16); // Create an encryption key from the password for the input\n\n    const verifierHashInputKey = this._convertPasswordToKey(password, encryptionInfo.key.hashAlgorithm, encryptionInfo.key.saltValue, encryptionInfo.key.spinCount, encryptionInfo.key.keyBits, BLOCK_KEYS.verifierHash.input); // Use the key to encrypt the verifier input\n\n\n    encryptionInfo.key.encryptedVerifierHashInput = this._crypt(true, encryptionInfo.key.cipherAlgorithm, encryptionInfo.key.cipherChaining, verifierHashInputKey, encryptionInfo.key.saltValue, verifierHashInput); // Create a hash of the input\n\n    const verifierHashValue = this._hash(encryptionInfo.key.hashAlgorithm, verifierHashInput); // Create an encryption key from the password for the hash\n\n\n    const verifierHashValueKey = this._convertPasswordToKey(password, encryptionInfo.key.hashAlgorithm, encryptionInfo.key.saltValue, encryptionInfo.key.spinCount, encryptionInfo.key.keyBits, BLOCK_KEYS.verifierHash.value); // Use the key to encrypt the hash value\n\n\n    encryptionInfo.key.encryptedVerifierHashValue = this._crypt(true, encryptionInfo.key.cipherAlgorithm, encryptionInfo.key.cipherChaining, verifierHashValueKey, encryptionInfo.key.saltValue, verifierHashValue); // Build the encryption info buffer\n\n    const encryptionInfoBuffer = this._buildEncryptionInfo(encryptionInfo); // Create a new CFB\n\n\n    let output = cfb.utils.cfb_new(); // Add the encryption info and encrypted package\n\n    cfb.utils.cfb_add(output, \"EncryptionInfo\", encryptionInfoBuffer);\n    cfb.utils.cfb_add(output, \"EncryptedPackage\", encryptedPackage); // Delete the SheetJS entry that is added at initialization\n\n    cfb.utils.cfb_del(output, \"\\u0001Sh33tJ5\"); // Write to a buffer and return\n\n    output = cfb.write(output); // The cfb library writes to a Uint8array in the browser. Convert to a Buffer.\n\n    if (!Buffer.isBuffer(output)) output = Buffer.from(output);\n    return output;\n  }\n  /**\n   * Decrypt the data with the given password\n   * @param {Buffer} data - The data to decrypt\n   * @param {string} password - The password\n   * @returns {Promise.<Buffer>} The decrypted data\n   */\n\n\n  decryptAsync(data, password) {\n    // Parse the CFB input and pull out the encryption info and encrypted package entries.\n    const parsed = cfb.parse(data);\n\n    let encryptionInfoBuffer = _.find(parsed.FileIndex, {\n      name: \"EncryptionInfo\"\n    }).content;\n\n    let encryptedPackageBuffer = _.find(parsed.FileIndex, {\n      name: \"EncryptedPackage\"\n    }).content; // In the browser the CFB content is an array. Convert to a Buffer.\n\n\n    if (!Buffer.isBuffer(encryptionInfoBuffer)) encryptionInfoBuffer = Buffer.from(encryptionInfoBuffer);\n    if (!Buffer.isBuffer(encryptedPackageBuffer)) encryptedPackageBuffer = Buffer.from(encryptedPackageBuffer);\n    return externals.Promise.resolve().then(() => this._parseEncryptionInfoAsync(encryptionInfoBuffer)) // Parse the encryption info XML into an object\n    .then(encryptionInfo => {\n      // Convert the password into an encryption key\n      const key = this._convertPasswordToKey(password, encryptionInfo.key.hashAlgorithm, encryptionInfo.key.saltValue, encryptionInfo.key.spinCount, encryptionInfo.key.keyBits, BLOCK_KEYS.key); // Use the key to decrypt the package key\n\n\n      const packageKey = this._crypt(false, encryptionInfo.key.cipherAlgorithm, encryptionInfo.key.cipherChaining, key, encryptionInfo.key.saltValue, encryptionInfo.key.encryptedKeyValue); // Use the package key to decrypt the package\n\n\n      return this._cryptPackage(false, encryptionInfo.package.cipherAlgorithm, encryptionInfo.package.cipherChaining, encryptionInfo.package.hashAlgorithm, encryptionInfo.package.blockSize, encryptionInfo.package.saltValue, packageKey, encryptedPackageBuffer);\n    });\n  }\n  /**\n   * Build the encryption info XML/buffer\n   * @param {{}} encryptionInfo - The encryption info object\n   * @returns {Buffer} The buffer\n   * @private\n   */\n\n\n  _buildEncryptionInfo(encryptionInfo) {\n    // Map the object into the appropriate XML structure. Buffers are encoded in base 64.\n    const encryptionInfoNode = {\n      name: \"encryption\",\n      attributes: {\n        xmlns: \"http://schemas.microsoft.com/office/2006/encryption\",\n        'xmlns:p': \"http://schemas.microsoft.com/office/2006/keyEncryptor/password\",\n        'xmlns:c': \"http://schemas.microsoft.com/office/2006/keyEncryptor/certificate\"\n      },\n      children: [{\n        name: \"keyData\",\n        attributes: {\n          saltSize: encryptionInfo.package.saltValue.length,\n          blockSize: encryptionInfo.package.blockSize,\n          keyBits: encryptionInfo.package.keyBits,\n          hashSize: encryptionInfo.package.hashSize,\n          cipherAlgorithm: encryptionInfo.package.cipherAlgorithm,\n          cipherChaining: encryptionInfo.package.cipherChaining,\n          hashAlgorithm: encryptionInfo.package.hashAlgorithm,\n          saltValue: encryptionInfo.package.saltValue.toString(\"base64\")\n        }\n      }, {\n        name: \"dataIntegrity\",\n        attributes: {\n          encryptedHmacKey: encryptionInfo.dataIntegrity.encryptedHmacKey.toString(\"base64\"),\n          encryptedHmacValue: encryptionInfo.dataIntegrity.encryptedHmacValue.toString(\"base64\")\n        }\n      }, {\n        name: \"keyEncryptors\",\n        children: [{\n          name: \"keyEncryptor\",\n          attributes: {\n            uri: \"http://schemas.microsoft.com/office/2006/keyEncryptor/password\"\n          },\n          children: [{\n            name: \"p:encryptedKey\",\n            attributes: {\n              spinCount: encryptionInfo.key.spinCount,\n              saltSize: encryptionInfo.key.saltValue.length,\n              blockSize: encryptionInfo.key.blockSize,\n              keyBits: encryptionInfo.key.keyBits,\n              hashSize: encryptionInfo.key.hashSize,\n              cipherAlgorithm: encryptionInfo.key.cipherAlgorithm,\n              cipherChaining: encryptionInfo.key.cipherChaining,\n              hashAlgorithm: encryptionInfo.key.hashAlgorithm,\n              saltValue: encryptionInfo.key.saltValue.toString(\"base64\"),\n              encryptedVerifierHashInput: encryptionInfo.key.encryptedVerifierHashInput.toString(\"base64\"),\n              encryptedVerifierHashValue: encryptionInfo.key.encryptedVerifierHashValue.toString(\"base64\"),\n              encryptedKeyValue: encryptionInfo.key.encryptedKeyValue.toString(\"base64\")\n            }\n          }]\n        }]\n      }]\n    }; // Convert to an XML string\n\n    const xmlBuilder = new XmlBuilder();\n    const encryptionInfoXml = xmlBuilder.build(encryptionInfoNode); // Convert to a buffer and prefix with the appropriate bytes\n\n    return Buffer.concat([ENCRYPTION_INFO_PREFIX, Buffer.from(encryptionInfoXml, \"utf8\")]);\n  }\n  /**\n   * Parse the encryption info from the XML/buffer\n   * @param {Buffer} buffer - The buffer\n   * @returns {Promise.<{}>} The parsed encryption info object\n   * @private\n   */\n\n\n  _parseEncryptionInfoAsync(buffer) {\n    // Pull off the prefix and convert to string\n    const xml = buffer.slice(ENCRYPTION_INFO_PREFIX.length).toString(\"utf8\"); // Parse the XML\n\n    const xmlParser = new XmlParser();\n    return xmlParser.parseAsync(xml).then(doc => {\n      // Pull out the relevant values for decryption and return\n      const keyDataNode = xmlq.findChild(doc, \"keyData\");\n      const keyEncryptorsNode = xmlq.findChild(doc, \"keyEncryptors\");\n      const keyEncryptorNode = xmlq.findChild(keyEncryptorsNode, \"keyEncryptor\");\n      const encryptedKeyNode = xmlq.findChild(keyEncryptorNode, \"p:encryptedKey\");\n      return {\n        package: {\n          cipherAlgorithm: keyDataNode.attributes.cipherAlgorithm,\n          cipherChaining: keyDataNode.attributes.cipherChaining,\n          saltValue: Buffer.from(keyDataNode.attributes.saltValue, \"base64\"),\n          hashAlgorithm: keyDataNode.attributes.hashAlgorithm,\n          blockSize: keyDataNode.attributes.blockSize\n        },\n        key: {\n          encryptedKeyValue: Buffer.from(encryptedKeyNode.attributes.encryptedKeyValue, \"base64\"),\n          cipherAlgorithm: encryptedKeyNode.attributes.cipherAlgorithm,\n          cipherChaining: encryptedKeyNode.attributes.cipherChaining,\n          saltValue: Buffer.from(encryptedKeyNode.attributes.saltValue, \"base64\"),\n          hashAlgorithm: encryptedKeyNode.attributes.hashAlgorithm,\n          spinCount: encryptedKeyNode.attributes.spinCount,\n          keyBits: encryptedKeyNode.attributes.keyBits\n        }\n      };\n    });\n  }\n  /**\n   * Calculate a hash of the concatenated buffers with the given algorithm.\n   * @param {string} algorithm - The hash algorithm.\n   * @param {Array.<Buffer>} buffers - The buffers to concat and hash\n   * @returns {Buffer} The hash\n   * @private\n   */\n\n\n  _hash(algorithm) {\n    algorithm = algorithm.toLowerCase();\n    const hashes = crypto.getHashes();\n    if (hashes.indexOf(algorithm) < 0) throw new Error(`Hash algorithm '${algorithm}' not supported!`);\n    const hash = crypto.createHash(algorithm);\n\n    for (var _len = arguments.length, buffers = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      buffers[_key - 1] = arguments[_key];\n    }\n\n    hash.update(Buffer.concat(buffers));\n    return hash.digest();\n  }\n  /**\n   * Calculate an HMAC of the concatenated buffers with the given algorithm and key\n   * @param {string} algorithm - The algorithm.\n   * @param {string} key - The key\n   * @param {Array.<Buffer>} buffers - The buffer to concat and HMAC\n   * @returns {Buffer} The HMAC\n   * @private\n   */\n\n\n  _hmac(algorithm, key) {\n    algorithm = algorithm.toLowerCase();\n    const hashes = crypto.getHashes();\n    if (hashes.indexOf(algorithm) < 0) throw new Error(`HMAC algorithm '${algorithm}' not supported!`);\n    const hmac = crypto.createHmac(algorithm, key);\n\n    for (var _len2 = arguments.length, buffers = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      buffers[_key2 - 2] = arguments[_key2];\n    }\n\n    hmac.update(Buffer.concat(buffers));\n    return hmac.digest();\n  }\n  /**\n   * Encrypt/decrypt input\n   * @param {boolean} encrypt - True to encrypt, false to decrypt\n   * @param {string} cipherAlgorithm - The cipher algorithm\n   * @param {sring} cipherChaining - The cipher chaining mode\n   * @param {Buffer} key - The encryption key\n   * @param {Buffer} iv - The initialization vector\n   * @param {Buffer} input - The input\n   * @returns {Buffer} The output\n   * @private\n   */\n\n\n  _crypt(encrypt, cipherAlgorithm, cipherChaining, key, iv, input) {\n    let algorithm = `${cipherAlgorithm.toLowerCase()}-${key.length * 8}`;\n    if (cipherChaining === 'ChainingModeCBC') algorithm += '-cbc';else throw new Error(`Unknown cipher chaining: ${cipherChaining}`);\n    const cipher = crypto[encrypt ? 'createCipheriv' : 'createDecipheriv'](algorithm, key, iv);\n    cipher.setAutoPadding(false);\n    let output = cipher.update(input);\n    output = Buffer.concat([output, cipher.final()]);\n    return output;\n  }\n  /**\n   * Encrypt/decrypt the package\n   * @param {boolean} encrypt - True to encrypt, false to decrypt\n   * @param {string} cipherAlgorithm - The cipher algorithm\n   * @param {string} cipherChaining - The cipher chaining mode\n   * @param {string} hashAlgorithm - The hash algorithm\n   * @param {number} blockSize - The IV block size\n   * @param {Buffer} saltValue - The salt\n   * @param {Buffer} key - The encryption key\n   * @param {Buffer} input - The package input\n   * @returns {Buffer} The output\n   * @private\n   */\n\n\n  _cryptPackage(encrypt, cipherAlgorithm, cipherChaining, hashAlgorithm, blockSize, saltValue, key, input) {\n    // The first 8 bytes is supposed to be the length, but it seems like it is really the length - 4..\n    const outputChunks = [];\n    const offset = encrypt ? 0 : PACKAGE_OFFSET; // The package is encoded in chunks. Encrypt/decrypt each and concat.\n\n    let i = 0,\n        start = 0,\n        end = 0;\n\n    while (end < input.length) {\n      start = end;\n      end = start + PACKAGE_ENCRYPTION_CHUNK_SIZE;\n      if (end > input.length) end = input.length; // Grab the next chunk\n\n      let inputChunk = input.slice(start + offset, end + offset); // Pad the chunk if it is not an integer multiple of the block size\n\n      const remainder = inputChunk.length % blockSize;\n      if (remainder) inputChunk = Buffer.concat([inputChunk, Buffer.alloc(blockSize - remainder)]); // Create the initialization vector\n\n      const iv = this._createIV(hashAlgorithm, saltValue, blockSize, i); // Encrypt/decrypt the chunk and add it to the array\n\n\n      const outputChunk = this._crypt(encrypt, cipherAlgorithm, cipherChaining, key, iv, inputChunk);\n\n      outputChunks.push(outputChunk);\n      i++;\n    } // Concat all of the output chunks.\n\n\n    let output = Buffer.concat(outputChunks);\n\n    if (encrypt) {\n      // Put the length of the package in the first 8 bytes\n      output = Buffer.concat([this._createUInt32LEBuffer(input.length, PACKAGE_OFFSET), output]);\n    } else {\n      // Truncate the buffer to the size in the prefix\n      const length = input.readUInt32LE(0);\n      output = output.slice(0, length);\n    }\n\n    return output;\n  }\n  /**\n   * Create a buffer of an integer encoded as a uint32le\n   * @param {number} value - The integer to encode\n   * @param {number} [bufferSize=4] The output buffer size in bytes\n   * @returns {Buffer} The buffer\n   * @private\n   */\n\n\n  _createUInt32LEBuffer(value) {\n    let bufferSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n    const buffer = Buffer.alloc(bufferSize);\n    buffer.writeUInt32LE(value, 0);\n    return buffer;\n  }\n  /**\n   * Convert a password into an encryption key\n   * @param {string} password - The password\n   * @param {string} hashAlgorithm - The hash algoritm\n   * @param {Buffer} saltValue - The salt value\n   * @param {number} spinCount - The spin count\n   * @param {number} keyBits - The length of the key in bits\n   * @param {Buffer} blockKey - The block key\n   * @returns {Buffer} The encryption key\n   * @private\n   */\n\n\n  _convertPasswordToKey(password, hashAlgorithm, saltValue, spinCount, keyBits, blockKey) {\n    // Password must be in unicode buffer\n    const passwordBuffer = Buffer.from(password, 'utf16le'); // Generate the initial hash\n\n    let key = this._hash(hashAlgorithm, saltValue, passwordBuffer); // Now regenerate until spin count\n\n\n    for (let i = 0; i < spinCount; i++) {\n      const iterator = this._createUInt32LEBuffer(i);\n\n      key = this._hash(hashAlgorithm, iterator, key);\n    } // Now generate the final hash\n\n\n    key = this._hash(hashAlgorithm, key, blockKey); // Truncate or pad as needed to get to length of keyBits\n\n    const keyBytes = keyBits / 8;\n\n    if (key.length < keyBytes) {\n      const tmp = Buffer.alloc(keyBytes, 0x36);\n      key.copy(tmp);\n      key = tmp;\n    } else if (key.length > keyBytes) {\n      key = key.slice(0, keyBytes);\n    }\n\n    return key;\n  }\n  /**\n   * Create an initialization vector (IV)\n   * @param {string} hashAlgorithm - The hash algorithm\n   * @param {Buffer} saltValue - The salt value\n   * @param {number} blockSize - The size of the IV\n   * @param {Buffer|number} blockKey - The block key or an int to convert to a buffer\n   * @returns {Buffer} The IV\n   * @private\n   */\n\n\n  _createIV(hashAlgorithm, saltValue, blockSize, blockKey) {\n    // Create the block key from the current index\n    if (typeof blockKey === \"number\") blockKey = this._createUInt32LEBuffer(blockKey); // Create the initialization vector by hashing the salt with the block key.\n    // Truncate or pad as needed to meet the block size.\n\n    let iv = this._hash(hashAlgorithm, saltValue, blockKey);\n\n    if (iv.length < blockSize) {\n      const tmp = Buffer.alloc(blockSize, 0x36);\n      iv.copy(tmp);\n      iv = tmp;\n    } else if (iv.length > blockSize) {\n      iv = iv.slice(0, blockSize);\n    }\n\n    return iv;\n  }\n\n}\n\nmodule.exports = Encryptor;","map":{"version":3,"names":["_","require","cfb","crypto","externals","XmlParser","XmlBuilder","xmlq","ENCRYPTION_INFO_PREFIX","Buffer","from","PACKAGE_ENCRYPTION_CHUNK_SIZE","PACKAGE_OFFSET","BLOCK_KEYS","dataIntegrity","hmacKey","hmacValue","key","verifierHash","input","value","Encryptor","encrypt","data","password","packageKey","randomBytes","encryptionInfo","package","cipherAlgorithm","cipherChaining","saltValue","hashAlgorithm","hashSize","blockSize","keyBits","length","spinCount","encryptedPackage","_cryptPackage","hmacKeyIV","_createIV","encryptedHmacKey","_crypt","_hmac","hmacValueIV","encryptedHmacValue","_convertPasswordToKey","encryptedKeyValue","verifierHashInput","verifierHashInputKey","encryptedVerifierHashInput","verifierHashValue","_hash","verifierHashValueKey","encryptedVerifierHashValue","encryptionInfoBuffer","_buildEncryptionInfo","output","utils","cfb_new","cfb_add","cfb_del","write","isBuffer","decryptAsync","parsed","parse","find","FileIndex","name","content","encryptedPackageBuffer","Promise","resolve","then","_parseEncryptionInfoAsync","encryptionInfoNode","attributes","xmlns","children","saltSize","toString","uri","xmlBuilder","encryptionInfoXml","build","concat","buffer","xml","slice","xmlParser","parseAsync","doc","keyDataNode","findChild","keyEncryptorsNode","keyEncryptorNode","encryptedKeyNode","algorithm","toLowerCase","hashes","getHashes","indexOf","Error","hash","createHash","buffers","update","digest","hmac","createHmac","iv","cipher","setAutoPadding","final","outputChunks","offset","i","start","end","inputChunk","remainder","alloc","outputChunk","push","_createUInt32LEBuffer","readUInt32LE","bufferSize","writeUInt32LE","blockKey","passwordBuffer","iterator","keyBytes","tmp","copy","module","exports"],"sources":["/Users/stichtinghelden/Documents/GitHub/de_verdwenen_ceo/node_modules/xlsx-populate/lib/Encryptor.js"],"sourcesContent":["\"use strict\";\n\n/**\n * OOXML uses the CFB file format with Agile Encryption. The details of the encryption are here:\n * https://msdn.microsoft.com/en-us/library/dd950165(v=office.12).aspx\n *\n * Helpful guidance also take from this Github project:\n * https://github.com/nolze/ms-offcrypto-tool\n */\n\nconst _ = require(\"lodash\");\nconst cfb = require(\"cfb\");\nconst crypto = require(\"crypto\");\nconst externals = require(\"./externals\");\nconst XmlParser = require(\"./XmlParser\");\nconst XmlBuilder = require(\"./XmlBuilder\");\nconst xmlq = require(\"./xmlq\");\n\nconst ENCRYPTION_INFO_PREFIX = Buffer.from([0x04, 0x00, 0x04, 0x00, 0x40, 0x00, 0x00, 0x00]); // First 4 bytes are the version number, second 4 bytes are reserved.\nconst PACKAGE_ENCRYPTION_CHUNK_SIZE = 4096;\nconst PACKAGE_OFFSET = 8; // First 8 bytes are the size of the stream\n\n// Block keys used for encryption\nconst BLOCK_KEYS = {\n    dataIntegrity: {\n        hmacKey: Buffer.from([0x5f, 0xb2, 0xad, 0x01, 0x0c, 0xb9, 0xe1, 0xf6]),\n        hmacValue: Buffer.from([0xa0, 0x67, 0x7f, 0x02, 0xb2, 0x2c, 0x84, 0x33])\n    },\n    key: Buffer.from([0x14, 0x6e, 0x0b, 0xe7, 0xab, 0xac, 0xd0, 0xd6]),\n    verifierHash: {\n        input: Buffer.from([0xfe, 0xa7, 0xd2, 0x76, 0x3b, 0x4b, 0x9e, 0x79]),\n        value: Buffer.from([0xd7, 0xaa, 0x0f, 0x6d, 0x30, 0x61, 0x34, 0x4e])\n    }\n};\n\n/**\n * Encrypts/decrypts XLSXs.\n * @private\n */\nclass Encryptor {\n    /**\n     * Encrypt the data with the password.\n     * @param {Buffer} data - The data to encrypt\n     * @param {string} password - The password\n     * @returns {Buffer} The encrypted data\n     */\n    encrypt(data, password) {\n        // Generate a random key to use to encrypt the document. Excel uses 32 bytes. We'll use the password to encrypt this key.\n        // N.B. The number of bits needs to correspond to an algorithm available in crypto (e.g. aes-256-cbc).\n        const packageKey = crypto.randomBytes(32);\n\n        // Create the encryption info. We'll use this for all of the encryption operations and for building the encryption info XML entry\n        const encryptionInfo = {\n            package: { // Info on the encryption of the package.\n                cipherAlgorithm: 'AES', // Cipher algorithm to use. Excel uses AES.\n                cipherChaining: 'ChainingModeCBC', // Cipher chaining mode to use. Excel uses CBC.\n                saltValue: crypto.randomBytes(16), // Random value to use as encryption salt. Excel uses 16 bytes.\n                hashAlgorithm: 'SHA512', // Hash algorithm to use. Excel uses SHA512.\n                hashSize: 64, // The size of the hash in bytes. SHA512 results in 64-byte hashes\n                blockSize: 16, // The number of bytes used to encrypt one block of data. It MUST be at least 2, no greater than 4096, and a multiple of 2. Excel uses 16\n                keyBits: packageKey.length * 8 // The number of bits in the package key.\n            },\n            key: { // Info on the encryption of the package key.\n                cipherAlgorithm: 'AES', // Cipher algorithm to use. Excel uses AES.\n                cipherChaining: 'ChainingModeCBC', // Cipher chaining mode to use. Excel uses CBC.\n                saltValue: crypto.randomBytes(16), // Random value to use as encryption salt. Excel uses 16 bytes.\n                hashAlgorithm: 'SHA512', // Hash algorithm to use. Excel uses SHA512.\n                hashSize: 64, // The size of the hash in bytes. SHA512 results in 64-byte hashes\n                blockSize: 16, // The number of bytes used to encrypt one block of data. It MUST be at least 2, no greater than 4096, and a multiple of 2. Excel uses 16\n                spinCount: 100000, // The number of times to iterate on a hash of a password. It MUST NOT be greater than 10,000,000. Excel uses 100,000.\n                keyBits: 256 // The length of the key to generate from the password. Must be a multiple of 8. Excel uses 256.\n            }\n        };\n\n        /* Package Encryption */\n\n        // Encrypt package using the package key.\n        const encryptedPackage = this._cryptPackage(\n            true,\n            encryptionInfo.package.cipherAlgorithm,\n            encryptionInfo.package.cipherChaining,\n            encryptionInfo.package.hashAlgorithm,\n            encryptionInfo.package.blockSize,\n            encryptionInfo.package.saltValue,\n            packageKey,\n            data\n        );\n\n        /* Data Integrity */\n\n        // Create the data integrity fields used by clients for integrity checks.\n        // First generate a random array of bytes to use in HMAC. The docs say to use the same length as the key salt, but Excel seems to use 64.\n        const hmacKey = crypto.randomBytes(64);\n\n        // Then create an initialization vector using the package encryption info and the appropriate block key.\n        const hmacKeyIV = this._createIV(\n            encryptionInfo.package.hashAlgorithm,\n            encryptionInfo.package.saltValue,\n            encryptionInfo.package.blockSize,\n            BLOCK_KEYS.dataIntegrity.hmacKey\n        );\n\n        // Use the package key and the IV to encrypt the HMAC key\n        const encryptedHmacKey = this._crypt(\n            true,\n            encryptionInfo.package.cipherAlgorithm,\n            encryptionInfo.package.cipherChaining,\n            packageKey,\n            hmacKeyIV,\n            hmacKey);\n\n        // Now create the HMAC\n        const hmacValue = this._hmac(encryptionInfo.package.hashAlgorithm, hmacKey, encryptedPackage);\n\n        // Next generate an initialization vector for encrypting the resulting HMAC value.\n        const hmacValueIV = this._createIV(\n            encryptionInfo.package.hashAlgorithm,\n            encryptionInfo.package.saltValue,\n            encryptionInfo.package.blockSize,\n            BLOCK_KEYS.dataIntegrity.hmacValue\n        );\n\n        // Now encrypt the value\n        const encryptedHmacValue = this._crypt(\n            true,\n            encryptionInfo.package.cipherAlgorithm,\n            encryptionInfo.package.cipherChaining,\n            packageKey,\n            hmacValueIV,\n            hmacValue\n        );\n\n        // Put the encrypted key and value on the encryption info\n        encryptionInfo.dataIntegrity = {\n            encryptedHmacKey,\n            encryptedHmacValue\n        };\n\n        /* Key Encryption */\n\n        // Convert the password to an encryption key\n        const key = this._convertPasswordToKey(\n            password,\n            encryptionInfo.key.hashAlgorithm,\n            encryptionInfo.key.saltValue,\n            encryptionInfo.key.spinCount,\n            encryptionInfo.key.keyBits,\n            BLOCK_KEYS.key\n        );\n\n        // Encrypt the package key with the\n        encryptionInfo.key.encryptedKeyValue = this._crypt(\n            true,\n            encryptionInfo.key.cipherAlgorithm,\n            encryptionInfo.key.cipherChaining,\n            key,\n            encryptionInfo.key.saltValue,\n            packageKey);\n\n        /* Verifier hash */\n\n        // Create a random byte array for hashing\n        const verifierHashInput = crypto.randomBytes(16);\n\n        // Create an encryption key from the password for the input\n        const verifierHashInputKey = this._convertPasswordToKey(\n            password,\n            encryptionInfo.key.hashAlgorithm,\n            encryptionInfo.key.saltValue,\n            encryptionInfo.key.spinCount,\n            encryptionInfo.key.keyBits,\n            BLOCK_KEYS.verifierHash.input\n        );\n\n        // Use the key to encrypt the verifier input\n        encryptionInfo.key.encryptedVerifierHashInput = this._crypt(\n            true,\n            encryptionInfo.key.cipherAlgorithm,\n            encryptionInfo.key.cipherChaining,\n            verifierHashInputKey,\n            encryptionInfo.key.saltValue,\n            verifierHashInput\n        );\n\n        // Create a hash of the input\n        const verifierHashValue = this._hash(encryptionInfo.key.hashAlgorithm, verifierHashInput);\n\n        // Create an encryption key from the password for the hash\n        const verifierHashValueKey = this._convertPasswordToKey(\n            password,\n            encryptionInfo.key.hashAlgorithm,\n            encryptionInfo.key.saltValue,\n            encryptionInfo.key.spinCount,\n            encryptionInfo.key.keyBits,\n            BLOCK_KEYS.verifierHash.value\n        );\n\n        // Use the key to encrypt the hash value\n        encryptionInfo.key.encryptedVerifierHashValue = this._crypt(\n            true,\n            encryptionInfo.key.cipherAlgorithm,\n            encryptionInfo.key.cipherChaining,\n            verifierHashValueKey,\n            encryptionInfo.key.saltValue,\n            verifierHashValue\n        );\n\n        // Build the encryption info buffer\n        const encryptionInfoBuffer = this._buildEncryptionInfo(encryptionInfo);\n\n        // Create a new CFB\n        let output = cfb.utils.cfb_new();\n\n        // Add the encryption info and encrypted package\n        cfb.utils.cfb_add(output, \"EncryptionInfo\", encryptionInfoBuffer);\n        cfb.utils.cfb_add(output, \"EncryptedPackage\", encryptedPackage);\n\n        // Delete the SheetJS entry that is added at initialization\n        cfb.utils.cfb_del(output, \"\\u0001Sh33tJ5\");\n\n        // Write to a buffer and return\n        output = cfb.write(output);\n\n        // The cfb library writes to a Uint8array in the browser. Convert to a Buffer.\n        if (!Buffer.isBuffer(output)) output = Buffer.from(output);\n\n        return output;\n    }\n\n    /**\n     * Decrypt the data with the given password\n     * @param {Buffer} data - The data to decrypt\n     * @param {string} password - The password\n     * @returns {Promise.<Buffer>} The decrypted data\n     */\n    decryptAsync(data, password) {\n        // Parse the CFB input and pull out the encryption info and encrypted package entries.\n        const parsed = cfb.parse(data);\n        let encryptionInfoBuffer = _.find(parsed.FileIndex, { name: \"EncryptionInfo\" }).content;\n        let encryptedPackageBuffer = _.find(parsed.FileIndex, { name: \"EncryptedPackage\" }).content;\n\n        // In the browser the CFB content is an array. Convert to a Buffer.\n        if (!Buffer.isBuffer(encryptionInfoBuffer)) encryptionInfoBuffer = Buffer.from(encryptionInfoBuffer);\n        if (!Buffer.isBuffer(encryptedPackageBuffer)) encryptedPackageBuffer = Buffer.from(encryptedPackageBuffer);\n\n        return externals.Promise.resolve()\n            .then(() => this._parseEncryptionInfoAsync(encryptionInfoBuffer)) // Parse the encryption info XML into an object\n            .then(encryptionInfo => {\n                // Convert the password into an encryption key\n                const key = this._convertPasswordToKey(\n                    password,\n                    encryptionInfo.key.hashAlgorithm,\n                    encryptionInfo.key.saltValue,\n                    encryptionInfo.key.spinCount,\n                    encryptionInfo.key.keyBits,\n                    BLOCK_KEYS.key\n                );\n\n                // Use the key to decrypt the package key\n                const packageKey = this._crypt(\n                    false,\n                    encryptionInfo.key.cipherAlgorithm,\n                    encryptionInfo.key.cipherChaining,\n                    key,\n                    encryptionInfo.key.saltValue,\n                    encryptionInfo.key.encryptedKeyValue\n                );\n\n                // Use the package key to decrypt the package\n                return this._cryptPackage(\n                    false,\n                    encryptionInfo.package.cipherAlgorithm,\n                    encryptionInfo.package.cipherChaining,\n                    encryptionInfo.package.hashAlgorithm,\n                    encryptionInfo.package.blockSize,\n                    encryptionInfo.package.saltValue,\n                    packageKey,\n                    encryptedPackageBuffer);\n            });\n    }\n\n    /**\n     * Build the encryption info XML/buffer\n     * @param {{}} encryptionInfo - The encryption info object\n     * @returns {Buffer} The buffer\n     * @private\n     */\n    _buildEncryptionInfo(encryptionInfo) {\n        // Map the object into the appropriate XML structure. Buffers are encoded in base 64.\n        const encryptionInfoNode = {\n            name: \"encryption\",\n            attributes: {\n                xmlns: \"http://schemas.microsoft.com/office/2006/encryption\",\n                'xmlns:p': \"http://schemas.microsoft.com/office/2006/keyEncryptor/password\",\n                'xmlns:c': \"http://schemas.microsoft.com/office/2006/keyEncryptor/certificate\"\n            },\n            children: [\n                {\n                    name: \"keyData\",\n                    attributes: {\n                        saltSize: encryptionInfo.package.saltValue.length,\n                        blockSize: encryptionInfo.package.blockSize,\n                        keyBits: encryptionInfo.package.keyBits,\n                        hashSize: encryptionInfo.package.hashSize,\n                        cipherAlgorithm: encryptionInfo.package.cipherAlgorithm,\n                        cipherChaining: encryptionInfo.package.cipherChaining,\n                        hashAlgorithm: encryptionInfo.package.hashAlgorithm,\n                        saltValue: encryptionInfo.package.saltValue.toString(\"base64\")\n                    }\n                },\n                {\n                    name: \"dataIntegrity\",\n                    attributes: {\n                        encryptedHmacKey: encryptionInfo.dataIntegrity.encryptedHmacKey.toString(\"base64\"),\n                        encryptedHmacValue: encryptionInfo.dataIntegrity.encryptedHmacValue.toString(\"base64\")\n                    }\n                },\n                {\n                    name: \"keyEncryptors\",\n                    children: [\n                        {\n                            name: \"keyEncryptor\",\n                            attributes: {\n                                uri: \"http://schemas.microsoft.com/office/2006/keyEncryptor/password\"\n                            },\n                            children: [\n                                {\n                                    name: \"p:encryptedKey\",\n                                    attributes: {\n                                        spinCount: encryptionInfo.key.spinCount,\n                                        saltSize: encryptionInfo.key.saltValue.length,\n                                        blockSize: encryptionInfo.key.blockSize,\n                                        keyBits: encryptionInfo.key.keyBits,\n                                        hashSize: encryptionInfo.key.hashSize,\n                                        cipherAlgorithm: encryptionInfo.key.cipherAlgorithm,\n                                        cipherChaining: encryptionInfo.key.cipherChaining,\n                                        hashAlgorithm: encryptionInfo.key.hashAlgorithm,\n                                        saltValue: encryptionInfo.key.saltValue.toString(\"base64\"),\n                                        encryptedVerifierHashInput: encryptionInfo.key.encryptedVerifierHashInput.toString(\"base64\"),\n                                        encryptedVerifierHashValue: encryptionInfo.key.encryptedVerifierHashValue.toString(\"base64\"),\n                                        encryptedKeyValue: encryptionInfo.key.encryptedKeyValue.toString(\"base64\")\n                                    }\n                                }\n                            ]\n                        }\n                    ]\n                }\n            ]\n        };\n\n        // Convert to an XML string\n        const xmlBuilder = new XmlBuilder();\n        const encryptionInfoXml = xmlBuilder.build(encryptionInfoNode);\n\n        // Convert to a buffer and prefix with the appropriate bytes\n        return Buffer.concat([ENCRYPTION_INFO_PREFIX, Buffer.from(encryptionInfoXml, \"utf8\")]);\n    }\n\n    /**\n     * Parse the encryption info from the XML/buffer\n     * @param {Buffer} buffer - The buffer\n     * @returns {Promise.<{}>} The parsed encryption info object\n     * @private\n     */\n    _parseEncryptionInfoAsync(buffer) {\n        // Pull off the prefix and convert to string\n        const xml = buffer.slice(ENCRYPTION_INFO_PREFIX.length).toString(\"utf8\");\n\n        // Parse the XML\n        const xmlParser = new XmlParser();\n        return xmlParser.parseAsync(xml)\n            .then(doc => {\n                // Pull out the relevant values for decryption and return\n                const keyDataNode = xmlq.findChild(doc, \"keyData\");\n                const keyEncryptorsNode = xmlq.findChild(doc, \"keyEncryptors\");\n                const keyEncryptorNode = xmlq.findChild(keyEncryptorsNode, \"keyEncryptor\");\n                const encryptedKeyNode = xmlq.findChild(keyEncryptorNode, \"p:encryptedKey\");\n\n                return {\n                    package: {\n                        cipherAlgorithm: keyDataNode.attributes.cipherAlgorithm,\n                        cipherChaining: keyDataNode.attributes.cipherChaining,\n                        saltValue: Buffer.from(keyDataNode.attributes.saltValue, \"base64\"),\n                        hashAlgorithm: keyDataNode.attributes.hashAlgorithm,\n                        blockSize: keyDataNode.attributes.blockSize\n                    },\n                    key: {\n                        encryptedKeyValue: Buffer.from(encryptedKeyNode.attributes.encryptedKeyValue, \"base64\"),\n                        cipherAlgorithm: encryptedKeyNode.attributes.cipherAlgorithm,\n                        cipherChaining: encryptedKeyNode.attributes.cipherChaining,\n                        saltValue: Buffer.from(encryptedKeyNode.attributes.saltValue, \"base64\"),\n                        hashAlgorithm: encryptedKeyNode.attributes.hashAlgorithm,\n                        spinCount: encryptedKeyNode.attributes.spinCount,\n                        keyBits: encryptedKeyNode.attributes.keyBits\n                    }\n                };\n            });\n    }\n\n    /**\n     * Calculate a hash of the concatenated buffers with the given algorithm.\n     * @param {string} algorithm - The hash algorithm.\n     * @param {Array.<Buffer>} buffers - The buffers to concat and hash\n     * @returns {Buffer} The hash\n     * @private\n     */\n    _hash(algorithm, ...buffers) {\n        algorithm = algorithm.toLowerCase();\n        const hashes = crypto.getHashes();\n        if (hashes.indexOf(algorithm) < 0) throw new Error(`Hash algorithm '${algorithm}' not supported!`);\n\n        const hash = crypto.createHash(algorithm);\n        hash.update(Buffer.concat(buffers));\n        return hash.digest();\n    }\n\n    /**\n     * Calculate an HMAC of the concatenated buffers with the given algorithm and key\n     * @param {string} algorithm - The algorithm.\n     * @param {string} key - The key\n     * @param {Array.<Buffer>} buffers - The buffer to concat and HMAC\n     * @returns {Buffer} The HMAC\n     * @private\n     */\n    _hmac(algorithm, key, ...buffers) {\n        algorithm = algorithm.toLowerCase();\n        const hashes = crypto.getHashes();\n        if (hashes.indexOf(algorithm) < 0) throw new Error(`HMAC algorithm '${algorithm}' not supported!`);\n\n        const hmac = crypto.createHmac(algorithm, key);\n        hmac.update(Buffer.concat(buffers));\n        return hmac.digest();\n    }\n\n    /**\n     * Encrypt/decrypt input\n     * @param {boolean} encrypt - True to encrypt, false to decrypt\n     * @param {string} cipherAlgorithm - The cipher algorithm\n     * @param {sring} cipherChaining - The cipher chaining mode\n     * @param {Buffer} key - The encryption key\n     * @param {Buffer} iv - The initialization vector\n     * @param {Buffer} input - The input\n     * @returns {Buffer} The output\n     * @private\n     */\n    _crypt(encrypt, cipherAlgorithm, cipherChaining, key, iv, input) {\n        let algorithm = `${cipherAlgorithm.toLowerCase()}-${key.length * 8}`;\n        if (cipherChaining === 'ChainingModeCBC') algorithm += '-cbc';\n        else throw new Error(`Unknown cipher chaining: ${cipherChaining}`);\n\n        const cipher = crypto[encrypt ? 'createCipheriv' : 'createDecipheriv'](algorithm, key, iv);\n        cipher.setAutoPadding(false);\n        let output = cipher.update(input);\n        output = Buffer.concat([output, cipher.final()]);\n        return output;\n    }\n\n    /**\n     * Encrypt/decrypt the package\n     * @param {boolean} encrypt - True to encrypt, false to decrypt\n     * @param {string} cipherAlgorithm - The cipher algorithm\n     * @param {string} cipherChaining - The cipher chaining mode\n     * @param {string} hashAlgorithm - The hash algorithm\n     * @param {number} blockSize - The IV block size\n     * @param {Buffer} saltValue - The salt\n     * @param {Buffer} key - The encryption key\n     * @param {Buffer} input - The package input\n     * @returns {Buffer} The output\n     * @private\n     */\n    _cryptPackage(encrypt, cipherAlgorithm, cipherChaining, hashAlgorithm, blockSize, saltValue, key, input) {\n        // The first 8 bytes is supposed to be the length, but it seems like it is really the length - 4..\n        const outputChunks = [];\n        const offset = encrypt ? 0 : PACKAGE_OFFSET;\n\n        // The package is encoded in chunks. Encrypt/decrypt each and concat.\n        let i = 0, start = 0, end = 0;\n        while (end < input.length) {\n            start = end;\n            end = start + PACKAGE_ENCRYPTION_CHUNK_SIZE;\n            if (end > input.length) end = input.length;\n\n            // Grab the next chunk\n            let inputChunk = input.slice(start + offset, end + offset);\n\n            // Pad the chunk if it is not an integer multiple of the block size\n            const remainder = inputChunk.length % blockSize;\n            if (remainder) inputChunk = Buffer.concat([inputChunk, Buffer.alloc(blockSize - remainder)]);\n\n            // Create the initialization vector\n            const iv = this._createIV(hashAlgorithm, saltValue, blockSize, i);\n\n            // Encrypt/decrypt the chunk and add it to the array\n            const outputChunk = this._crypt(encrypt, cipherAlgorithm, cipherChaining, key, iv, inputChunk);\n            outputChunks.push(outputChunk);\n\n            i++;\n        }\n\n        // Concat all of the output chunks.\n        let output = Buffer.concat(outputChunks);\n\n        if (encrypt) {\n            // Put the length of the package in the first 8 bytes\n            output = Buffer.concat([this._createUInt32LEBuffer(input.length, PACKAGE_OFFSET), output]);\n        } else {\n            // Truncate the buffer to the size in the prefix\n            const length = input.readUInt32LE(0);\n            output = output.slice(0, length);\n        }\n\n        return output;\n    }\n\n    /**\n     * Create a buffer of an integer encoded as a uint32le\n     * @param {number} value - The integer to encode\n     * @param {number} [bufferSize=4] The output buffer size in bytes\n     * @returns {Buffer} The buffer\n     * @private\n     */\n    _createUInt32LEBuffer(value, bufferSize = 4) {\n        const buffer = Buffer.alloc(bufferSize);\n        buffer.writeUInt32LE(value, 0);\n        return buffer;\n    }\n\n    /**\n     * Convert a password into an encryption key\n     * @param {string} password - The password\n     * @param {string} hashAlgorithm - The hash algoritm\n     * @param {Buffer} saltValue - The salt value\n     * @param {number} spinCount - The spin count\n     * @param {number} keyBits - The length of the key in bits\n     * @param {Buffer} blockKey - The block key\n     * @returns {Buffer} The encryption key\n     * @private\n     */\n    _convertPasswordToKey(password, hashAlgorithm, saltValue, spinCount, keyBits, blockKey) {\n        // Password must be in unicode buffer\n        const passwordBuffer = Buffer.from(password, 'utf16le');\n\n        // Generate the initial hash\n        let key = this._hash(hashAlgorithm, saltValue, passwordBuffer);\n\n        // Now regenerate until spin count\n        for (let i = 0; i < spinCount; i++) {\n            const iterator = this._createUInt32LEBuffer(i);\n            key = this._hash(hashAlgorithm, iterator, key);\n        }\n\n        // Now generate the final hash\n        key = this._hash(hashAlgorithm, key, blockKey);\n\n        // Truncate or pad as needed to get to length of keyBits\n        const keyBytes = keyBits / 8;\n        if (key.length < keyBytes) {\n            const tmp = Buffer.alloc(keyBytes, 0x36);\n            key.copy(tmp);\n            key = tmp;\n        } else if (key.length > keyBytes) {\n            key = key.slice(0, keyBytes);\n        }\n\n        return key;\n    }\n\n    /**\n     * Create an initialization vector (IV)\n     * @param {string} hashAlgorithm - The hash algorithm\n     * @param {Buffer} saltValue - The salt value\n     * @param {number} blockSize - The size of the IV\n     * @param {Buffer|number} blockKey - The block key or an int to convert to a buffer\n     * @returns {Buffer} The IV\n     * @private\n     */\n    _createIV(hashAlgorithm, saltValue, blockSize, blockKey) {\n        // Create the block key from the current index\n        if (typeof blockKey === \"number\") blockKey = this._createUInt32LEBuffer(blockKey);\n\n        // Create the initialization vector by hashing the salt with the block key.\n        // Truncate or pad as needed to meet the block size.\n        let iv = this._hash(hashAlgorithm, saltValue, blockKey);\n        if (iv.length < blockSize) {\n            const tmp = Buffer.alloc(blockSize, 0x36);\n            iv.copy(tmp);\n            iv = tmp;\n        } else if (iv.length > blockSize) {\n            iv = iv.slice(0, blockSize);\n        }\n\n        return iv;\n    }\n}\n\nmodule.exports = Encryptor;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}