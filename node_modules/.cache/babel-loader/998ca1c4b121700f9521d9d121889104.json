{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.common.detector {*/\n\nvar ResultPoint_1 = require(\"../../ResultPoint\");\n\nvar MathUtils_1 = require(\"./MathUtils\");\n\nvar NotFoundException_1 = require(\"../../NotFoundException\");\n/**\n * <p>\n * Detects a candidate barcode-like rectangular region within an image. It\n * starts around the center of the image, increases the size of the candidate\n * region until it finds a white rectangular region. By keeping track of the\n * last black points it encountered, it determines the corners of the barcode.\n * </p>\n *\n * @author David Olivier\n */\n\n\nvar WhiteRectangleDetector =\n/** @class */\nfunction () {\n  // public constructor(private image: BitMatrix) /*throws NotFoundException*/ {\n  //   this(image, INIT_SIZE, image.getWidth() / 2, image.getHeight() / 2)\n  // }\n\n  /**\n   * @param image barcode image to find a rectangle in\n   * @param initSize initial size of search area around center\n   * @param x x position of search center\n   * @param y y position of search center\n   * @throws NotFoundException if image is too small to accommodate {@code initSize}\n   */\n  function WhiteRectangleDetector(image, initSize\n  /*int*/\n  , x\n  /*int*/\n  , y\n  /*int*/\n  ) {\n    this.image = image;\n    this.height = image.getHeight();\n    this.width = image.getWidth();\n\n    if (undefined === initSize || null === initSize) {\n      initSize = WhiteRectangleDetector.INIT_SIZE;\n    }\n\n    if (undefined === x || null === x) {\n      x = image.getWidth() / 2 | 0;\n    }\n\n    if (undefined === y || null === y) {\n      y = image.getHeight() / 2 | 0;\n    }\n\n    var halfsize = initSize / 2 | 0;\n    this.leftInit = x - halfsize;\n    this.rightInit = x + halfsize;\n    this.upInit = y - halfsize;\n    this.downInit = y + halfsize;\n\n    if (this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width) {\n      throw new NotFoundException_1.default();\n    }\n  }\n  /**\n   * <p>\n   * Detects a candidate barcode-like rectangular region within an image. It\n   * starts around the center of the image, increases the size of the candidate\n   * region until it finds a white rectangular region.\n   * </p>\n   *\n   * @return {@link ResultPoint}[] describing the corners of the rectangular\n   *         region. The first and last points are opposed on the diagonal, as\n   *         are the second and third. The first point will be the topmost\n   *         point and the last, the bottommost. The second point will be\n   *         leftmost and the third, the rightmost\n   * @throws NotFoundException if no Data Matrix Code can be found\n   */\n\n\n  WhiteRectangleDetector.prototype.detect = function () {\n    var left = this.leftInit;\n    var right = this.rightInit;\n    var up = this.upInit;\n    var down = this.downInit;\n    var sizeExceeded = false;\n    var aBlackPointFoundOnBorder = true;\n    var atLeastOneBlackPointFoundOnBorder = false;\n    var atLeastOneBlackPointFoundOnRight = false;\n    var atLeastOneBlackPointFoundOnBottom = false;\n    var atLeastOneBlackPointFoundOnLeft = false;\n    var atLeastOneBlackPointFoundOnTop = false;\n    var width = this.width;\n    var height = this.height;\n\n    while (aBlackPointFoundOnBorder) {\n      aBlackPointFoundOnBorder = false; // .....\n      // .   |\n      // .....\n\n      var rightBorderNotWhite = true;\n\n      while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {\n        rightBorderNotWhite = this.containsBlackPoint(up, down, right, false);\n\n        if (rightBorderNotWhite) {\n          right++;\n          aBlackPointFoundOnBorder = true;\n          atLeastOneBlackPointFoundOnRight = true;\n        } else if (!atLeastOneBlackPointFoundOnRight) {\n          right++;\n        }\n      }\n\n      if (right >= width) {\n        sizeExceeded = true;\n        break;\n      } // .....\n      // .   .\n      // .___.\n\n\n      var bottomBorderNotWhite = true;\n\n      while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {\n        bottomBorderNotWhite = this.containsBlackPoint(left, right, down, true);\n\n        if (bottomBorderNotWhite) {\n          down++;\n          aBlackPointFoundOnBorder = true;\n          atLeastOneBlackPointFoundOnBottom = true;\n        } else if (!atLeastOneBlackPointFoundOnBottom) {\n          down++;\n        }\n      }\n\n      if (down >= height) {\n        sizeExceeded = true;\n        break;\n      } // .....\n      // |   .\n      // .....\n\n\n      var leftBorderNotWhite = true;\n\n      while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {\n        leftBorderNotWhite = this.containsBlackPoint(up, down, left, false);\n\n        if (leftBorderNotWhite) {\n          left--;\n          aBlackPointFoundOnBorder = true;\n          atLeastOneBlackPointFoundOnLeft = true;\n        } else if (!atLeastOneBlackPointFoundOnLeft) {\n          left--;\n        }\n      }\n\n      if (left < 0) {\n        sizeExceeded = true;\n        break;\n      } // .___.\n      // .   .\n      // .....\n\n\n      var topBorderNotWhite = true;\n\n      while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {\n        topBorderNotWhite = this.containsBlackPoint(left, right, up, true);\n\n        if (topBorderNotWhite) {\n          up--;\n          aBlackPointFoundOnBorder = true;\n          atLeastOneBlackPointFoundOnTop = true;\n        } else if (!atLeastOneBlackPointFoundOnTop) {\n          up--;\n        }\n      }\n\n      if (up < 0) {\n        sizeExceeded = true;\n        break;\n      }\n\n      if (aBlackPointFoundOnBorder) {\n        atLeastOneBlackPointFoundOnBorder = true;\n      }\n    }\n\n    if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {\n      var maxSize = right - left;\n      var z = null;\n\n      for (var i = 1; z === null && i < maxSize; i++) {\n        z = this.getBlackPointOnSegment(left, down - i, left + i, down);\n      }\n\n      if (z == null) {\n        throw new NotFoundException_1.default();\n      }\n\n      var t = null; // go down right\n\n      for (var i = 1; t === null && i < maxSize; i++) {\n        t = this.getBlackPointOnSegment(left, up + i, left + i, up);\n      }\n\n      if (t == null) {\n        throw new NotFoundException_1.default();\n      }\n\n      var x = null; // go down left\n\n      for (var i = 1; x === null && i < maxSize; i++) {\n        x = this.getBlackPointOnSegment(right, up + i, right - i, up);\n      }\n\n      if (x == null) {\n        throw new NotFoundException_1.default();\n      }\n\n      var y = null; // go up left\n\n      for (var i = 1; y === null && i < maxSize; i++) {\n        y = this.getBlackPointOnSegment(right, down - i, right - i, down);\n      }\n\n      if (y == null) {\n        throw new NotFoundException_1.default();\n      }\n\n      return this.centerEdges(y, z, x, t);\n    } else {\n      throw new NotFoundException_1.default();\n    }\n  };\n\n  WhiteRectangleDetector.prototype.getBlackPointOnSegment = function (aX\n  /*float*/\n  , aY\n  /*float*/\n  , bX\n  /*float*/\n  , bY\n  /*float*/\n  ) {\n    var dist = MathUtils_1.default.round(MathUtils_1.default.distance(aX, aY, bX, bY));\n    var xStep = (bX - aX) / dist;\n    var yStep = (bY - aY) / dist;\n    var image = this.image;\n\n    for (var i = 0; i < dist; i++) {\n      var x = MathUtils_1.default.round(aX + i * xStep);\n      var y = MathUtils_1.default.round(aY + i * yStep);\n\n      if (image.get(x, y)) {\n        return new ResultPoint_1.default(x, y);\n      }\n    }\n\n    return null;\n  };\n  /**\n   * recenters the points of a constant distance towards the center\n   *\n   * @param y bottom most point\n   * @param z left most point\n   * @param x right most point\n   * @param t top most point\n   * @return {@link ResultPoint}[] describing the corners of the rectangular\n   *         region. The first and last points are opposed on the diagonal, as\n   *         are the second and third. The first point will be the topmost\n   *         point and the last, the bottommost. The second point will be\n   *         leftmost and the third, the rightmost\n   */\n\n\n  WhiteRectangleDetector.prototype.centerEdges = function (y, z, x, t) {\n    //\n    //       t            t\n    //  z                      x\n    //        x    OR    z\n    //   y                    y\n    //\n    var yi = y.getX();\n    var yj = y.getY();\n    var zi = z.getX();\n    var zj = z.getY();\n    var xi = x.getX();\n    var xj = x.getY();\n    var ti = t.getX();\n    var tj = t.getY();\n    var CORR = WhiteRectangleDetector.CORR;\n\n    if (yi < this.width / 2.0) {\n      return [new ResultPoint_1.default(ti - CORR, tj + CORR), new ResultPoint_1.default(zi + CORR, zj + CORR), new ResultPoint_1.default(xi - CORR, xj - CORR), new ResultPoint_1.default(yi + CORR, yj - CORR)];\n    } else {\n      return [new ResultPoint_1.default(ti + CORR, tj + CORR), new ResultPoint_1.default(zi + CORR, zj - CORR), new ResultPoint_1.default(xi - CORR, xj + CORR), new ResultPoint_1.default(yi - CORR, yj - CORR)];\n    }\n  };\n  /**\n   * Determines whether a segment contains a black point\n   *\n   * @param a          min value of the scanned coordinate\n   * @param b          max value of the scanned coordinate\n   * @param fixed      value of fixed coordinate\n   * @param horizontal set to true if scan must be horizontal, false if vertical\n   * @return true if a black point has been found, else false.\n   */\n\n\n  WhiteRectangleDetector.prototype.containsBlackPoint = function (a\n  /*int*/\n  , b\n  /*int*/\n  , fixed\n  /*int*/\n  , horizontal) {\n    var image = this.image;\n\n    if (horizontal) {\n      for (var x = a; x <= b; x++) {\n        if (image.get(x, fixed)) {\n          return true;\n        }\n      }\n    } else {\n      for (var y = a; y <= b; y++) {\n        if (image.get(fixed, y)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  WhiteRectangleDetector.INIT_SIZE = 10;\n  WhiteRectangleDetector.CORR = 1;\n  return WhiteRectangleDetector;\n}();\n\nexports.default = WhiteRectangleDetector;","map":{"version":3,"sources":["../../../../src/core/common/detector/WhiteRectangleDetector.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;AAcG;;;;;AAEH;;AAEA,IAAA,aAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AAGA,IAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,IAAA,mBAAA,GAAA,OAAA,CAAA,yBAAA,CAAA;AAEA;;;;;;;;;AASG;;;AACH,IAAA,sBAAA;AAAA;AAAA,YAAA;EAYI;EACA;EACA;;EAEA;;;;;;AAMG;EACH,SAAA,sBAAA,CAA2B,KAA3B,EAA6C;EAAkB;EAA/D,EAAwE;EAAW;EAAnF,EAA4F;EAAW;EAAvG,EAA8G;IAAnF,KAAA,KAAA,GAAA,KAAA;IACvB,KAAK,MAAL,GAAc,KAAK,CAAC,SAAN,EAAd;IACA,KAAK,KAAL,GAAa,KAAK,CAAC,QAAN,EAAb;;IACA,IAAI,SAAS,KAAK,QAAd,IAA0B,SAAS,QAAvC,EAAiD;MAC7C,QAAQ,GAAG,sBAAsB,CAAC,SAAlC;IACH;;IACD,IAAI,SAAS,KAAK,CAAd,IAAmB,SAAS,CAAhC,EAAmC;MAC/B,CAAC,GAAG,KAAK,CAAC,QAAN,KAAmB,CAAnB,GAAuB,CAA3B;IACH;;IACD,IAAI,SAAS,KAAK,CAAd,IAAmB,SAAS,CAAhC,EAAmC;MAC/B,CAAC,GAAG,KAAK,CAAC,SAAN,KAAoB,CAApB,GAAwB,CAA5B;IACH;;IACD,IAAM,QAAQ,GAAG,QAAQ,GAAG,CAAX,GAAe,CAAhC;IACA,KAAK,QAAL,GAAgB,CAAC,GAAG,QAApB;IACA,KAAK,SAAL,GAAiB,CAAC,GAAG,QAArB;IACA,KAAK,MAAL,GAAc,CAAC,GAAG,QAAlB;IACA,KAAK,QAAL,GAAgB,CAAC,GAAG,QAApB;;IACA,IAAI,KAAK,MAAL,GAAc,CAAd,IAAmB,KAAK,QAAL,GAAgB,CAAnC,IAAwC,KAAK,QAAL,IAAiB,KAAK,MAA9D,IAAwE,KAAK,SAAL,IAAkB,KAAK,KAAnG,EAA0G;MACtG,MAAM,IAAI,mBAAA,CAAA,OAAJ,EAAN;IACH;EACJ;EAED;;;;;;;;;;;;;AAaG;;;EACI,sBAAA,CAAA,SAAA,CAAA,MAAA,GAAP,YAAA;IACI,IAAI,IAAI,GAAG,KAAK,QAAhB;IACA,IAAI,KAAK,GAAG,KAAK,SAAjB;IACA,IAAI,EAAE,GAAG,KAAK,MAAd;IACA,IAAI,IAAI,GAAG,KAAK,QAAhB;IACA,IAAI,YAAY,GAAY,KAA5B;IACA,IAAI,wBAAwB,GAAY,IAAxC;IACA,IAAI,iCAAiC,GAAY,KAAjD;IAEA,IAAI,gCAAgC,GAAY,KAAhD;IACA,IAAI,iCAAiC,GAAY,KAAjD;IACA,IAAI,+BAA+B,GAAY,KAA/C;IACA,IAAI,8BAA8B,GAAY,KAA9C;IAEA,IAAM,KAAK,GAAG,KAAK,KAAnB;IACA,IAAM,MAAM,GAAG,KAAK,MAApB;;IAEA,OAAO,wBAAP,EAAiC;MAE7B,wBAAwB,GAAG,KAA3B,CAF6B,CAI7B;MACA;MACA;;MACA,IAAI,mBAAmB,GAAY,IAAnC;;MACA,OAAO,CAAC,mBAAmB,IAAI,CAAC,gCAAzB,KAA8D,KAAK,GAAG,KAA7E,EAAoF;QAChF,mBAAmB,GAAG,KAAK,kBAAL,CAAwB,EAAxB,EAA4B,IAA5B,EAAkC,KAAlC,EAAyC,KAAzC,CAAtB;;QACA,IAAI,mBAAJ,EAAyB;UACrB,KAAK;UACL,wBAAwB,GAAG,IAA3B;UACA,gCAAgC,GAAG,IAAnC;QACH,CAJD,MAIO,IAAI,CAAC,gCAAL,EAAuC;UAC1C,KAAK;QACR;MACJ;;MAED,IAAI,KAAK,IAAI,KAAb,EAAoB;QAChB,YAAY,GAAG,IAAf;QACA;MACH,CAtB4B,CAwB7B;MACA;MACA;;;MACA,IAAI,oBAAoB,GAAY,IAApC;;MACA,OAAO,CAAC,oBAAoB,IAAI,CAAC,iCAA1B,KAAgE,IAAI,GAAG,MAA9E,EAAsF;QAClF,oBAAoB,GAAG,KAAK,kBAAL,CAAwB,IAAxB,EAA8B,KAA9B,EAAqC,IAArC,EAA2C,IAA3C,CAAvB;;QACA,IAAI,oBAAJ,EAA0B;UACtB,IAAI;UACJ,wBAAwB,GAAG,IAA3B;UACA,iCAAiC,GAAG,IAApC;QACH,CAJD,MAIO,IAAI,CAAC,iCAAL,EAAwC;UAC3C,IAAI;QACP;MACJ;;MAED,IAAI,IAAI,IAAI,MAAZ,EAAoB;QAChB,YAAY,GAAG,IAAf;QACA;MACH,CA1C4B,CA4C7B;MACA;MACA;;;MACA,IAAI,kBAAkB,GAAY,IAAlC;;MACA,OAAO,CAAC,kBAAkB,IAAI,CAAC,+BAAxB,KAA4D,IAAI,IAAI,CAA3E,EAA8E;QAC1E,kBAAkB,GAAG,KAAK,kBAAL,CAAwB,EAAxB,EAA4B,IAA5B,EAAkC,IAAlC,EAAwC,KAAxC,CAArB;;QACA,IAAI,kBAAJ,EAAwB;UACpB,IAAI;UACJ,wBAAwB,GAAG,IAA3B;UACA,+BAA+B,GAAG,IAAlC;QACH,CAJD,MAIO,IAAI,CAAC,+BAAL,EAAsC;UACzC,IAAI;QACP;MACJ;;MAED,IAAI,IAAI,GAAG,CAAX,EAAc;QACV,YAAY,GAAG,IAAf;QACA;MACH,CA9D4B,CAgE7B;MACA;MACA;;;MACA,IAAI,iBAAiB,GAAY,IAAjC;;MACA,OAAO,CAAC,iBAAiB,IAAI,CAAC,8BAAvB,KAA0D,EAAE,IAAI,CAAvE,EAA0E;QACtE,iBAAiB,GAAG,KAAK,kBAAL,CAAwB,IAAxB,EAA8B,KAA9B,EAAqC,EAArC,EAAyC,IAAzC,CAApB;;QACA,IAAI,iBAAJ,EAAuB;UACnB,EAAE;UACF,wBAAwB,GAAG,IAA3B;UACA,8BAA8B,GAAG,IAAjC;QACH,CAJD,MAIO,IAAI,CAAC,8BAAL,EAAqC;UACxC,EAAE;QACL;MACJ;;MAED,IAAI,EAAE,GAAG,CAAT,EAAY;QACR,YAAY,GAAG,IAAf;QACA;MACH;;MAED,IAAI,wBAAJ,EAA8B;QAC1B,iCAAiC,GAAG,IAApC;MACH;IAEJ;;IAED,IAAI,CAAC,YAAD,IAAiB,iCAArB,EAAwD;MAEpD,IAAM,OAAO,GAAG,KAAK,GAAG,IAAxB;MAEA,IAAI,CAAC,GAAuB,IAA5B;;MACA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,KAAK,IAAN,IAAc,CAAC,GAAG,OAAlC,EAA2C,CAAC,EAA5C,EAAgD;QAC5C,CAAC,GAAG,KAAK,sBAAL,CAA4B,IAA5B,EAAkC,IAAI,GAAG,CAAzC,EAA4C,IAAI,GAAG,CAAnD,EAAsD,IAAtD,CAAJ;MACH;;MAED,IAAI,CAAC,IAAI,IAAT,EAAe;QACX,MAAM,IAAI,mBAAA,CAAA,OAAJ,EAAN;MACH;;MAED,IAAI,CAAC,GAAuB,IAA5B,CAboD,CAcpD;;MACA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,KAAK,IAAN,IAAc,CAAC,GAAG,OAAlC,EAA2C,CAAC,EAA5C,EAAgD;QAC5C,CAAC,GAAG,KAAK,sBAAL,CAA4B,IAA5B,EAAkC,EAAE,GAAG,CAAvC,EAA0C,IAAI,GAAG,CAAjD,EAAoD,EAApD,CAAJ;MACH;;MAED,IAAI,CAAC,IAAI,IAAT,EAAe;QACX,MAAM,IAAI,mBAAA,CAAA,OAAJ,EAAN;MACH;;MAED,IAAI,CAAC,GAAuB,IAA5B,CAvBoD,CAwBpD;;MACA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,KAAK,IAAN,IAAc,CAAC,GAAG,OAAlC,EAA2C,CAAC,EAA5C,EAAgD;QAC5C,CAAC,GAAG,KAAK,sBAAL,CAA4B,KAA5B,EAAmC,EAAE,GAAG,CAAxC,EAA2C,KAAK,GAAG,CAAnD,EAAsD,EAAtD,CAAJ;MACH;;MAED,IAAI,CAAC,IAAI,IAAT,EAAe;QACX,MAAM,IAAI,mBAAA,CAAA,OAAJ,EAAN;MACH;;MAED,IAAI,CAAC,GAAuB,IAA5B,CAjCoD,CAkCpD;;MACA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,KAAK,IAAN,IAAc,CAAC,GAAG,OAAlC,EAA2C,CAAC,EAA5C,EAAgD;QAC5C,CAAC,GAAG,KAAK,sBAAL,CAA4B,KAA5B,EAAmC,IAAI,GAAG,CAA1C,EAA6C,KAAK,GAAG,CAArD,EAAwD,IAAxD,CAAJ;MACH;;MAED,IAAI,CAAC,IAAI,IAAT,EAAe;QACX,MAAM,IAAI,mBAAA,CAAA,OAAJ,EAAN;MACH;;MAED,OAAO,KAAK,WAAL,CAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAA1B,CAAP;IAEH,CA7CD,MA6CO;MACH,MAAM,IAAI,mBAAA,CAAA,OAAJ,EAAN;IACH;EACJ,CA3JM;;EA6JC,sBAAA,CAAA,SAAA,CAAA,sBAAA,GAAR,UAA+B;EAAU;EAAzC,EAAoD;EAAU;EAA9D,EAAyE;EAAU;EAAnF,EAA8F;EAAU;EAAxG,EAAiH;IAC7G,IAAM,IAAI,GAAG,WAAA,CAAA,OAAA,CAAU,KAAV,CAAgB,WAAA,CAAA,OAAA,CAAU,QAAV,CAAmB,EAAnB,EAAuB,EAAvB,EAA2B,EAA3B,EAA+B,EAA/B,CAAhB,CAAb;IACA,IAAM,KAAK,GAAqB,CAAC,EAAE,GAAG,EAAN,IAAY,IAA5C;IACA,IAAM,KAAK,GAAqB,CAAC,EAAE,GAAG,EAAN,IAAY,IAA5C;IAEA,IAAM,KAAK,GAAG,KAAK,KAAnB;;IAEA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,IAApB,EAA0B,CAAC,EAA3B,EAA+B;MAC3B,IAAM,CAAC,GAAG,WAAA,CAAA,OAAA,CAAU,KAAV,CAAgB,EAAE,GAAG,CAAC,GAAG,KAAzB,CAAV;MACA,IAAM,CAAC,GAAG,WAAA,CAAA,OAAA,CAAU,KAAV,CAAgB,EAAE,GAAG,CAAC,GAAG,KAAzB,CAAV;;MACA,IAAI,KAAK,CAAC,GAAN,CAAU,CAAV,EAAa,CAAb,CAAJ,EAAqB;QACjB,OAAO,IAAI,aAAA,CAAA,OAAJ,CAAgB,CAAhB,EAAmB,CAAnB,CAAP;MACH;IACJ;;IACD,OAAO,IAAP;EACH,CAfO;EAiBR;;;;;;;;;;;;AAYG;;;EACK,sBAAA,CAAA,SAAA,CAAA,WAAA,GAAR,UAAoB,CAApB,EAAoC,CAApC,EACI,CADJ,EACoB,CADpB,EACkC;IAE9B;IACA;IACA;IACA;IACA;IACA;IAEA,IAAM,EAAE,GAAqB,CAAC,CAAC,IAAF,EAA7B;IACA,IAAM,EAAE,GAAqB,CAAC,CAAC,IAAF,EAA7B;IACA,IAAM,EAAE,GAAqB,CAAC,CAAC,IAAF,EAA7B;IACA,IAAM,EAAE,GAAqB,CAAC,CAAC,IAAF,EAA7B;IACA,IAAM,EAAE,GAAqB,CAAC,CAAC,IAAF,EAA7B;IACA,IAAM,EAAE,GAAqB,CAAC,CAAC,IAAF,EAA7B;IACA,IAAM,EAAE,GAAqB,CAAC,CAAC,IAAF,EAA7B;IACA,IAAM,EAAE,GAAqB,CAAC,CAAC,IAAF,EAA7B;IAEA,IAAM,IAAI,GAAG,sBAAsB,CAAC,IAApC;;IAEA,IAAI,EAAE,GAAG,KAAK,KAAL,GAAa,GAAtB,EAA2B;MACvB,OAAO,CACH,IAAI,aAAA,CAAA,OAAJ,CAAgB,EAAE,GAAG,IAArB,EAA2B,EAAE,GAAG,IAAhC,CADG,EAEH,IAAI,aAAA,CAAA,OAAJ,CAAgB,EAAE,GAAG,IAArB,EAA2B,EAAE,GAAG,IAAhC,CAFG,EAGH,IAAI,aAAA,CAAA,OAAJ,CAAgB,EAAE,GAAG,IAArB,EAA2B,EAAE,GAAG,IAAhC,CAHG,EAIH,IAAI,aAAA,CAAA,OAAJ,CAAgB,EAAE,GAAG,IAArB,EAA2B,EAAE,GAAG,IAAhC,CAJG,CAAP;IAKH,CAND,MAMO;MACH,OAAO,CACH,IAAI,aAAA,CAAA,OAAJ,CAAgB,EAAE,GAAG,IAArB,EAA2B,EAAE,GAAG,IAAhC,CADG,EAEH,IAAI,aAAA,CAAA,OAAJ,CAAgB,EAAE,GAAG,IAArB,EAA2B,EAAE,GAAG,IAAhC,CAFG,EAGH,IAAI,aAAA,CAAA,OAAJ,CAAgB,EAAE,GAAG,IAArB,EAA2B,EAAE,GAAG,IAAhC,CAHG,EAIH,IAAI,aAAA,CAAA,OAAJ,CAAgB,EAAE,GAAG,IAArB,EAA2B,EAAE,GAAG,IAAhC,CAJG,CAAP;IAKH;EACJ,CAlCO;EAoCR;;;;;;;;AAQG;;;EACK,sBAAA,CAAA,SAAA,CAAA,kBAAA,GAAR,UAA2B;EAAU;EAArC,EAA8C;EAAU;EAAxD,EAAiE;EAAc;EAA/E,EAAwF,UAAxF,EAA2G;IAEvG,IAAM,KAAK,GAAG,KAAK,KAAnB;;IAEA,IAAI,UAAJ,EAAgB;MACZ,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,IAAI,CAArB,EAAwB,CAAC,EAAzB,EAA6B;QACzB,IAAI,KAAK,CAAC,GAAN,CAAU,CAAV,EAAa,KAAb,CAAJ,EAAyB;UACrB,OAAO,IAAP;QACH;MACJ;IACJ,CAND,MAMO;MACH,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,IAAI,CAArB,EAAwB,CAAC,EAAzB,EAA6B;QACzB,IAAI,KAAK,CAAC,GAAN,CAAU,KAAV,EAAiB,CAAjB,CAAJ,EAAyB;UACrB,OAAO,IAAP;QACH;MACJ;IACJ;;IAED,OAAO,KAAP;EACH,CAnBO;;EAjSO,sBAAA,CAAA,SAAA,GAAY,EAAZ;EACA,sBAAA,CAAA,IAAA,GAAO,CAAP;EAqTnB,OAAA,sBAAA;AAAC,CAxTD,EAAA;;kBAAqB,sB","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.common.detector {*/\nvar ResultPoint_1 = require(\"../../ResultPoint\");\nvar MathUtils_1 = require(\"./MathUtils\");\nvar NotFoundException_1 = require(\"../../NotFoundException\");\n/**\n * <p>\n * Detects a candidate barcode-like rectangular region within an image. It\n * starts around the center of the image, increases the size of the candidate\n * region until it finds a white rectangular region. By keeping track of the\n * last black points it encountered, it determines the corners of the barcode.\n * </p>\n *\n * @author David Olivier\n */\nvar WhiteRectangleDetector = /** @class */ (function () {\n    // public constructor(private image: BitMatrix) /*throws NotFoundException*/ {\n    //   this(image, INIT_SIZE, image.getWidth() / 2, image.getHeight() / 2)\n    // }\n    /**\n     * @param image barcode image to find a rectangle in\n     * @param initSize initial size of search area around center\n     * @param x x position of search center\n     * @param y y position of search center\n     * @throws NotFoundException if image is too small to accommodate {@code initSize}\n     */\n    function WhiteRectangleDetector(image, initSize /*int*/, x /*int*/, y /*int*/) {\n        this.image = image;\n        this.height = image.getHeight();\n        this.width = image.getWidth();\n        if (undefined === initSize || null === initSize) {\n            initSize = WhiteRectangleDetector.INIT_SIZE;\n        }\n        if (undefined === x || null === x) {\n            x = image.getWidth() / 2 | 0;\n        }\n        if (undefined === y || null === y) {\n            y = image.getHeight() / 2 | 0;\n        }\n        var halfsize = initSize / 2 | 0;\n        this.leftInit = x - halfsize;\n        this.rightInit = x + halfsize;\n        this.upInit = y - halfsize;\n        this.downInit = y + halfsize;\n        if (this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width) {\n            throw new NotFoundException_1.default();\n        }\n    }\n    /**\n     * <p>\n     * Detects a candidate barcode-like rectangular region within an image. It\n     * starts around the center of the image, increases the size of the candidate\n     * region until it finds a white rectangular region.\n     * </p>\n     *\n     * @return {@link ResultPoint}[] describing the corners of the rectangular\n     *         region. The first and last points are opposed on the diagonal, as\n     *         are the second and third. The first point will be the topmost\n     *         point and the last, the bottommost. The second point will be\n     *         leftmost and the third, the rightmost\n     * @throws NotFoundException if no Data Matrix Code can be found\n     */\n    WhiteRectangleDetector.prototype.detect = function () {\n        var left = this.leftInit;\n        var right = this.rightInit;\n        var up = this.upInit;\n        var down = this.downInit;\n        var sizeExceeded = false;\n        var aBlackPointFoundOnBorder = true;\n        var atLeastOneBlackPointFoundOnBorder = false;\n        var atLeastOneBlackPointFoundOnRight = false;\n        var atLeastOneBlackPointFoundOnBottom = false;\n        var atLeastOneBlackPointFoundOnLeft = false;\n        var atLeastOneBlackPointFoundOnTop = false;\n        var width = this.width;\n        var height = this.height;\n        while (aBlackPointFoundOnBorder) {\n            aBlackPointFoundOnBorder = false;\n            // .....\n            // .   |\n            // .....\n            var rightBorderNotWhite = true;\n            while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {\n                rightBorderNotWhite = this.containsBlackPoint(up, down, right, false);\n                if (rightBorderNotWhite) {\n                    right++;\n                    aBlackPointFoundOnBorder = true;\n                    atLeastOneBlackPointFoundOnRight = true;\n                }\n                else if (!atLeastOneBlackPointFoundOnRight) {\n                    right++;\n                }\n            }\n            if (right >= width) {\n                sizeExceeded = true;\n                break;\n            }\n            // .....\n            // .   .\n            // .___.\n            var bottomBorderNotWhite = true;\n            while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {\n                bottomBorderNotWhite = this.containsBlackPoint(left, right, down, true);\n                if (bottomBorderNotWhite) {\n                    down++;\n                    aBlackPointFoundOnBorder = true;\n                    atLeastOneBlackPointFoundOnBottom = true;\n                }\n                else if (!atLeastOneBlackPointFoundOnBottom) {\n                    down++;\n                }\n            }\n            if (down >= height) {\n                sizeExceeded = true;\n                break;\n            }\n            // .....\n            // |   .\n            // .....\n            var leftBorderNotWhite = true;\n            while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {\n                leftBorderNotWhite = this.containsBlackPoint(up, down, left, false);\n                if (leftBorderNotWhite) {\n                    left--;\n                    aBlackPointFoundOnBorder = true;\n                    atLeastOneBlackPointFoundOnLeft = true;\n                }\n                else if (!atLeastOneBlackPointFoundOnLeft) {\n                    left--;\n                }\n            }\n            if (left < 0) {\n                sizeExceeded = true;\n                break;\n            }\n            // .___.\n            // .   .\n            // .....\n            var topBorderNotWhite = true;\n            while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {\n                topBorderNotWhite = this.containsBlackPoint(left, right, up, true);\n                if (topBorderNotWhite) {\n                    up--;\n                    aBlackPointFoundOnBorder = true;\n                    atLeastOneBlackPointFoundOnTop = true;\n                }\n                else if (!atLeastOneBlackPointFoundOnTop) {\n                    up--;\n                }\n            }\n            if (up < 0) {\n                sizeExceeded = true;\n                break;\n            }\n            if (aBlackPointFoundOnBorder) {\n                atLeastOneBlackPointFoundOnBorder = true;\n            }\n        }\n        if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {\n            var maxSize = right - left;\n            var z = null;\n            for (var i = 1; z === null && i < maxSize; i++) {\n                z = this.getBlackPointOnSegment(left, down - i, left + i, down);\n            }\n            if (z == null) {\n                throw new NotFoundException_1.default();\n            }\n            var t = null;\n            // go down right\n            for (var i = 1; t === null && i < maxSize; i++) {\n                t = this.getBlackPointOnSegment(left, up + i, left + i, up);\n            }\n            if (t == null) {\n                throw new NotFoundException_1.default();\n            }\n            var x = null;\n            // go down left\n            for (var i = 1; x === null && i < maxSize; i++) {\n                x = this.getBlackPointOnSegment(right, up + i, right - i, up);\n            }\n            if (x == null) {\n                throw new NotFoundException_1.default();\n            }\n            var y = null;\n            // go up left\n            for (var i = 1; y === null && i < maxSize; i++) {\n                y = this.getBlackPointOnSegment(right, down - i, right - i, down);\n            }\n            if (y == null) {\n                throw new NotFoundException_1.default();\n            }\n            return this.centerEdges(y, z, x, t);\n        }\n        else {\n            throw new NotFoundException_1.default();\n        }\n    };\n    WhiteRectangleDetector.prototype.getBlackPointOnSegment = function (aX /*float*/, aY /*float*/, bX /*float*/, bY /*float*/) {\n        var dist = MathUtils_1.default.round(MathUtils_1.default.distance(aX, aY, bX, bY));\n        var xStep = (bX - aX) / dist;\n        var yStep = (bY - aY) / dist;\n        var image = this.image;\n        for (var i = 0; i < dist; i++) {\n            var x = MathUtils_1.default.round(aX + i * xStep);\n            var y = MathUtils_1.default.round(aY + i * yStep);\n            if (image.get(x, y)) {\n                return new ResultPoint_1.default(x, y);\n            }\n        }\n        return null;\n    };\n    /**\n     * recenters the points of a constant distance towards the center\n     *\n     * @param y bottom most point\n     * @param z left most point\n     * @param x right most point\n     * @param t top most point\n     * @return {@link ResultPoint}[] describing the corners of the rectangular\n     *         region. The first and last points are opposed on the diagonal, as\n     *         are the second and third. The first point will be the topmost\n     *         point and the last, the bottommost. The second point will be\n     *         leftmost and the third, the rightmost\n     */\n    WhiteRectangleDetector.prototype.centerEdges = function (y, z, x, t) {\n        //\n        //       t            t\n        //  z                      x\n        //        x    OR    z\n        //   y                    y\n        //\n        var yi = y.getX();\n        var yj = y.getY();\n        var zi = z.getX();\n        var zj = z.getY();\n        var xi = x.getX();\n        var xj = x.getY();\n        var ti = t.getX();\n        var tj = t.getY();\n        var CORR = WhiteRectangleDetector.CORR;\n        if (yi < this.width / 2.0) {\n            return [\n                new ResultPoint_1.default(ti - CORR, tj + CORR),\n                new ResultPoint_1.default(zi + CORR, zj + CORR),\n                new ResultPoint_1.default(xi - CORR, xj - CORR),\n                new ResultPoint_1.default(yi + CORR, yj - CORR)\n            ];\n        }\n        else {\n            return [\n                new ResultPoint_1.default(ti + CORR, tj + CORR),\n                new ResultPoint_1.default(zi + CORR, zj - CORR),\n                new ResultPoint_1.default(xi - CORR, xj + CORR),\n                new ResultPoint_1.default(yi - CORR, yj - CORR)\n            ];\n        }\n    };\n    /**\n     * Determines whether a segment contains a black point\n     *\n     * @param a          min value of the scanned coordinate\n     * @param b          max value of the scanned coordinate\n     * @param fixed      value of fixed coordinate\n     * @param horizontal set to true if scan must be horizontal, false if vertical\n     * @return true if a black point has been found, else false.\n     */\n    WhiteRectangleDetector.prototype.containsBlackPoint = function (a /*int*/, b /*int*/, fixed /*int*/, horizontal) {\n        var image = this.image;\n        if (horizontal) {\n            for (var x = a; x <= b; x++) {\n                if (image.get(x, fixed)) {\n                    return true;\n                }\n            }\n        }\n        else {\n            for (var y = a; y <= b; y++) {\n                if (image.get(fixed, y)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    WhiteRectangleDetector.INIT_SIZE = 10;\n    WhiteRectangleDetector.CORR = 1;\n    return WhiteRectangleDetector;\n}());\nexports.default = WhiteRectangleDetector;\n//# sourceMappingURL=WhiteRectangleDetector.js.map"]},"metadata":{},"sourceType":"script"}